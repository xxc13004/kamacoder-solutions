# 排序 + 贪心
[题目链接](https://kamacoder.com/problempage.php?pid=1395)
## 思路分析
从特殊到一般分析：

分析一下题目，我们发现，假如所有来宾的身高都不相同，那么其实要保证每一个来宾的体验，就必须保证他们的座位号与身高一一对应。也就是说每一个来宾要安排坐在第几号座位是唯一的，只需要按照身高进行排序，就能确定他们要安排的座位号，然后按照入场顺序模拟就好了。

但是实际情况不是这样，会有多个来宾身高一致的情况，那么这个时候每个入场顺序的人排在第几个座位号是不固定的，因为我们只需要保证同一个身高的人，在一个连续的区间排着就可以了，但是每个入场顺序的人排在第几位是不知道的。

所以需要一种贪心的策略来排座位，我们知道同一种身高的人，一定是坐在一起的，也就是座位号是连起来的（可能不在同一排），那么我们把同样身高的人进行分组，这一组的人所处的座位号的连续区间一定是唯一确定的，只不过内部顺序不一样。我们需要解决的就是给他们确定内部顺序，使得累积拥挤指数最小。由于晚来的人会受到先来的人的影响，所以对于同一组的人，我们按照入场时间的顺序进行倒序排序，保证后入场的人尽可能的坐在这个组更靠前的位置，这样入场时间更后的人就能最少的被与自己相同身高的人影响，对于其他身高的人，由于他们始终处于这个组的前面，或者后面，我们没法改变其他组的人影响，所以只能尽可能减少自己组内的影响。

用树状数组维护每一行到某个坐标前面的人有多少个，就说明当前这个宾客的累积拥挤值是多少。

这样就能保证累计拥挤指数是最小的。
## 复杂度分析
1. 时间复杂度：O(NlogN)，N = n * m；
2. 空间复杂度：O(N)。
## 代码实现
### Cpp
``` cpp
#include <bits/stdc++.h>
using namespace std;

struct BIT {
    int n;
    vector<int> bit;
    BIT(int n=0): n(n), bit(n+1,0) {}
    void add(int i,int delta){ while(i<=n){ bit[i]+=delta; i+=i&-i; } }
    int sum(int i){ int s=0; while(i>0){ s+=bit[i]; i-=i&-i; } return s; }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; 
    if(!(cin>>n>>m)) return 0;
    int total = n*m;
    vector<long long> h(total);
    for(int i=0;i<total;i++) cin>>h[i];

    // 1) 全局按 (height 升序, arrival 升序)
    vector<pair<long long,int>> persons(total);
    for(int i=0;i<total;i++) persons[i] = {h[i], i};
    sort(persons.begin(), persons.end(), [](auto &a, auto &b){
        if(a.first != b.first) return a.first < b.first;
        return a.second < b.second;
    });

    // 2) 按行块内再排序：height 升序, arrival 降序（把同高组在行内按到场降序放）
    vector<int> seats(total);
    for(int row=0; row<n; ++row){
        int L = row * m;
        int R = L + m;
        // 复制子块
        vector<pair<long long,int>> block(persons.begin()+L, persons.begin()+R);
        sort(block.begin(), block.end(), [](auto &a, auto &b){
            if(a.first != b.first) return a.first < b.first;
            return a.second > b.second; // arrival 降序
        });
        for(int i=0;i<m;i++) seats[L+i] = block[i].second;
    }

    // 3) arrival -> (row, col)
    vector<pair<int,int>> pos(total);
    for(int i=0;i<total;i++){
        pos[seats[i]] = {i / m, i % m};
    }

    // 4) 模拟，按到场顺序，用每行 BIT 记录已坐
    vector<BIT> bits;
    for(int i=0;i<n;i++) bits.emplace_back(m);
    long long ans = 0;
    for(int arrival=0; arrival<total; ++arrival){
        int r = pos[arrival].first;
        int c = pos[arrival].second;
        ans += bits[r].sum(c);   // 已坐在列 < c 的人数
        bits[r].add(c+1, 1);
    }
    cout << ans << "\n";
    return 0;
}

```
### Python
``` python
# Python 修正版（详细注释）
import sys

class BIT:
    def __init__(self, n):
        self.n = n
        self.bit = [0] * (n + 1)
    def add(self, i, delta):
        while i <= self.n:
            self.bit[i] += delta
            i += i & -i
    def sum(self, i):
        s = 0
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s

def main():
    data = sys.stdin.read().strip().split()
    if not data:
        return
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    total = n * m
    heights = [int(next(it)) for _ in range(total)]

    # 1) 全局按 (height asc, arrival asc) 排序（稳定）
    persons = [(heights[i], i) for i in range(total)]
    persons.sort(key=lambda x: (x[0], x[1]))

    # 2) 按行取块，每行内部对于相同 height 要按 arrival 降序排序
    #    实现方法：对每一行的子数组按 (height asc, arrival desc) 排序
    seats = [None] * total  # seats[pos] = arrival_index
    for r in range(n):
        l = r * m
        rpos = l + m
        block = persons[l:rpos]
        # 在行内：height 升，arrival 降（使同高者在行内按到场降序）
        block.sort(key=lambda x: (x[0], -x[1]))
        for i, p in enumerate(block):
            seats[l + i] = p[1]

    # 3) 建映射 arrival -> (row, col)
    pos_map = [None] * total
    for pos in range(total):
        row = pos // m
        col = pos % m
        pos_map[seats[pos]] = (row, col)

    # 4) 模拟按到场顺序入场，每人累加该行左侧已坐人数
    bits = [BIT(m) for _ in range(n)]
    ans = 0
    for arrival in range(total):
        row, col = pos_map[arrival]
        # 注意：sum(col) 计算的是已坐在列 index < col 的人数 (col: 0-based)
        ans += bits[row].sum(col)
        bits[row].add(col + 1, 1)
    print(ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    static class BIT {
        int n; int[] bit;
        BIT(int n){ this.n=n; bit=new int[n+1]; }
        void add(int i,int delta){ while(i<=n){ bit[i]+=delta; i+=i&-i; } }
        int sum(int i){ int s=0; while(i>0){ s+=bit[i]; i-=i&-i; } return s; }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] nm = br.readLine().trim().split("\\s+");
        int n = Integer.parseInt(nm[0]), m = Integer.parseInt(nm[1]);
        int total = n * m;
        String[] hs = br.readLine().trim().split("\\s+");
        long[] h = new long[total];
        for (int i = 0; i < total; i++) h[i] = Long.parseLong(hs[i]);

        // 1) 全局按 (height asc, arrival asc)
        ArrayList<long[]> persons = new ArrayList<>();
        for (int i = 0; i < total; i++) persons.add(new long[]{h[i], i});
        persons.sort((a,b)->{
            if (a[0] != b[0]) return Long.compare(a[0], b[0]);
            return Long.compare(a[1], b[1]);
        });

        // 2) 按行处理块，块内按 (height asc, arrival desc)
        int[] seats = new int[total];
        for (int row = 0; row < n; row++) {
            int L = row * m, R = L + m;
            List<long[]> block = persons.subList(L, R);
            block.sort((a,b)->{
                if (a[0] != b[0]) return Long.compare(a[0], b[0]);
                return Long.compare(b[1], a[1]); // arrival desc
            });
            for (int i = 0; i < m; i++) seats[L + i] = (int)block.get(i)[1];
        }

        // 3) arrival -> (row,col)
        int[][] pos = new int[total][2];
        for (int i = 0; i < total; i++) {
            pos[seats[i]][0] = i / m;
            pos[seats[i]][1] = i % m;
        }

        // 4) 模拟
        BIT[] bits = new BIT[n];
        for (int i = 0; i < n; i++) bits[i] = new BIT(m);
        long ans = 0;
        for (int i = 0; i < total; i++) {
            int r = pos[i][0], c = pos[i][1];
            ans += bits[r].sum(c);
            bits[r].add(c+1, 1);
        }
        System.out.println(ans);
    }
}
```
### Go
``` go
package main
import (
	"bufio"
	"fmt"
	"os"
	"sort"
)

type BIT struct {
	n int
	b []int
}
func NewBIT(n int) *BIT { return &BIT{n:n, b:make([]int,n+1)} }
func (t *BIT) add(i,delta int){ for i<=t.n { t.b[i]+=delta; i+=i&-i } }
func (t *BIT) sum(i int) int { s:=0; for i>0 { s+=t.b[i]; i-=i&-i }; return s }

func main(){
	in := bufio.NewReader(os.Stdin)
	var n,m int
	if _, err := fmt.Fscan(in, &n, &m); err!=nil { return }
	total := n*m
	h := make([]int64, total)
	for i:=0;i<total;i++ { fmt.Fscan(in, &h[i]) }

	type P struct{ val int64; id int }
	persons := make([]P, total)
	for i:=0;i<total;i++ { persons[i]=P{h[i], i} }
	// 1) 全局按 (val asc, id asc)
	sort.Slice(persons, func(i,j int) bool {
		if persons[i].val != persons[j].val { return persons[i].val < persons[j].val }
		return persons[i].id < persons[j].id
	})

	seats := make([]int, total)
	// 2) 按行块内部按 (val asc, id desc)
	for row:=0; row<n; row++ {
		L := row*m; R := L+m
		block := make([]P, m)
		copy(block, persons[L:R])
		sort.Slice(block, func(i,j int) bool {
			if block[i].val != block[j].val { return block[i].val < block[j].val }
			return block[i].id > block[j].id // id desc
		})
		for i:=0;i<m;i++ { seats[L+i] = block[i].id }
	}

	// 3) arrival -> (row,col)
	pos := make([][2]int, total)
	for i:=0;i<total;i++ { pos[seats[i]] = [2]int{i/m, i%m} }

	// 4) 模拟
	bits := make([]*BIT, n)
	for i:=0;i<n;i++ { bits[i] = NewBIT(m) }
	var ans int64 = 0
	for i:=0;i<total;i++ {
		r := pos[i][0]; c := pos[i][1]
		ans += int64(bits[r].sum(c))
		bits[r].add(c+1, 1)
	}
	fmt.Println(ans)
}
```