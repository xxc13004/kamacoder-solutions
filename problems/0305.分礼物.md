# 状态压缩 + 动态规划
[题目链接](https://kamacoder.com/problempage.php?pid=1385)
## 思路分析
提前对数组进行排序, 排序的作用是加快算法的速度, 见下面的状态转移部分. 并且计算数组的总和, 判断是否可以被k整除.

**状态定义：** 定义dp[i]为选择的集合为i时是否能划分为相等的k个子集。定义cur[i]为当前选取的数字集合为i时，最后一个子集的和。

**状态转移：** 设初始状态为dp[0] = true. 枚举所有的状态i，如果当前的状态是dp[i] = false，那么表示不能继续往下划分了, 直接跳过. 如果为true, 那么我们枚举每一个未选择的数作为下一个待选择的数, 如果cur[i] + nums[j] > eq (eq为最终答案中每个子集的值, 即我们需要划分的值, 可以提前计算出来.), 那么说明这个数不能放到当前的集合中, 直接break结束内层循环, 由于提前对数组进行了排序处理, 所以后面的数字一定是比这个数字还大的, 肯定也不行. 否则, 我们就可以将当前枚举的数字放入当前的子集中, 此时, 集合的状态就是``` next = i | 1 << j ```, 我们需要更新``` cur[next] = (cur[i] + nums[j]) % eq, dp[next] = true ```. cur取模是为了下一次下一次枚举到这个集合可以继续使用. 也就是归0的操作. 由于之前已经确保了数组的和是可以被k整除的, 并且每个子集的和又是小于等于eq的(>eq就直接break了), 那么可以推出其实每个子集的和一定是等于eq的.

**转移方程:** 
1. dp[i | 1 << j] = true if (i & 1 << j == 0 && dp[i] == true && cur[i] + nums[j] <= eq);
2. cur[i | i << j] = cur[i] + nums[j].

最后的结果就是dp[(1 << n) - 1].
## 复杂度分析
1. 时间复杂度：O(n*2^n)；
2. 空间复杂度：O(2^n)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
string solve() {
    int n, k;
    cin >> n >> k;
    vector<int> nums(n);
    for (int i = 0; i < n; ++i) cin >> nums[i];
    int sum = accumulate(nums.begin(), nums.end(), 0);
    if (sum % k != 0) return "false";
    int eq = sum / k;
    int u = 1 << n;
    sort(nums.begin(), nums.end());
    vector<int> dp(u, 0), cur(u);
    dp[0] = 1;
    for (int i = 0; i < u; ++i) {
        if (!dp[i]) continue;
        for (int j = 0; j < n; ++j) {
            if (cur[i] + nums[j] > eq) break;
            if (i & 1 << j) continue;
            if (!dp[i | 1 << j]) {
                dp[i | 1 << j] = 1;
                cur[i | 1 << j] = (cur[i] + nums[j]) % eq;
            }
        }
    }
    return dp[u - 1] ? "true" : "false";
}
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    cout << solve() << endl;
    return 0;
}
```
### Python
``` python
import sys

def solve():
    data = sys.stdin.read().split()
    n, k = int(data[0]), int(data[1])
    nums = list(map(int, data[2:2+n]))
    
    total = sum(nums)
    if total % k != 0:
        return "false"
    
    target = total // k
    nums.sort()
    
    # 如果最大值大于目标值，直接返回false
    if nums[-1] > target:
        return "false"
    
    u = 1 << n  # 状态总数
    dp = [False] * u
    cur = [0] * u
    dp[0] = True
    
    for i in range(u):
        if not dp[i]:
            continue
        for j in range(n):
            if i & (1 << j):  # 该元素已被使用
                continue
            if cur[i] + nums[j] > target:
                break  # 排序后可以提前终止
            new_state = i | (1 << j)
            if not dp[new_state]:
                dp[new_state] = True
                cur[new_state] = (cur[i] + nums[j]) % target
    
    return "true" if dp[u-1] else "false"

def main():
    print(solve())

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.util.*;
import java.io.*;

public class Main {
    public static String solve() {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        int[] nums = new int[n];
        int total = 0;
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
            total += nums[i];
        }
        
        if (total % k != 0) {
            return "false";
        }
        
        int target = total / k;
        Arrays.sort(nums);
        
        if (nums[n-1] > target) {
            return "false";
        }
        
        int u = 1 << n;
        boolean[] dp = new boolean[u];
        int[] cur = new int[u];
        dp[0] = true;
        
        for (int i = 0; i < u; i++) {
            if (!dp[i]) continue;
            for (int j = 0; j < n; j++) {
                if ((i & (1 << j)) != 0) continue;
                if (cur[i] + nums[j] > target) break;
                
                int newState = i | (1 << j);
                if (!dp[newState]) {
                    dp[newState] = true;
                    cur[newState] = (cur[i] + nums[j]) % target;
                }
            }
        }
        
        return dp[u-1] ? "true" : "false";
    }
    
    public static void main(String[] args) {
        System.out.println(solve());
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
	"strconv"
)

func solve() string {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Split(bufio.ScanWords)
	
	scanner.Scan()
	n, _ := strconv.Atoi(scanner.Text())
	scanner.Scan()
	k, _ := strconv.Atoi(scanner.Text())
	
	nums := make([]int, n)
	total := 0
	for i := 0; i < n; i++ {
		scanner.Scan()
		nums[i], _ = strconv.Atoi(scanner.Text())
		total += nums[i]
	}
	
	if total%k != 0 {
		return "false"
	}
	
	target := total / k
	sort.Ints(nums)
	
	if nums[len(nums)-1] > target {
		return "false"
	}
	
	u := 1 << uint(n)
	dp := make([]bool, u)
	cur := make([]int, u)
	dp[0] = true
	
	for i := 0; i < u; i++ {
		if !dp[i] {
			continue
		}
		for j := 0; j < n; j++ {
			if i&(1<<uint(j)) != 0 {
				continue
			}
			if cur[i]+nums[j] > target {
				break
			}
			newState := i | (1 << uint(j))
			if !dp[newState] {
				dp[newState] = true
				cur[newState] = (cur[i] + nums[j]) % target
			}
		}
	}
	
	if dp[u-1] {
		return "true"
	}
	return "false"
}

func main() {
	fmt.Println(solve())
}
```