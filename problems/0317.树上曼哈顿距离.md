# DFS
[题目链接](https://kamacoder.com/problempage.php?pid=1397)
## 思路分析
分析题目可知，我们只需要从根节点1开始遍历，每次碰到左孩子就将其坐标值改为父节点的(x - 1, y - 1)，碰到右孩子就将其坐标值改为(x + 1, y - 1)。并将每个节点的坐标值记录到数组里面即可。如何区分左右孩子？可以通过有序集合，或者排序来实现，除掉（删除掉）父节点之外，第一个元素就是左孩子，最后一个元素就是右孩子。

最后查询时将每两个点的坐标取出来直接计算即可。
## 复杂度分析
1. 时间复杂度：O(n)，每个节点只需要遍历一次；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n, q;
    cin >> n >> q;
    vector<set<int>> paths(n + 1);
    for (int i = 0, x, y; i < n - 1; ++i) {
        cin >> x >> y;
        // 自带排序
        paths[x].insert(y);
        paths[y].insert(x);
    }
    int x = 0, y = 0;  // 从根节点出发，dfs给每个节点分配权值
    vector<PII> power(n + 1);
    auto dfs = [&power, &paths](auto &&dfs, int p, int cur, int x, int y) -> void {
        auto child = paths[cur];
        child.erase(p);  // 去掉父亲
        // 确定左、右儿子
        int l = child.size() > 0 ? *child.begin() : -1;
        int r = child.size() > 1 ? *child.rbegin() : -1;
        if (l != -1) {  // 如果左孩子存在的话
            power[l] = {x - 1, y - 1};
            dfs(dfs, cur, l, x - 1, y - 1);
        }
        if (r != -1) {  // 如果右孩子存在的话
            power[r] = {x + 1, y - 1};
            dfs(dfs, cur, r, x + 1, y - 1);
        }
    };
    dfs(dfs, 1, 1, 0, 0);
    for (int i = 0, x, y; i < q; ++i) {
        cin >> x >> y;
        auto [x1, y1] = power[x];
        auto [x2, y2] = power[y];
        cout << abs(x1 - x2) + abs(y1 - y2) << endl;
    }
    return 0;
}
```
### Python
``` python
import sys
sys.setrecursionlimit(300000)

def main():
    import sys
    input = sys.stdin.readline
    
    n, q = map(int, input().split())
    
    paths = [set() for _ in range(n + 1)]
    for _ in range(n - 1):
        x, y = map(int, input().split())
        paths[x].add(y)
        paths[y].add(x)
    
    power = [None] * (n + 1)
    power[1] = (0, 0)
    
    def dfs(p, cur, x, y):
        child = paths[cur].copy()
        if p in child:
            child.remove(p)
        
        if not child:
            return
        
        # 排序子节点
        sorted_child = sorted(child)
        l = sorted_child[0]  # 左孩子（最小的）
        r = sorted_child[-1] if len(sorted_child) > 1 else None  # 右孩子（最大的）
        
        # 处理左孩子
        if l is not None:
            power[l] = (x - 1, y - 1)
            dfs(cur, l, x - 1, y - 1)
        
        # 处理右孩子
        if r is not None and r != l:  # 确保左右孩子不同
            power[r] = (x + 1, y - 1)
            dfs(cur, r, x + 1, y - 1)
    
    dfs(1, 1, 0, 0)
    
    out_lines = []
    for _ in range(q):
        x, y = map(int, input().split())
        if power[x] is None or power[y] is None:
            # 对于未分配坐标的节点，使用默认值
            x1, y1 = power[x] if power[x] is not None else (0, 0)
            x2, y2 = power[y] if power[y] is not None else (0, 0)
        else:
            x1, y1 = power[x]
            x2, y2 = power[y]
        out_lines.append(str(abs(x1 - x2) + abs(y1 - y2)))
    
    print('\n'.join(out_lines))

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    static List<TreeSet<Integer>> paths;
    static Pair[] power;
    
    static class Pair {
        int x, y;
        Pair(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int q = Integer.parseInt(st.nextToken());
        
        paths = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            paths.add(new TreeSet<>());
        }
        
        for (int i = 0; i < n - 1; i++) {
            st = new StringTokenizer(br.readLine());
            int x = Integer.parseInt(st.nextToken());
            int y = Integer.parseInt(st.nextToken());
            paths.get(x).add(y);
            paths.get(y).add(x);
        }
        
        power = new Pair[n + 1];
        power[1] = new Pair(0, 0);
        
        dfs(1, 1, 0, 0);
        
        for (int i = 0; i < q; i++) {
            st = new StringTokenizer(br.readLine());
            int x = Integer.parseInt(st.nextToken());
            int y = Integer.parseInt(st.nextToken());
            Pair p1 = power[x] != null ? power[x] : new Pair(0, 0);
            Pair p2 = power[y] != null ? power[y] : new Pair(0, 0);
            int distance = Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
            pw.println(distance);
        }
        
        pw.flush();
    }
    
    static void dfs(int p, int cur, int x, int y) {
        TreeSet<Integer> childSet = new TreeSet<>(paths.get(cur));
        childSet.remove(p);
        
        if (childSet.isEmpty()) return;
        
        Integer l = childSet.first();
        Integer r = childSet.size() > 1 ? childSet.last() : null;
        
        if (l != null) {
            power[l] = new Pair(x - 1, y - 1);
            dfs(cur, l, x - 1, y - 1);
        }
        
        if (r != null && !r.equals(l)) {
            power[r] = new Pair(x + 1, y - 1);
            dfs(cur, r, x + 1, y - 1);
        }
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
)

type Point struct {
	x, y int
}

func main() {
	reader := bufio.NewReaderSize(os.Stdin, 1<<20)
	writer := bufio.NewWriterSize(os.Stdout, 1<<20)
	defer writer.Flush()

	var n, q int
	fmt.Fscan(reader, &n, &q)

	paths := make([]map[int]bool, n+1)
	for i := range paths {
		paths[i] = make(map[int]bool)
	}

	for i := 0; i < n-1; i++ {
		var x, y int
		fmt.Fscan(reader, &x, &y)
		paths[x][y] = true
		paths[y][x] = true
	}

	power := make([]*Point, n+1)
	power[1] = &Point{0, 0}

	var dfs func(p, cur, x, y int)
	dfs = func(p, cur, x, y int) {
		children := make([]int, 0)
		for child := range paths[cur] {
			if child != p {
				children = append(children, child)
			}
		}

		if len(children) == 0 {
			return
		}

		sort.Ints(children)
		l := children[0]
		var r int
		if len(children) > 1 {
			r = children[len(children)-1]
		} else {
			r = -1
		}

		if power[l] == nil {
			power[l] = &Point{x - 1, y - 1}
			dfs(cur, l, x-1, y-1)
		}

		if r != -1 && r != l && power[r] == nil {
			power[r] = &Point{x + 1, y - 1}
			dfs(cur, r, x+1, y-1)
		}
	}

	dfs(1, 1, 0, 0)

	for i := 0; i < q; i++ {
		var x, y int
		fmt.Fscan(reader, &x, &y)
		
		var p1, p2 Point
		if power[x] != nil {
			p1 = *power[x]
		}
		if power[y] != nil {
			p2 = *power[y]
		}
		
		distance := abs(p1.x-p2.x) + abs(p1.y-p2.y)
		fmt.Fprintln(writer, distance)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}
```