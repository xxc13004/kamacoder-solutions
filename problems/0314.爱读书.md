# 动态规划
[题目链接](https://kamacoder.com/problempage.php?pid=1394)
## 思路分析
**状态定义：** dp[i][j]表示在使用j时间下读前i页书能获取的最多的知识量。

**状态转移：** 假设我们当前读到第i本书，如果正常读，能获取的知识量是book[i]，如果快速阅读，那么能获取的知识量是(book[i - 1] + book[i]) / 2，假设当前页不是第一页。所以我们就有两种可能的状态。

**状态转移：**

1. dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + book[i]), if dp[i - 1][j - 1]存在且可行；
2. dp[i][j] = max(dp[i][j], dp[i - 2][j - 1] + (book[i] + book[i - 1]) / 2), if dp[i - 2][j - 1]存在且可行。

初始时刻，dp[0][0] = 0，表示不花时间读0页书，能获取到0知识。并且将dp数组初始化为一个负数，表示不可行的状态。最后的答案就是dp[i]的最大值，注意此时的答案不是dp[n][m]，因为m有可能大于n，所以时间特别充裕的情况下，我们是不能花多个时间读同一页书的。故答案应该在j <= min(m, n)的情况中产生。另外dp数组记得定义为浮点数类型。
## 复杂度分析
1. 时间复杂度：O(n * m)；
2. 空间复杂度：O(n * m)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n, m;
    cin >> n >> m;
    vector<int> nums(n);
    for (int i = 0; i < n; ++i) cin >> nums[i];
    // 注意数组初始化为double
    vector<vector<double>> dp(n + 1, vector<double> (m + 1, -1.0));
    dp[0][0] = 0.0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (dp[i - 1][j - 1] >= 0) {  // 不能是负数，表示前一个状态可行
                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + nums[i - 1]);
            }
            if (i >= 2 && dp[i - 2][j - 1] >= 0) {
                double x = nums[i - 1] + nums[i - 2];
                dp[i][j] = max(dp[i][j], dp[i - 2][j - 1] + x / 2);
            }
        }
    }
    // 可能会有m > n的情况，所以得求过程中的最大值。
    double ans = -1.0;
    for (int i = 1; i <= m; ++i) ans = max(ans, dp[n][i]);
    if (ans < 0) {
        cout << -1 << endl;
    } else {
        printf("%.1lf\n", ans);
    }
    return 0;
}
```
### Python
``` python
import sys

def main():
    data = sys.stdin.read().split()
    n, m = int(data[0]), int(data[1])
    nums = list(map(int, data[2:2+n]))
    
    # 初始化dp数组
    dp = [[-1.0] * (m + 1) for _ in range(n + 1)]
    dp[0][0] = 0.0
    
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if dp[i - 1][j - 1] >= 0:
                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + nums[i - 1])
            if i >= 2 and dp[i - 2][j - 1] >= 0:
                x = nums[i - 1] + nums[i - 2]
                dp[i][j] = max(dp[i][j], dp[i - 2][j - 1] + x / 2)
    
    # 寻找最大值
    ans = -1.0
    for j in range(1, m + 1):
        ans = max(ans, dp[n][j])
    
    if ans < 0:
        print(-1)
    else:
        print(f"{ans:.1f}")

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        
        int[] nums = new int[n];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            nums[i] = Integer.parseInt(st.nextToken());
        }
        
        // 初始化dp数组
        double[][] dp = new double[n + 1][m + 1];
        for (int i = 0; i <= n; i++) {
            Arrays.fill(dp[i], -1.0);
        }
        dp[0][0] = 0.0;
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (dp[i - 1][j - 1] >= 0) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + nums[i - 1]);
                }
                if (i >= 2 && dp[i - 2][j - 1] >= 0) {
                    double x = nums[i - 1] + nums[i - 2];
                    dp[i][j] = Math.max(dp[i][j], dp[i - 2][j - 1] + x / 2.0);
                }
            }
        }
        
        // 寻找最大值
        double ans = -1.0;
        for (int j = 1; j <= m; j++) {
            ans = Math.max(ans, dp[n][j]);
        }
        
        if (ans < 0) {
            System.out.println(-1);
        } else {
            System.out.printf("%.1f\n", ans);
        }
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	const bufferSize = 1 << 20
	reader := bufio.NewReaderSize(os.Stdin, bufferSize)
	writer := bufio.NewWriterSize(os.Stdout, bufferSize)
	defer writer.Flush()

	var n, m int
	fmt.Fscan(reader, &n, &m)

	nums := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Fscan(reader, &nums[i])
	}

	// 初始化dp数组
	dp := make([][]float64, n+1)
	for i := range dp {
		dp[i] = make([]float64, m+1)
		for j := range dp[i] {
			dp[i][j] = -1.0
		}
	}
	dp[0][0] = 0.0

	for i := 1; i <= n; i++ {
		for j := 1; j <= m; j++ {
			if dp[i-1][j-1] >= 0 {
				dp[i][j] = max(dp[i][j], dp[i-1][j-1]+float64(nums[i-1]))
			}
			if i >= 2 && dp[i-2][j-1] >= 0 {
				x := float64(nums[i-1] + nums[i-2])
				dp[i][j] = max(dp[i][j], dp[i-2][j-1]+x/2.0)
			}
		}
	}

	// 寻找最大值
	ans := -1.0
	for j := 1; j <= m; j++ {
		ans = max(ans, dp[n][j])
	}

	if ans < 0 {
		fmt.Fprintln(writer, -1)
	} else {
		fmt.Fprintf(writer, "%.1f\n", ans)
	}
}

func max(a, b float64) float64 {
	if a > b {
		return a
	}
	return b
}
```