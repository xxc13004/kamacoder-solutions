# 动态规划
[题目链接](https://kamacoder.com/problempage.php?pid=1400)
## 思路分析
这道题需要将其转化为一个动态规划的背包类的问题，具体转化如下：

经典背包问题的定义如下：一个背包容量为k，我们要尽可能装更多的宝物，每件宝物体积为w，价值为v。

 对于每个奖励点 i：
  - 若对手 j 投资 a[j][i]，要击败他至少需 2 * a[j][i] + 1。
  - 排序这些阈值，若投入 x 元，则能打败所有阈值 <= x 的对手。
  - 于是每个奖励点形成“选 c 个对手要 **花费 arr[c-1] 元，得分 = (i+1)\*c”** 的若干选项。也就是说对于一个经典背包问题，这里的花费就是w，能获得的价值v就是得分。
  - 通过背包对所有奖励点进行求解，求总得分最大。

对每一个点进行操作，即纵向操作，由于同一号点的得分是相同的，不管从谁的手上抢走，得分都是i。所以纵向看每个点，计算打败他需要的最小投入，然后将这些投入排序，枚举在这个点我们要打败多少个人才行。假设打败c个人，在这个点就可以获得c * (i + 1)的得分，那么需要的花费就是排序后的花费数组的下标c - 1对应的元素。

后续的操作就是枚举，然后背包的过程。时间复杂度在可接受的范围内，python的代码可以自行优化。
## 复杂度分析
1. 时间复杂度：O(n * m * s)；
2. 空间复杂度：O(m)。
## 代码实现
### Cpp
``` cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int s, n, m;
    if (!(cin >> s >> n >> m)) return 0;

    vector<vector<int>> a(s, vector<int>(n));
    for (int i = 0; i < s; ++i)
        for (int j = 0; j < n; ++j)
            cin >> a[i][j];

    const int NEG = -1e9;
    vector<int> dp(m + 1, NEG);
    dp[0] = 0;

    for (int i = 0; i < n; ++i) {
        // 收集每个奖励点的阈值
        vector<int> arr(s);
        for (int j = 0; j < s; ++j) arr[j] = 2 * a[j][i] + 1;
        sort(arr.begin(), arr.end());

        // 生成可选方案
        vector<pair<int, int>> options;
        for (int c = 1; c <= s; ++c) {
            int cost = arr[c - 1];
            if (cost > m) break;
            options.emplace_back(cost, (i + 1) * c);
        }

        // 背包：对该奖励点选一个方案（或不选）
        vector<int> ndp = dp;
        for (auto [cost, val] : options) {
            for (int w = cost; w <= m; ++w) {
                if (dp[w - cost] != NEG)
                    ndp[w] = max(ndp[w], dp[w - cost] + val);
            }
        }
        dp.swap(ndp);
    }

    int ans = *max_element(dp.begin(), dp.end());
    cout << max(ans, 0) << '\n';
    return 0;
}

```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    static final int NEG = -1000000000;

    static class FastScanner {
        private final byte[] buf = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;
        FastScanner(InputStream in) { this.in = in; }
        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buf);
                ptr = 0;
                if (len <= 0) return -1;
            }
            return buf[ptr++];
        }
        int nextInt() throws IOException {
            int c, sign = 1, x = 0;
            do c = readByte(); while (c <= 32 && c >= 0);
            if (c == '-') { sign = -1; c = readByte(); }
            for (; c > 32 && c >= 0; c = readByte())
                x = x * 10 + (c - '0');
            return x * sign;
        }
    }

    public static void main(String[] args) throws Exception {
        FastScanner fs = new FastScanner(System.in);
        StringBuilder sb = new StringBuilder();
        int s = fs.nextInt(), n = fs.nextInt(), m = fs.nextInt();

        int[][] a = new int[s][n];
        for (int i = 0; i < s; i++)
            for (int j = 0; j < n; j++)
                a[i][j] = fs.nextInt();

        int[] dp = new int[m + 1];
        Arrays.fill(dp, NEG);
        dp[0] = 0;

        for (int i = 0; i < n; i++) {
            int[] arr = new int[s];
            for (int j = 0; j < s; j++) arr[j] = 2 * a[j][i] + 1;
            Arrays.sort(arr);

            List<int[]> options = new ArrayList<>();
            for (int c = 1; c <= s; c++) {
                int cost = arr[c - 1];
                if (cost > m) break;
                options.add(new int[]{cost, (i + 1) * c});
            }

            int[] ndp = dp.clone();
            for (int[] opt : options) {
                int cost = opt[0], val = opt[1];
                for (int w = cost; w <= m; w++) {
                    if (dp[w - cost] != NEG)
                        ndp[w] = Math.max(ndp[w], dp[w - cost] + val);
                }
            }
            dp = ndp;
        }

        int ans = 0;
        for (int x : dp) ans = Math.max(ans, x);
        System.out.println(ans);
    }
}

```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
)

func main() {
	in := bufio.NewReaderSize(os.Stdin, 1<<20)
	var s, n, m int
	fmt.Fscan(in, &s, &n, &m)

	a := make([][]int, s)
	for i := range a {
		a[i] = make([]int, n)
		for j := 0; j < n; j++ {
			fmt.Fscan(in, &a[i][j])
		}
	}

	const NEG = -1000000000
	dp := make([]int, m+1)
	for i := 1; i <= m; i++ {
		dp[i] = NEG
	}

	for i := 0; i < n; i++ {
		arr := make([]int, s)
		for j := 0; j < s; j++ {
			arr[j] = 2*a[j][i] + 1
		}
		sort.Ints(arr)

		options := make([][2]int, 0)
		for c := 1; c <= s; c++ {
			cost := arr[c-1]
			if cost > m {
				break
			}
			val := (i + 1) * c
			options = append(options, [2]int{cost, val})
		}

		ndp := make([]int, len(dp))
		copy(ndp, dp)
		for _, opt := range options {
			cost, val := opt[0], opt[1]
			for w := cost; w <= m; w++ {
				if dp[w-cost] != NEG {
					cand := dp[w-cost] + val
					if cand > ndp[w] {
						ndp[w] = cand
					}
				}
			}
		}
		dp = ndp
	}

	ans := 0
	for _, v := range dp {
		if v > ans {
			ans = v
		}
	}
	fmt.Println(ans)
}


```
