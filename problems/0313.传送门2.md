# 前缀和 + 前后缀分解
[题目链接](https://kamacoder.com/problempage.php?pid=1393)
## 思路分析
本题是只能按顺序进行传送，并且求的还是每一次过程中的可能最远距离，所以不能只用单纯的前缀和进行求解，因为前缀和只能做到求最终结果的最远距离。所以可以对前缀和进行前后缀分解。

我们先对所有传送门求解前缀和，然后求出不翻转的答案。假设prefix[i]表示到达点i时不翻转的距离。然后我们枚举每一个点i作为翻转点，对于j >= i时有如下距离公式：

``` dj = prefix[j] - 2 * prefix[i] ```

因为翻转过后，我们需要将其减掉，并且反转了本身也变成了负值，所以要减2倍。简单来说就是翻转操作会使prefix[i] 变成 -prefix[i] 所以这个差值其实是两倍的prefix[i]。

因为题意要求每个点可能到达的最远距离，即对于每个j来说的最远距离，且由于我们不能直接枚举j，因为这样时间复杂度就是n^2的。所以需要提前对prefix进行预处理，求出后缀的最大值mx[i]和最小mn[i]。表示以i为分割点的时候，后面能到达的最远的距离就只会在```d1 = mx[i] - 2 * prefix[i]```和```d2 = mn[i] - 2 * prefix[i]```中产生。

所以ans = max(ans, abs(d1), abs(d2))。

注：这题也可以使用状态机dp进行求解。

## 复杂度分析
1. 时间复杂度：O(n)；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n;
    cin >> n;
    vector<int> nums(n);
    for (int i = 0; i < n; ++i) cin >> nums[i];
    // 计算前缀和 以及 记录不翻转的最远距离
    vector<LL> prefix(n + 1);
    LL ans = -1;
    for (int i = 0; i < n; ++i) {
        prefix[i + 1] = prefix[i] + nums[i];
        ans = max(ans, abs(prefix[i + 1]));
    }
    // 记录前缀和数组的 后缀 最大值和最小值
    vector<LL> mx(n + 1), mn(n + 1);
    mx[n] = prefix[n];
    mn[n] = prefix[n];
    for (int i = n - 1; i >= 0; --i) {
        mx[i] = max(mx[i + 1], prefix[i]);
        mn[i] = min(mn[i + 1], prefix[i]);
    }
    // 枚举反转点
    for (int i = 0; i <= n; ++i) {
        LL x = abs(mx[i] - prefix[i] - prefix[i]);
        LL y = abs(mn[i] - prefix[i] - prefix[i]);
        ans = max({ans, x, y});
    }
    cout << ans << endl;
    return 0;
}
```
### Python
``` python
import sys

def main():
    data = sys.stdin.read().split()
    n = int(data[0])
    nums = list(map(int, data[1:1+n]))
    
    # 计算前缀和以及记录不翻转的最远距离
    prefix = [0] * (n + 1)
    ans = -1
    for i in range(n):
        prefix[i + 1] = prefix[i] + nums[i]
        ans = max(ans, abs(prefix[i + 1]))
    
    # 记录前缀和数组的后缀最大值和最小值
    mx = [0] * (n + 1)
    mn = [0] * (n + 1)
    mx[n] = prefix[n]
    mn[n] = prefix[n]
    
    for i in range(n - 1, -1, -1):
        mx[i] = max(mx[i + 1], prefix[i])
        mn[i] = min(mn[i + 1], prefix[i])
    
    # 枚举反转点
    for i in range(n + 1):
        x = abs(mx[i] - prefix[i] - prefix[i])
        y = abs(mn[i] - prefix[i] - prefix[i])
        ans = max(ans, x, y)
    
    print(ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        int n = Integer.parseInt(br.readLine());
        int[] nums = new int[n];
        
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            nums[i] = Integer.parseInt(st.nextToken());
        }
        
        // 计算前缀和以及记录不翻转的最远距离
        long[] prefix = new long[n + 1];
        long ans = -1;
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + nums[i];
            ans = Math.max(ans, Math.abs(prefix[i + 1]));
        }
        
        // 记录前缀和数组的后缀最大值和最小值
        long[] mx = new long[n + 1];
        long[] mn = new long[n + 1];
        mx[n] = prefix[n];
        mn[n] = prefix[n];
        
        for (int i = n - 1; i >= 0; i--) {
            mx[i] = Math.max(mx[i + 1], prefix[i]);
            mn[i] = Math.min(mn[i + 1], prefix[i]);
        }
        
        // 枚举反转点
        for (int i = 0; i <= n; i++) {
            long x = Math.abs(mx[i] - prefix[i] - prefix[i]);
            long y = Math.abs(mn[i] - prefix[i] - prefix[i]);
            ans = Math.max(ans, Math.max(x, y));
        }
        
        System.out.println(ans);
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	const bufferSize = 1 << 20
	reader := bufio.NewReaderSize(os.Stdin, bufferSize)
	writer := bufio.NewWriterSize(os.Stdout, bufferSize)
	defer writer.Flush()

	var n int
	fmt.Fscan(reader, &n)

	nums := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Fscan(reader, &nums[i])
	}

	// 计算前缀和以及记录不翻转的最远距离
	prefix := make([]int64, n+1)
	ans := int64(-1)
	for i := 0; i < n; i++ {
		prefix[i+1] = prefix[i] + int64(nums[i])
		if abs64(prefix[i+1]) > ans {
			ans = abs64(prefix[i+1])
		}
	}

	// 记录前缀和数组的后缀最大值和最小值
	mx := make([]int64, n+1)
	mn := make([]int64, n+1)
	mx[n] = prefix[n]
	mn[n] = prefix[n]

	for i := n - 1; i >= 0; i-- {
		mx[i] = max64(mx[i+1], prefix[i])
		mn[i] = min64(mn[i+1], prefix[i])
	}

	// 枚举反转点
	for i := 0; i <= n; i++ {
		x := abs64(mx[i] - prefix[i] - prefix[i])
		y := abs64(mn[i] - prefix[i] - prefix[i])
		if x > ans {
			ans = x
		}
		if y > ans {
			ans = y
		}
	}

	fmt.Fprintln(writer, ans)
}

func abs64(x int64) int64 {
	if x < 0 {
		return -x
	}
	return x
}

func max64(a, b int64) int64 {
	if a > b {
		return a
	}
	return b
}

func min64(a, b int64) int64 {
	if a < b {
		return a
	}
	return b
}
```