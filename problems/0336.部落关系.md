# DFS
[题目链接](https://kamacoder.com/problempage.php?pid=1416)
## 思路分析

1. 先用dfs或者bfs求出所有联通块并为每个联通块标号。
2. 遍历每一个单元格的部族，根据标号，确定其四周（如果没出界）的所有单元格是否跟他同属于一个部族。若属于，则跳过；若不属于，则将其部族名添加到当前联通块的邻居部族集合中（利用集合去重）。
3. 最后的结果就是每个单元格所属联通块的集合的大小。

## 复杂度分析
1. 时间复杂度：O(n * m)；
2. 空间复杂度：O(n * m)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n, m;
    cin >> n >> m;
    vector<string> grids(n);
    vector<vector<int>> connect(n, vector<int> (m));
    for (int i = 0; i < n; ++i) cin >> grids[i];
    int idx = 1;  // 给每个联通块编号
    vector<vector<int>> vis(n, vector<int> (m));  // 标记是否访问过
    auto valid = [m, n](int x, int y) {
        if (x < 0 || x >= n || y < 0 || y >= m) return false;
        return true;
    };  
    function<void (int, int, int)> dfs = [&](int x, int y, int idx) {
        connect[x][y] = idx;
        vis[x][y] = 1;
        for (int i = 0; i < 4; ++i) {
            int dx = x + dir[i], dy = y + dir[i + 1];
            // 未出界，没访问过，并且部族名相等
            if (valid(dx, dy) && !vis[dx][dy] && grids[dx][dy] == grids[x][y]) {
                dfs(dx, dy, idx);
            }
        }
    };
    // 为每个联通块标号
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (!vis[i][j]) {
                dfs(i, j, idx++);
            }
        }
    }
    vector<set<char>> ans(idx);  // 记录每个部族的答案数量，这个联通块的答案是一样的，用set去重
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            for (int k = 0; k < 4; ++k) {
                int x = i + dir[k], y = j + dir[k + 1];
                if (valid(x, y) && connect[x][y] != connect[i][j]) {
                    ans[connect[i][j]].insert(grids[x][y]);
                }
            }
        }
    }
    // 输出答案
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            cout << ans[connect[i][j]].size() << ' ';
        }
        cout << endl;
    }
    return 0;
}
```
### Python
``` python
import sys
sys.setrecursionlimit(1000000)

def main():
    # 优化输入
    data = sys.stdin.read().split()
    it = iter(data)
    n = int(next(it))
    m = int(next(it))
    
    grids = [next(it) for _ in range(n)]
    
    # 方向数组：右、下、左、上
    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    # connect数组记录每个点所属的连通块编号
    connect = [[0] * m for _ in range(n)]
    vis = [[False] * m for _ in range(n)]
    idx = 1  # 连通块编号从1开始
    
    def dfs(x, y, current_idx):
        """深度优先搜索标记连通块"""
        connect[x][y] = current_idx
        vis[x][y] = True
        tribe = grids[x][y]  # 当前部族字符
        
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            # 检查边界、是否访问过、是否属于同一部族
            if 0 <= nx < n and 0 <= ny < m and not vis[nx][ny] and grids[nx][ny] == tribe:
                dfs(nx, ny, current_idx)
    
    # 标记所有连通块
    for i in range(n):
        for j in range(m):
            if not vis[i][j]:
                dfs(i, j, idx)
                idx += 1
    
    # ans[i]存储第i个连通块周围不同的邻接部族
    ans = [set() for _ in range(idx)]
    
    # 统计每个连通块周围的邻接部族
    for i in range(n):
        for j in range(m):
            current_idx = connect[i][j]
            current_tribe = grids[i][j]
            
            for dx, dy in dirs:
                ni, nj = i + dx, j + dy
                # 检查边界和是否属于不同部族
                if 0 <= ni < n and 0 <= nj < m and grids[ni][nj] != current_tribe:
                    ans[current_idx].add(grids[ni][nj])
    
    # 输出结果
    output_lines = []
    for i in range(n):
        line = []
        for j in range(m):
            line.append(str(len(ans[connect[i][j]])))
        output_lines.append(' '.join(line))
    
    sys.stdout.write('\n'.join(output_lines))

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    // 方向数组：右、下、左、上
    private static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    private static char[][] grids;
    private static int[][] connect;
    private static boolean[][] visited;
    private static int n, m;
    
    public static void main(String[] args) throws IOException {
        // 优化输入
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        
        grids = new char[n][m];
        for (int i = 0; i < n; i++) {
            String line = br.readLine();
            for (int j = 0; j < m; j++) {
                grids[i][j] = line.charAt(j);
            }
        }
        
        connect = new int[n][m];
        visited = new boolean[n][m];
        int idx = 1; // 连通块编号从1开始
        
        // 标记所有连通块
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (!visited[i][j]) {
                    dfs(i, j, idx);
                    idx++;
                }
            }
        }
        
        // ans[i]存储第i个连通块周围不同的邻接部族
        Set<Character>[] ans = new Set[idx];
        for (int i = 0; i < idx; i++) {
            ans[i] = new HashSet<>();
        }
        
        // 统计每个连通块周围的邻接部族
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int currentIdx = connect[i][j];
                char currentTribe = grids[i][j];
                
                for (int[] dir : dirs) {
                    int ni = i + dir[0];
                    int nj = j + dir[1];
                    
                    // 检查边界和是否属于不同部族
                    if (ni >= 0 && ni < n && nj >= 0 && nj < m 
                        && grids[ni][nj] != currentTribe) {
                        ans[currentIdx].add(grids[ni][nj]);
                    }
                }
            }
        }
        
        // 输出结果
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                sb.append(ans[connect[i][j]].size());
                if (j < m - 1) sb.append(' ');
            }
            if (i < n - 1) sb.append('\n');
        }
        System.out.print(sb.toString());
    }
    
    // 深度优先搜索标记连通块
    private static void dfs(int x, int y, int idx) {
        connect[x][y] = idx;
        visited[x][y] = true;
        char tribe = grids[x][y];
        
        for (int[] dir : dirs) {
            int nx = x + dir[0];
            int ny = y + dir[1];
            
            // 检查边界、是否访问过、是否属于同一部族
            if (nx >= 0 && nx < n && ny >= 0 && ny < m 
                && !visited[nx][ny] && grids[nx][ny] == tribe) {
                dfs(nx, ny, idx);
            }
        }
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
)

var (
	grids    [][]byte
	connect  [][]int
	visited  [][]bool
	n, m     int
)

// 方向数组：右、下、左、上
var dirs = [4][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}

func dfs(x, y, idx int) {
	// 深度优先搜索标记连通块
	connect[x][y] = idx
	visited[x][y] = true
	tribe := grids[x][y]
	
	for _, dir := range dirs {
		nx, ny := x+dir[0], y+dir[1]
		// 检查边界、是否访问过、是否属于同一部族
		if nx >= 0 && nx < n && ny >= 0 && ny < m && 
		   !visited[nx][ny] && grids[nx][ny] == tribe {
			dfs(nx, ny, idx)
		}
	}
}

func main() {
	// 优化输入
	reader := bufio.NewReader(os.Stdin)
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()
	
	fmt.Fscan(reader, &n, &m)
	
	grids = make([][]byte, n)
	connect = make([][]int, n)
	visited = make([][]bool, n)
	
	for i := 0; i < n; i++ {
		var line string
		fmt.Fscan(reader, &line)
		grids[i] = []byte(line)
		connect[i] = make([]int, m)
		visited[i] = make([]bool, m)
	}
	
	idx := 1 // 连通块编号从1开始
	
	// 标记所有连通块
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			if !visited[i][j] {
				dfs(i, j, idx)
				idx++
			}
		}
	}
	
	// ans[i]存储第i个连通块周围不同的邻接部族
	ans := make([]map[byte]bool, idx)
	for i := range ans {
		ans[i] = make(map[byte]bool)
	}
	
	// 统计每个连通块周围的邻接部族
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			currentIdx := connect[i][j]
			currentTribe := grids[i][j]
			
			for _, dir := range dirs {
				ni, nj := i+dir[0], j+dir[1]
				// 检查边界和是否属于不同部族
				if ni >= 0 && ni < n && nj >= 0 && nj < m && 
				   grids[ni][nj] != currentTribe {
					ans[currentIdx][grids[ni][nj]] = true
				}
			}
		}
	}
	
	// 输出结果
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			fmt.Fprint(writer, len(ans[connect[i][j]]))
			if j < m-1 {
				fmt.Fprint(writer, " ")
			}
		}
		if i < n-1 {
			fmt.Fprintln(writer)
		}
	}
}
```