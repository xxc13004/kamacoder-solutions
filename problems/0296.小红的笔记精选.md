# 位运算 + 排序 + 哈希表
[题目链接](https://kamacoder.com/problempage.php?pid=1376)
## 思路分析
这个题目，其实每个数的下一个数都是固定的，我们这里简称next。问题是怎么求这个下一个数。

考虑这样一个二进制串，100101，他的next是什么？应该是100110，即对这个数直接+1就可以得到了。100110的next是什么，是101001，即对原数字+3。1000100的next是什么？是1001000，对原数字+4。

这里其实已经有规律了，我们要把一个二进制增大并且还要1的位数与原串一样多，那么需要找到最小改变量。这个最小改变量就是低位1之后遇到的第一个0及其之后的位数，例如：100101，他的最小改变量是01；100110的最小改变量是0110，注意，低位1后面的第一个0，由于最低位的0前面没有1，所以要继续往后找；1000100的最小改变量是0100。我们要将这个数增大，同时还要保证1的数量相等，那么一定要增加到这个0变成1为止，这也是为什么要找0的原因。

例如：01 -> 10; 0110 -> 1000; 0100 -> 1000;

我们知道最小改变量有几位，直接在最高为添加1，后续补0就可以了，可以用位运算很容易得到。但是要注意下面的配平操作，见下面第二点。

递增的差就是这两个二进制相减的结果:

1. 10 - 01 = 1, 即对原数字+1；
2. 1000 - 0110 = 2， 但是上面的答案是3，因为我们没有将1进行平衡，这个最小改变量是有两个1的，要想平衡1的数量，还得在末尾再补一个1，所以应该是1001 - 0110 = 3，即对原数字+3。同理如果是011110这样的最小改变量，我们就应该变成100111，剩下的1补在最低位就是最小的结果，算是一种贪心的思路。
3. 1000 - 0100 = 4，即对原数字+4.

综上知，我们先找到最小的改变量，并且配平1的数量，然后做差计算next。由于next是唯一的且严格大于当前的数字，所以对数字进行从小到大排序可以很方便的计算出最长序列。
## 复杂度分析
1. 时间复杂度：O(nlog(n))；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int next(int x) {
    int cnt = 0;  // 找到0的位置，为了计算递增差
    int end = 0, start = 0;  // 计算递增差
    int y = x;  // 副本
    while ((y & 1) == 0) y >>= 1, cnt++;
    while (1) {
        if ((y & 1) == 0) {
            end = 1 << cnt;  // 变成10000的格式
            start = ((1 << cnt) - 1) & x;  // 取出最小改变量
            break;
        }
        y >>= 1;
        ++cnt;
    }
    return x + end - start + (1 << (__builtin_popcount(start) - 1)) - 1;  // 后面一坨为了平衡1的数量
}
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n;
    cin >> n;
    vector<int> nums(n);
    for (int i = 0; i < n; ++i) cin >> nums[i];
    sort(nums.begin(), nums.end());
    unordered_map<int, int> ump;
    for (int i = 0; i < n; ++i) {
        ump[next(nums[i])] = ump[nums[i]] + 1;
    }
    int ans = 1;
    for (const auto &[_, y] : ump) {
        ans = max(ans, y);
    }
    cout << ans << endl;
    return 0;
}
```
### Python
``` python
import sys
from collections import defaultdict

def popcount(x):
    """计算二进制中1的个数"""
    return bin(x).count('1')

def next_val(x):
    cnt = 0  # 找到0的位置，为了计算递增差
    end, start = 0, 0  # 计算递增差
    y = x  # 副本
    while (y & 1) == 0:
        y >>= 1
        cnt += 1
    while True:
        if (y & 1) == 0:
            end = 1 << cnt  # 变成10000的格式
            start = ((1 << cnt) - 1) & x  # 取出最小改变量
            break
        y >>= 1
        cnt += 1
    # 后面一坨为了平衡1的数量
    return x + end - start + (1 << (popcount(start) - 1)) - 1

def main():
    data = sys.stdin.read().split()
    if not data:
        return
    
    n = int(data[0])
    nums = list(map(int, data[1:1+n]))
    
    nums.sort()
    ump = defaultdict(int)
    
    for num in nums:
        next_num = next_val(num)
        ump[next_num] = ump.get(num, 0) + 1
    
    ans = 1
    for count in ump.values():
        ans = max(ans, count)
    
    print(ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.util.*;
import java.io.*;

public class Main {
    // 计算二进制中1的个数
    private static int popcount(int x) {
        int count = 0;
        while (x != 0) {
            count += x & 1;
            x >>>= 1;
        }
        return count;
    }
    
    private static int next(int x) {
        int cnt = 0;  // 找到0的位置，为了计算递增差
        int end = 0, start = 0;  // 计算递增差
        int y = x;  // 副本
        while ((y & 1) == 0) {
            y >>= 1;
            cnt++;
        }
        while (true) {
            if ((y & 1) == 0) {
                end = 1 << cnt;  // 变成10000的格式
                start = ((1 << cnt) - 1) & x;  // 取出最小改变量
                break;
            }
            y >>= 1;
            ++cnt;
        }
        return x + end - start + (1 << (popcount(start) - 1)) - 1;  // 后面一坨为了平衡1的数量
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int[] nums = new int[n];
        
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            nums[i] = Integer.parseInt(st.nextToken());
        }
        
        Arrays.sort(nums);
        Map<Integer, Integer> ump = new HashMap<>();
        
        for (int i = 0; i < n; i++) {
            int nextVal = next(nums[i]);
            ump.put(nextVal, ump.getOrDefault(nums[i], 0) + 1);
        }
        
        int ans = 1;
        for (int count : ump.values()) {
            ans = Math.max(ans, count);
        }
        
        System.out.println(ans);
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
)

// 计算二进制中1的个数
func popcount(x int) int {
	count := 0
	for x != 0 {
		count += x & 1
		x >>= 1
	}
	return count
}

func next(x int) int {
	cnt := 0  // 找到0的位置，为了计算递增差
	end, start := 0, 0  // 计算递增差
	y := x  // 副本
	for (y & 1) == 0 {
		y >>= 1
		cnt++
	}
	for {
		if (y & 1) == 0 {
			end = 1 << uint(cnt)  // 变成10000的格式
			start = ((1 << uint(cnt)) - 1) & x  // 取出最小改变量
			break
		}
		y >>= 1
		cnt++
	}
	// 后面一坨为了平衡1的数量
	return x + end - start + (1 << uint(popcount(start) - 1)) - 1
}

func main() {
	reader := bufio.NewReader(os.Stdin)
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()

	var n int
	fmt.Fscan(reader, &n)
	
	nums := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Fscan(reader, &nums[i])
	}
	
	sort.Ints(nums)
	ump := make(map[int]int)
	
	for i := 0; i < n; i++ {
		nextVal := next(nums[i])
		if val, exists := ump[nums[i]]; exists {
			ump[nextVal] = val + 1
		} else {
			ump[nextVal] = 1
		}
	}
	
	ans := 1
	for _, count := range ump {
		if count > ans {
			ans = count
		}
	}
	
	fmt.Fprintln(writer, ans)
}
```