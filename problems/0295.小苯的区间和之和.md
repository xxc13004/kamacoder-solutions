# 贪心 + 排序
[题目链接](https://kamacoder.com/problempage.php?pid=1375)
## 思路分析
计算数组的每一个下标的贡献：即每一个下标位置的元素会被计算几次。我们希望计算次数最多的位置的元素是最小的。也就是说，贡献大的位置的元素要尽可能的小，贡献小的位置的元素尽可能的大。

贡献的计算方法如下：假设当前的下标为i，左边元素的个数l=i，右边元素的个数r=n-i-1，那么此位置的贡献为```s = l + r + l * r + 1 = i + n - i - 1 + i * (n - i - 1) + 1 = n + i * (n - i - 1)```。然后对贡献数组进行排序即可，按照贡献大小排序（正序），对原数组按照从大到小的（逆序），然后相乘再相加就是最终的答案。

注释：因为是要计算所有的区间，所以区间的总数量是固定的，每个位置的元素所对应的区间的数量也是唯一的。在上述贡献计算方法中，每个位置的区间数量就是贡献。计算贡献也就是计算每个位置的区间数量。
## 复杂度分析
1. 时间复杂度：O(nlog(n))；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n;
    cin >> n;
    vector<int> nums(n);
    vector<LL> cnts(n);
    for (int i = 0; i < n; ++i) cin >> nums[i];
    for (int i = 0; i < n; ++i) {
        cnts[i] = n + 1LL * i * (n - i - 1);
    }
    sort(nums.begin(), nums.end(), greater<>());
    sort(cnts.begin(), cnts.end());
    LL ans = 0;
    for (int i = 0; i < n; ++i) {
        ans += nums[i] * cnts[i];
    }
    cout << ans << endl;
    return 0;
}
```
### Python
``` python
import sys

def main():
    data = sys.stdin.read().split()
    if not data:
        return
    
    n = int(data[0])
    nums = list(map(int, data[1:1+n]))
    
    cnts = [0] * n
    for i in range(n):
        cnts[i] = n + i * (n - i - 1)
    
    nums.sort(reverse=True)
    cnts.sort()
    
    ans = 0
    for i in range(n):
        ans += nums[i] * cnts[i]
    
    print(ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int[] nums = new int[n];
        long[] cnts = new long[n];
        
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            nums[i] = Integer.parseInt(st.nextToken());
        }
        
        for (int i = 0; i < n; i++) {
            cnts[i] = n + (long) i * (n - i - 1);
        }
        
        // 降序排序nums
        nums = Arrays.stream(nums)
                   .boxed()
                   .sorted(Collections.reverseOrder())
                   .mapToInt(Integer::intValue)
                   .toArray();
        
        Arrays.sort(cnts);
        
        long ans = 0;
        for (int i = 0; i < n; i++) {
            ans += (long) nums[i] * cnts[i];
        }
        
        System.out.println(ans);
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
)

func main() {
	reader := bufio.NewReader(os.Stdin)
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()

	var n int
	fmt.Fscan(reader, &n)
	
	nums := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Fscan(reader, &nums[i])
	}
	
	cnts := make([]int64, n)
	for i := 0; i < n; i++ {
		cnts[i] = int64(n) + int64(i)*int64(n-i-1)
	}
	
	// 降序排序nums
	sort.Slice(nums, func(i, j int) bool {
		return nums[i] > nums[j]
	})
	
	sort.Slice(cnts, func(i, j int) bool {
		return cnts[i] < cnts[j]
	})
	
	var ans int64
	for i := 0; i < n; i++ {
		ans += int64(nums[i]) * cnts[i]
	}
	
	fmt.Fprintln(writer, ans)
}
```