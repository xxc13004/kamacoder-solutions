# 排序 + 贪心
[题目链接](https://kamacoder.com/problempage.php?pid=1401)
## 思路分析
题目意思是，我们在保证数组中所有的天数都必须要待在大本营的情况下的，另外的天数尽量减少往返跑，在这种情况下，需要往返的最少的次数。

由于数组中每个指定的日期一定要待在珠峰，那么很容易想到，剩下的天数，如果要减少往返跑的话，那就只能挑选时间间隔最少的两天，在这两天之间待在大本营，这样可以减少两次移动。因此对每个天数的间隔进行从小到大排序，然后按照顺序依次选择在这几天之间留在珠峰大本营，直到我们没办法待在大本营为止。

## 复杂度分析
1. 时间复杂度：O(nlogn)；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int n, k;
    cin >> n >> k;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    k -= n;
    vector<int> d;
    for (int i = 1; i < n; i++) {
        d.push_back(arr[i] - arr[i - 1] - 1);
    }
    
    sort(d.rbegin(), d.rend());
    int ans = 2 * d.size();
    
    while (!d.empty() && k - d.back() >= 0) {
        ans -= 2;
        k -= d.back();
        d.pop_back();
    }
    
    cout << ans + 2 << endl;
    return 0;
}
```
### Python
``` python
n, k = map(int, input().split())
arr = list(map(int, input().split()))
k -= n
d = []
for i in range(1, n):
    d.append(arr[i] - arr[i - 1] - 1)
d.sort(reverse=True)
ans = 2 * len(d)
while d and k - d[-1] >= 0:
    ans -= 2
    k -= d[-1]
    d.pop()
print(ans + 2)
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        
        int[] arr = new int[n];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }
        
        k -= n;
        List<Integer> d = new ArrayList<>();
        for (int i = 1; i < n; i++) {
            d.add(arr[i] - arr[i - 1] - 1);
        }
        
        Collections.sort(d, Collections.reverseOrder());
        int ans = 2 * d.size();
        
        while (!d.isEmpty() && k - d.get(d.size() - 1) >= 0) {
            ans -= 2;
            k -= d.get(d.size() - 1);
            d.remove(d.size() - 1);
        }
        
        System.out.println(ans + 2);
    }
}
```
### Go
``` go
package main

import (
    "bufio"
    "fmt"
    "os"
    "sort"
    "strconv"
    "strings"
)

func main() {
    reader := bufio.NewReader(os.Stdin)
    
    // 读取第一行
    line, _ := reader.ReadString('\n')
    line = strings.TrimSpace(line)
    parts := strings.Split(line, " ")
    n, _ := strconv.Atoi(parts[0])
    k, _ := strconv.Atoi(parts[1])
    
    // 读取第二行
    line, _ = reader.ReadString('\n')
    line = strings.TrimSpace(line)
    numStrs := strings.Split(line, " ")
    
    arr := make([]int, n)
    for i := 0; i < n; i++ {
        arr[i], _ = strconv.Atoi(numStrs[i])
    }
    
    k -= n
    d := make([]int, 0)
    for i := 1; i < n; i++ {
        d = append(d, arr[i]-arr[i-1]-1)
    }
    
    sort.Sort(sort.Reverse(sort.IntSlice(d)))
    ans := 2 * len(d)
    
    for len(d) > 0 && k-d[len(d)-1] >= 0 {
        ans -= 2
        k -= d[len(d)-1]
        d = d[:len(d)-1]
    }
    
    fmt.Println(ans + 2)
}
```