# 思维
[题目链接](https://kamacoder.com/problempage.php?pid=1356)
## 思路分析
我们可以发现一个规律：已经是交替字符串了，不管是否翻转都不会改变他的交替长度。

如：10101 -> 10101, 奇数长度的串是回文的，翻不翻转不影响；1010 -> 0101，偶数长度的串翻转过后虽然顺序变了，可是不影响交替的长度。

如果我们对一个字符串的翻转操作进行等价替换：从翻转处切开，把这个字符串的头接到它的尾部，虽然字符串的顺序变了，但是交替的长度与题目所述的翻转操作相比并没有改变。其实将这个字符串进行一次完整的翻转就是我们之前的操作的结果。

由上面我们可以想到，如果我们将这个字符串拼接到他自己的后面会怎么样呢？这样就构造出了一个尾部接着头部的字符串，也就是经过等价翻转的字符串。并且交替的长度是不变的。实际上我们就会发现，不管怎么操作，所有的串都可以在这个加强串（也就是将自身拼接到自身的末尾）里面找到。

所以答案就是在加强串里面找到一个最长的交替串，注意这个最终的答案不能超过原字符串的长度本身。例如：1010，加强串是10101010，我们求出来最长交替串是8，但是实际上原字符串的长度只有4，所以最后要判断一下。

## 复杂度分析
1. 时间复杂度：O(n)；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n;
    cin >> n;
    n <<= 1;
    string s;
    cin >> s;
    s += s;
    int cnt = 1, ans = 1;
    for (int i = 1; i < n; ++i) {
        if (s[i] == s[i - 1]) {
            cnt = 1;
        } else {
            ans = max(ans, ++cnt);
        }
    }
    // 总长度不能超过原始字符串的长度
    cout << min(ans, n / 2) << endl;
    return 0;
}
```
### Python
``` python
import sys

def main():
    n = int(sys.stdin.readline()) * 2
    s = sys.stdin.readline().strip()
    s += s
    
    cnt, ans = 1, 1
    for i in range(1, n):
        if s[i] == s[i-1]:
            cnt = 1
        else:
            cnt += 1
            ans = max(ans, cnt)
    
    print(min(ans, n//2))

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine()) * 2;
        String s = br.readLine();
        s += s;
        
        int cnt = 1, ans = 1;
        for (int i = 1; i < n; i++) {
            if (s.charAt(i) == s.charAt(i-1)) {
                cnt = 1;
            } else {
                ans = Math.max(ans, ++cnt);
            }
        }
        
        System.out.println(Math.min(ans, n/2));
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	const bufferSize = 1 << 20 // 1MB 缓冲区
	reader := bufio.NewReaderSize(os.Stdin, bufferSize)
	writer := bufio.NewWriterSize(os.Stdout, bufferSize)
	defer writer.Flush()

	// 快速读取数字
	readInt := func() int {
		var x int
		var neg bool
		for {
			b, err := reader.ReadByte()
			if err != nil || (b < '0' || b > '9') && b != '-' {
				if neg {
					x = -x
				}
				return x
			}
			if b == '-' {
				neg = true
				continue
			}
			x = x*10 + int(b-'0')
		}
	}

	// 读取字符串（不包括换行符）
	readString := func() string {
		var bytes []byte
		for {
			b, err := reader.ReadByte()
			if err != nil || b == '\n' {
				break
			}
			bytes = append(bytes, b)
		}
		return string(bytes)
	}

	n := readInt() * 2
	s := readString()
	s += s // 创建循环字符串

	cnt, ans := 1, 1
	for i := 1; i < n; i++ {
		if s[i] == s[i-1] {
			cnt = 1
		} else {
			cnt++
			if cnt > ans {
				ans = cnt
			}
		}
	}

	// 结果不能超过原始字符串长度
	if ans > n/2 {
		ans = n / 2
	}
	fmt.Fprintln(writer, ans)
}
```