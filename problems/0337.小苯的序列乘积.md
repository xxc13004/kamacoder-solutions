# 思维
[题目链接](https://kamacoder.com/problempage.php?pid=1417)
## 思路分析

根据题意可知，我们不能对查询进行暴力求解，需要有一个预处理方式，使得每一次查询能够直接获取答案，假设长度为len的答案保存在ans数组中，下面讲解ans数组的求法。

按照0将数组分为多个段，因为不管什么段只要包含0，那么乘积就会变成0，也不用累加。

对于每一段，需要分为两种处理方式：

1. 全1的段：因为不管多少个1相乘，都是1，所以全1的段对答案的贡献就是``` C = max(0, L−len+1) ```，其中，L是段长，len表示对长度len的贡献。直接将其加入到ans[len]中即可。
2. 不全为1的段，即至少有一个数不为1。分析一下这一段的性质，由于乘积指数增长的特性，10 * 10 * 10 = 1000，如果数组里面的数都为10的话，那么最多也就是连续9个10就到上限了，而10也不算特别大的元素。如果序列中存在更大的元素的话，这个段的长度可能更小。最坏的情况就是数组的元素都是2，那么最多也就是三十多个2相乘就到上限了。也就是说，**合法子数组的长度并不会特别大。**

    - 对于乘积来说，只有大于1的元素才会影响大小，而1不会影响。例如：``` [1, 1, 2, 1, 3, 1, 1] ```，乘积为2 * 3 = 6，两边的1不改变乘积值。
    - 对于第二种类型的段，设其下标区间为[start, start+L)，找出所有a[i] > 1的数字的位置，存储在pos中。
    - 这些大于1的数字会把该类段继续分割为全1的子段，对于这些子段，继续按照全1的段计算贡献。
    - 对于大于的1元素，枚举每种组合方式，按照下面的方式计算。

        - A = 上一个大于1元素位置+1（若无则为0）
        - B = 当前子序列第一个大于1元素位置
        - C = 当前子序列最后一个大于1元素位置
        - D = 下一个大于1元素位置-1（若无则为段尾）
    
    - 枚举pos，最多就30+元素。枚举每一种组合，这些组合和的乘积为M，其余的元素是1，不影响。例如``` [1, 1, 2, 1, 3, 1, 1] ```，pos=[2, 3], 可以枚举的组合有三种：

        - [2], 乘积M=2
        - [3], 乘积M=3
        - [2, 3], 乘积M=6
    
    - 假设我们枚举到[2, 3], 那么我们可以扩展这个子数组。

        - 最小长度 min_len = C - B + 1
        - 最大长度 max_len = D - A + 1
        - 对每个长度 len ∈ [min_len, max_len]，计算恰好包含该子序列且不包含其他大于1元素的子数组个数：
        - count = max(0, min(B, D−len+1) − max(A, C−len+1)+1)
        - 将 M × count累加到ans[len]。
    
    - 最后输出结果ans[qi]。


## 复杂度分析
1. 时间复杂度：O(nlogn)，常数比较大，但是总体来说是能够接受的，因为每一段包含的数字不会超过30多个；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include <bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    cin >> t;
    while (t--) {
        int n, q;
        cin >> n >> q;
        vector<int> a(n);
        for (int i = 0; i < n; ++i) cin >> a[i];
         
        vector<LL> ans(n + 1, 0);
         
        // 分割非零段
        int i = 0;
        while (i < n) {
            if (a[i] == 0) { i++; continue; }
            int start = i;
            while (i < n && a[i] != 0) i++;
            int L = i - start; // 段长
             
            // 判断是否全为1
            bool all_one = true;
            for (int j = start; j < start + L; ++j) {
                if (a[j] != 1) { all_one = false; break; }
            }
             
            if (all_one) {
                for (int len = 1; len <= L; ++len) {
                    ans[len] += L - len + 1;
                }
                continue;
            }
             
            // 非全1段：收集大于1的元素位置
            vector<int> pos;
            for (int j = start; j < start + L; ++j) {
                if (a[j] > 1) pos.push_back(j - start);
            }
            int k = pos.size();
             
            // 处理全1子段
            vector<int> splits;
            splits.push_back(-1);
            splits.insert(splits.end(), pos.begin(), pos.end());
            splits.push_back(L);
            for (int idx = 0; idx + 1 < splits.size(); ++idx) {
                int left = splits[idx] + 1;
                int right = splits[idx + 1] - 1;
                if (left <= right) {
                    int L1 = right - left + 1;
                    for (int len = 1; len <= L1; ++len) {
                        ans[len] += L1 - len + 1;
                    }
                }
            }
             
            // 处理包含大于1元素的子数组
            for (int i1 = 0; i1 < k; ++i1) {
                LL M = 1;
                for (int j1 = i1; j1 < k; ++j1) {
                    M *= a[start + pos[j1]];
                    if (M > 1000000000LL) break;
                     
                    int A = (i1 == 0 ? 0 : pos[i1 - 1] + 1);
                    int B = pos[i1];
                    int C = pos[j1];
                    int D = (j1 == k - 1 ? L - 1 : pos[j1 + 1] - 1);
                     
                    int min_len = C - B + 1;
                    int max_len = D - A + 1;
                    for (int len = min_len; len <= max_len; ++len) {
                        int cnt = min(B, D - len + 1) - max(A, C - len + 1) + 1;
                        if (cnt > 0) {
                            ans[len] += M * cnt;
                        }
                    }
                }
            }
        }
         
        // 回答询问
        while (q--) {
            int len;
            cin >> len;
            cout << ans[len] << "\n";
        }
    }
    return 0;
}
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    static final long INF = 1000000001L;
    
    public static void main(String[] args) throws IOException {
        FastReader in = new FastReader();
        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        
        int T = in.nextInt();
        while (T-- > 0) {
            int n = in.nextInt();
            int q = in.nextInt();
            
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = in.nextInt();
            }
            
            long[] ans = new long[n + 1];
            
            // 分割非零段
            int idx = 0;
            while (idx < n) {
                if (a[idx] == 0) {
                    idx++;
                    continue;
                }
                
                int start = idx;
                while (idx < n && a[idx] != 0) {
                    idx++;
                }
                int L = idx - start;
                
                // 检查是否全为1
                boolean allOne = true;
                for (int j = start; j < start + L; j++) {
                    if (a[j] != 1) {
                        allOne = false;
                        break;
                    }
                }
                
                if (allOne) {
                    for (int len = 1; len <= L; len++) {
                        ans[len] += L - len + 1;
                    }
                    continue;
                }
                
                // 收集大于1的元素位置
                List<Integer> pos = new ArrayList<>();
                for (int j = start; j < start + L; j++) {
                    if (a[j] > 1) {
                        pos.add(j - start);
                    }
                }
                int k = pos.size();
                
                // 处理全1子段
                List<Integer> splits = new ArrayList<>();
                splits.add(-1);
                splits.addAll(pos);
                splits.add(L);
                
                for (int splitIdx = 0; splitIdx + 1 < splits.size(); splitIdx++) {
                    int left = splits.get(splitIdx) + 1;
                    int right = splits.get(splitIdx + 1) - 1;
                    if (left <= right) {
                        int L1 = right - left + 1;
                        for (int len = 1; len <= L1; len++) {
                            ans[len] += L1 - len + 1;
                        }
                    }
                }
                
                // 处理包含大于1元素的子数组
                for (int i1 = 0; i1 < k; i1++) {
                    long M = 1L;
                    for (int j1 = i1; j1 < k; j1++) {
                        M *= a[start + pos.get(j1)];
                        if (M > 1000000000L) {
                            break;
                        }
                        
                        // 计算扩展范围
                        int A = (i1 == 0) ? 0 : (pos.get(i1 - 1) + 1);
                        int B = pos.get(i1);
                        int C = pos.get(j1);
                        int D = (j1 == k - 1) ? (L - 1) : (pos.get(j1 + 1) - 1);
                        
                        int minLen = C - B + 1;
                        int maxLen = D - A + 1;
                        
                        for (int length = minLen; length <= maxLen; length++) {
                            int leftMin = Math.max(A, C - length + 1);
                            int leftMax = Math.min(B, D - length + 1);
                            
                            if (leftMax >= leftMin) {
                                int cnt = leftMax - leftMin + 1;
                                ans[length] += M * cnt;
                            }
                        }
                    }
                }
            }
            
            // 回答询问
            for (int i = 0; i < q; i++) {
                int len = in.nextInt();
                out.println(ans[len]);
            }
        }
        
        out.flush();
    }
    
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;
        
        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }
        
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        
        int nextInt() {
            return Integer.parseInt(next());
        }
        
        long nextLong() {
            return Long.parseLong(next());
        }
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	in := bufio.NewReader(os.Stdin)
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	var T int
	fmt.Fscan(in, &T)

	for t := 0; t < T; t++ {
		var n, q int
		fmt.Fscan(in, &n, &q)

		a := make([]int, n)
		for i := 0; i < n; i++ {
			fmt.Fscan(in, &a[i])
		}

		ans := make([]int64, n+1)

		// 分割非零段
		i := 0
		for i < n {
			if a[i] == 0 {
				i++
				continue
			}

			start := i
			for i < n && a[i] != 0 {
				i++
			}
			L := i - start

			// 检查是否全为1
			allOne := true
			for j := start; j < start+L; j++ {
				if a[j] != 1 {
					allOne = false
					break
				}
			}

			if allOne {
				for len := 1; len <= L; len++ {
					ans[len] += int64(L - len + 1)
				}
				continue
			}

			// 收集大于1的元素位置
			pos := []int{}
			for j := start; j < start+L; j++ {
				if a[j] > 1 {
					pos = append(pos, j-start)
				}
			}
			k := len(pos)

			// 处理全1子段
			splits := []int{-1}
			splits = append(splits, pos...)
			splits = append(splits, L)
			for idx := 0; idx+1 < len(splits); idx++ {
				left := splits[idx] + 1
				right := splits[idx+1] - 1
				if left <= right {
					L1 := right - left + 1
					for len := 1; len <= L1; len++ {
						ans[len] += int64(L1 - len + 1)
					}
				}
			}

			// 处理包含大于1元素的子数组
			for i1 := 0; i1 < k; i1++ {
				M := int64(1)
				for j1 := i1; j1 < k; j1++ {
					M *= int64(a[start+pos[j1]])
					if M > 1000000000 {
						break
					}

					// 计算扩展范围
					A := 0
					if i1 > 0 {
						A = pos[i1-1] + 1
					}
					B := pos[i1]
					C := pos[j1]
					D := L - 1
					if j1+1 < k {
						D = pos[j1+1] - 1
					}

					minLen := C - B + 1
					maxLen := D - A + 1

					for length := minLen; length <= maxLen; length++ {
						leftMin := A
						if C-length+1 > leftMin {
							leftMin = C - length + 1
						}
						leftMax := B
						if D-length+1 < leftMax {
							leftMax = D - length + 1
						}

						if leftMax >= leftMin {
							cnt := leftMax - leftMin + 1
							ans[length] += M * int64(cnt)
						}
					}
				}
			}
		}

		// 回答询问
		for q > 0 {
			var len int
			fmt.Fscan(in, &len)
			fmt.Fprintln(out, ans[len])
			q--
		}
	}
}
```