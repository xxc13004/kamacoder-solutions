# 排序
[题目链接](https://kamacoder.com/problempage.php?pid=1353)
## 思路分析
由于题目保证输入的数据一定是一棵树，那么我就可以得知一定不存在环。所以，每次删掉一条边都会产生一个联通块。

通过分析题目，可以发现，这道题实际上哪两个节点之间是联通的不重要，我们只需要知道最后树被分成了几个联通块即可。那么我们枚举最后存在几个联通块即可，可以对边权进行排序，我们一定是从最小的边权开始删除，然后求一个最大值及时正确答案。

## 复杂度分析
1. 时间复杂度：O(nlog(n))；
2. 空间复杂度：O(1)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n;
    cin >> t;
    while (t--) {
        cin >> n;
        vector<int> v(n);
        for (int i = 0; i < n; ++i) cin >> v[i];
        // 读取所有边权，边不重要
        vector<int> weights(n - 1);
        for (int i = 0, x, y; i < n - 1; ++i) {
            cin >> x >> y >> weights[i];
        }
        // 对边权进行排序
        sort(weights.begin(), weights.end());
        int sum = accumulate(weights.begin(), weights.end(), 0);
        int ans = sum + v[0];
        for (int i = 1; i < n; ++i) {
            sum -= weights[i - 1];
            ans = max(ans, sum + v[i]);
        }
        cout << ans << endl;
    }
    return 0;
}
```
### Python
``` python
import sys

MOD = 10**9 + 7
dir = [1, 0, -1, 0, 1]

def main():
    input = sys.stdin.read().split()
    ptr = 0
    t = int(input[ptr])
    ptr += 1
    for _ in range(t):
        n = int(input[ptr])
        ptr += 1
        v = list(map(int, input[ptr:ptr+n]))
        ptr += n
        
        weights = []
        for _ in range(n-1):
            x = int(input[ptr])
            y = int(input[ptr+1])
            w = int(input[ptr+2])
            weights.append(w)
            ptr += 3
        
        weights.sort()
        total = sum(weights)
        ans = total + v[0]
        for i in range(1, n):
            total -= weights[i-1]
            ans = max(ans, total + v[i])
        
        print(ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            int n = Integer.parseInt(br.readLine());
            int[] v = new int[n];
            String[] tokens = br.readLine().split(" ");
            for (int i = 0; i < n; i++) {
                v[i] = Integer.parseInt(tokens[i]);
            }
            
            int[] weights = new int[n-1];
            for (int i = 0; i < n-1; i++) {
                tokens = br.readLine().split(" ");
                // int x = Integer.parseInt(tokens[0]);
                // int y = Integer.parseInt(tokens[1]);
                weights[i] = Integer.parseInt(tokens[2]);
            }
            
            Arrays.sort(weights);
            int sum = 0;
            for (int w : weights) sum += w;
            
            int ans = sum + v[0];
            for (int i = 1; i < n; i++) {
                sum -= weights[i-1];
                ans = Math.max(ans, sum + v[i]);
            }
            
            bw.write(ans + "\n");
        }
        
        bw.flush();
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
	"strconv"
    "strings"
)

func main() {
	// 使用更快的输入方式
	reader := bufio.NewReader(os.Stdin)
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()

	// 读取测试用例数量 t
	line, _ := reader.ReadString('\n')
	t, _ := strconv.Atoi(strings.TrimSpace(line))

	for ; t > 0; t-- {
		// 读取 n
		line, _ = reader.ReadString('\n')
		n, _ := strconv.Atoi(strings.TrimSpace(line))

		// 读取 v 数组
		line, _ = reader.ReadString('\n')
		vStr := strings.Fields(line)
		v := make([]int, n)
		for i := 0; i < n; i++ {
			v[i], _ = strconv.Atoi(vStr[i])
		}

		// 读取边权
		weights := make([]int, n-1)
		for i := 0; i < n-1; i++ {
			line, _ = reader.ReadString('\n')
			edge := strings.Fields(line)
			w, _ := strconv.Atoi(edge[2])
			weights[i] = w
		}

		// 排序边权
		sort.Ints(weights)

		// 计算总和
		sum := 0
		for _, w := range weights {
			sum += w
		}

		// 计算答案
		ans := sum + v[0]
		for i := 1; i < n; i++ {
			sum -= weights[i-1]
			if sum+v[i] > ans {
				ans = sum + v[i]
			}
		}

		// 输出结果
		fmt.Fprintln(writer, ans)
	}
}
```