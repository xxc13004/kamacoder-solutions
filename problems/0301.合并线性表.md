# 双指针
[题目链接](https://kamacoder.com/problempage.php?pid=1381)
## 思路分析
直接使用双指针进行归并排序即可。初始时刻，两个指针分别指向两个数组的起始位置，然后将指向较小数的指针后移，另一个不变，直到其中一个指针到数组的末尾，然后将另外一个数组剩下的数，全部添加到结果数组中。
## 复杂度分析
1. 时间复杂度：O(n + m)；
2. 空间复杂度：O(n + m)。
## 代码实现
### Cpp
``` cpp
#include <bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    int n, m;
    cin >> n;
    vector<int> arr1(n);
    for (int i = 0; i < n; i++) cin >> arr1[i];
    cin >> m;
    vector<int> arr2(m);
    for (int i = 0; i < m; i++) cin >> arr2[i];
    // 哨兵
    arr1.push_back(INT_MAX);
    arr2.push_back(INT_MAX);
    // 归并排序
    vector<int> res;
    int i = 0, j = 0;
    while (i < n || j < m) {
        if (arr1[i] < arr2[j]) res.push_back(arr1[i++]);
        else res.push_back(arr2[j++]);
    }
    for (int x : res) cout << x << " ";
    return 0;
}
```
### Python
``` python
arr1 = list(map(int, input().strip().split()))
arr2 = list(map(int, input().strip().split()))
n, m = arr1[0], arr2[0]
# 哨兵
arr1.append(10**10)
arr2.append(10**10)
# 归并排序
res = []
i = j = 1
while i <= n or j <= m:
    if arr1[i] < arr2[j]:
        res.append(arr1[i])
        i += 1
    else:
        res.append(arr2[j])
        j += 1
print(' '.join(map(str, res)))
```
### Java
``` java
import java.io.*;
import java.util.*;
public class Main {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		String[] arr1Str = br.readLine().split(" ");
        int n = Integer.parseInt(arr1Str[0]);
		int[] arr1 = new int[n + 1];
		for (int i = 1; i <= n; i++) arr1[i-1] = Integer.parseInt(arr1Str[i]);
		arr1[n] = Integer.MAX_VALUE; // 哨兵
		String[] arr2Str = br.readLine().split(" ");
        int m = Integer.parseInt(arr2Str[0]);
		int[] arr2 = new int[m + 1];
		for (int i = 1; i <= m; i++) arr2[i-1] = Integer.parseInt(arr2Str[i]);
		arr2[m] = Integer.MAX_VALUE; // 哨兵
		// 归并排序
		List<Integer> res = new ArrayList<>();
		int i = 0, j = 0;
		while (i < n || j < m) {
			if (arr1[i] < arr2[j]) res.add(arr1[i++]);
			else res.add(arr2[j++]);
		}
		for (int x : res) bw.write(x + " ");
		bw.flush();
		bw.close();
		br.close();
	}
}
```
### Go
``` go
package main
import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	reader := bufio.NewReader(os.Stdin)
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()
	var n, m int
	fmt.Fscan(reader, &n)
	arr1 := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Fscan(reader, &arr1[i])
	}
	fmt.Fscan(reader, &m)
	arr2 := make([]int, m)
	for i := 0; i < m; i++ {
		fmt.Fscan(reader, &arr2[i])
	}
	// 哨兵
	arr1 = append(arr1, int(1e9+7))
	arr2 = append(arr2, int(1e9+7))
	// 归并排序
	res := make([]int, 0, n+m)
	i, j := 0, 0
	for i < n || j < m {
		if arr1[i] < arr2[j] {
			res = append(res, arr1[i])
			i++
		} else {
			res = append(res, arr2[j])
			j++
		}
	}
	for _, x := range res {
		fmt.Fprint(writer, x, " ")
	}
}
```