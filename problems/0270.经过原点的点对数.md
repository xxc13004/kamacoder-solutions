# 哈希表
[题目链接](https://kamacoder.com/problempage.php?pid=1350)
## 思路分析
两个点的连线经过原点的特征是x1y2 = x2y1，(x1, y1)、(x2 y2)分别是两个点的坐标。所以题目可以转化为：已知一个点，求是否存在其他的点使得这两个点的坐标满足上述表达式，由于直接求不好求，所以可以将上述表达式转换一下，变成x1/y1 = x2/y2，从题目的描述可以知道，不管x1, y1, x2, y2均不可能出现0。所以其实就是求所有点的横纵坐标所构成的最简分数是否相等，如果相等就说明这两个点的连线一定经过坐标原点。

因为直接除可能导致因浮点数运算的而出现精度问题，所以我们要用最简分数进行存储，如何求最简分数呢？其实就是对这个分数进行约分，将分子分母同时除以他们的最大公约数就是最简分数，所以这里需要用到求最大公约数的算法。可以直接调用gcd函数进行求解，不熟悉这个函数也可以用辗转相除法求得。然后将分子分母组成一个元组（其他语言可以用类似的数据结构进行替代），保存到哈希表，并记录这个分数出现的次数，每次遍历一个点的时候，加上这个点的最简分数在这之前出现过的次数即可。

## 复杂度分析
1. 时间复杂度：O(nlog(C))；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n, ans = 0;
    map<PII, int> mp;
    cin >> n;
    for (int i = 1, x; i <= n; ++i) {
        cin >> x;
        // 求出两个数的最大公约数，对分数进行约分
        int t = __gcd(i, x);
        PII key = {i / t, x / t};
        ans += mp[key];
        // 记录这个分数的数量
        mp[key]++;
    }
    cout << ans << endl;
    return 0;
}
```
### Python
``` python
import sys
import math
from collections import defaultdict

def main():
    input = sys.stdin.read
    data = input().split()
    n = int(data[0])
    x_values = list(map(int, data[1:n+1]))
    
    mp = defaultdict(int)
    ans = 0
    
    for i in range(1, n + 1):
        x = x_values[i - 1]
        # 求出两个数的最大公约数，对分数进行约分
        t = math.gcd(i, x)
        key = (i // t, x // t)
        ans += mp[key]
        # 记录这个分数的数量
        mp[key] += 1
    
    print(ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int[] x = new int[n];
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            x[i] = Integer.parseInt(st.nextToken());
        }

        Map<Pair, Integer> mp = new HashMap<>();
        int ans = 0;

        for (int i = 1; i <= n; i++) {
            int xi = x[i - 1];
            // 求出两个数的最大公约数，对分数进行约分
            int t = gcd(i, xi);
            Pair key = new Pair(i / t, xi / t);
            ans += mp.getOrDefault(key, 0);
            // 记录这个分数的数量
            mp.put(key, mp.getOrDefault(key, 0) + 1);
        }

        System.out.println(ans);
    }

    static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    static class Pair {
        int first, second;

        Pair(int first, int second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Pair pair = (Pair) o;
            return first == pair.first && second == pair.second;
        }

        @Override
        public int hashCode() {
            return Objects.hash(first, second);
        }
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

func main() {
	// 使用更快的输入方式
	reader := bufio.NewReaderSize(os.Stdin, 1<<20) // 设置缓冲区为 1MB

	// 读取 n
	line, _ := reader.ReadString('\n')
	n, _ := strconv.Atoi(strings.TrimSpace(line))

	// 预分配 x 数组
	x := make([]int, n)
	
	// 快速读取 x 数组
	line, _ = reader.ReadString('\n')
	fields := strings.Fields(line)
	for i := 0; i < n; i++ {
		x[i], _ = strconv.Atoi(fields[i])
	}

	type Fraction struct {
		num, den int
	}
	
	mp := make(map[Fraction]int, n) // 预分配 map 大小
	ans := 0

	for i := 1; i <= n; i++ {
		xi := x[i-1]
		// 快速计算 GCD 并约分
		t := gcd(i, xi)
		key := Fraction{i / t, xi / t}
		ans += mp[key]
		mp[key]++
	}

	fmt.Println(ans)
}

// 快速 GCD 计算（非递归版本）
func gcd(a, b int) int {
	for b != 0 {
		a, b = b, a%b
	}
	return a
}
```