# 数学
[题目链接](https://kamacoder.com/problempage.php?pid=1419)
## 思路分析

先用素数筛预处理出一定范围内的所有素数，并存储在一个列表中，以便快速枚举。

针对比较小的素数，直接使用预处理的素数列表判断；针对较大的素数，可以通过Miller-Rabin素性测试。

采用三层循环枚举四个素数，按顺序枚举可以保证字典序最小。

1. 最外层枚举p1，从最小的2开始
2. 中层枚举p2，同样从2开始
3. 内层处理剩余的部分k=n-p1-p2，n是我们待求的数。我们将k拆分为两个素数的和。
    - 如果k是奇数，由于奇数=奇数+偶数，而所有的偶数中，只有2是素数，所以这种情况，只能拆分为2，和k-2，此时，只需要知道k-2是不是素数即可。
    - 如果k是偶数，则继续枚举第三个素数p3，检查k-p3是不是素数。
    - 只要找到了上面两种情况合法的结果，就可以直接输出，并结束枚举，由于我们是从最小的2开始枚举，所以可以保证字典序最小。

关于Miller-Rabin算法，可以自行了解。该算法可以高效的检测一个数是否为素数。

## 复杂度分析
1. 时间复杂度：O(LIMITloglogLIMIT + m^3)， LIMIT=5*10^5, m为素数表的大小；
2. 空间复杂度：O(LIMIT)。
## 代码实现
### Cpp
``` cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <cstring>
using namespace std;

const int LIMIT = 500000;
vector<int> primes;
bool is_prime_small[LIMIT + 1];

// 筛法生成素数
void sieve() {
    memset(is_prime_small, true, sizeof(is_prime_small));
    is_prime_small[0] = is_prime_small[1] = false;
    for (int i = 2; i <= LIMIT; i++) {
        if (is_prime_small[i]) {
            primes.push_back(i);
            if ((long long)i * i <= LIMIT) {
                for (int j = i * i; j <= LIMIT; j += i) {
                    is_prime_small[j] = false;
                }
            }
        }
    }
}

// 快速幂取模
long long mod_pow(long long a, long long d, long long n) {
    long long result = 1;
    a %= n;
    while (d > 0) {
        if (d & 1) result = (result * a) % n;
        a = (a * a) % n;
        d >>= 1;
    }
    return result;
}

// Miller-Rabin 素性测试
bool miller_rabin(long long n) {
    if (n < 2) return false;
    if (n <= LIMIT) return is_prime_small[n];
    
    // 小素数试除
    int small_primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
    for (int p : small_primes) {
        if (n % p == 0) return n == p;
    }
    
    // 分解 n-1 = d * 2^s
    long long d = n - 1;
    int s = 0;
    while (d % 2 == 0) {
        d /= 2;
        s++;
    }
    
    // 测试基底
    int bases[] = {2, 3, 5, 7, 11, 13};
    for (int a : bases) {
        if (a >= n) continue;
        long long x = mod_pow(a, d, n);
        if (x == 1 || x == n - 1) continue;
        
        bool composite = true;
        for (int r = 0; r < s - 1; r++) {
            x = (x * x) % n;
            if (x == n - 1) {
                composite = false;
                break;
            }
        }
        if (composite) return false;
    }
    return true;
}

// 素性测试包装函数
bool is_prime(long long n) {
    if (n <= LIMIT) return is_prime_small[n];
    return miller_rabin(n);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // 预处理素数表
    sieve();
    
    int t;
    cin >> t;
    while (t--) {
        long long n;
        cin >> n;
        
        bool found = false;
        // 枚举第一个质数 p1
        for (int p1 : primes) {
            if (p1 > n) break;
            long long m = n - p1;
            if (m < 6) continue;  // 三个质数之和至少为6
            
            // 枚举第二个质数 p2
            for (int p2 : primes) {
                if (p2 > m) break;
                long long k = m - p2;
                if (k < 4) continue;  // 两个质数之和至少为4
                
                if (k % 2 == 1) {
                    // k为奇数，只能分解为 2 和 k-2
                    if (k - 2 >= 2 && is_prime(k - 2)) {
                        cout << p1 << " " << p2 << " 2 " << k - 2 << "\n";
                        found = true;
                        break;
                    }
                } else {
                    // k为偶数，枚举第三个质数 p3
                    for (int p3 : primes) {
                        if (p3 > k / 2) break;
                        if (is_prime(k - p3)) {
                            cout << p1 << " " << p2 << " " << p3 << " " << k - p3 << "\n";
                            found = true;
                            break;
                        }
                    }
                    if (found) break;
                }
            }
            if (found) break;
        }
        
        if (!found) {
            cout << "-1\n";
        }
    }
    
    return 0;
}
```
### Python
``` python
import sys

# ---------- 素数筛生成素数列表 ----------
LIMIT = 500000
def sieve(limit):
    is_prime = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False
    primes = []
    for i in range(2, limit + 1):
        if is_prime[i]:
            primes.append(i)
            if i * i <= limit:
                for j in range(i * i, limit + 1, i):
                    is_prime[j] = False
    return primes, is_prime

primes_list, is_prime_small = sieve(LIMIT)

# ---------- Miller-Rabin 素性测试 ----------
def is_prime(n):
    if n < 2:
        return False
    if n <= LIMIT:
        return is_prime_small[n]
    # 小素数试除
    small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
    for p in small_primes:
        if n % p == 0:
            return n == p
    # Miller-Rabin
    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1
    for a in [2, 3, 5, 7, 11, 13]:
        if a >= n:
            continue
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(s - 1):
            x = (x * x) % n
            if x == n - 1:
                break
        else:
            return False
    return True

# ---------- 主求解函数 ----------
def solve():
    data = sys.stdin.read().strip().split()
    if not data:
        return
    t = int(data[0])
    out_lines = []
    idx = 1
    for _ in range(t):
        n = int(data[idx])
        idx += 1
        found = False
        # 枚举第一个质数 p1
        for p1 in primes_list:
            if p1 > n:
                break
            m = n - p1
            if m < 6:  # 三个质数之和至少为 2+2+2=6
                continue
            # 枚举第二个质数 p2
            for p2 in primes_list:
                if p2 > m:
                    break
                k = m - p2
                if k < 4:  # 两个质数之和至少为 2+2=4
                    continue
                if k % 2 == 1:  # k 为奇数，只能分解为 2 和 k-2
                    if k - 2 >= 2 and is_prime(k - 2):
                        out_lines.append(f"{p1} {p2} {2} {k-2}")
                        found = True
                        break
                else:  # k 为偶数，枚举第三个质数 p3
                    for p3 in primes_list:
                        if p3 > k // 2:  # 对称性，只需枚举到 k/2
                            break
                        if is_prime(k - p3):
                            out_lines.append(f"{p1} {p2} {p3} {k-p3}")
                            found = True
                            break
                    if found:
                        break
            if found:
                break
        if not found:
            out_lines.append("-1")
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    solve()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    static final int LIMIT = 500000;
    static List<Integer> primes = new ArrayList<>();
    static boolean[] isPrimeSmall = new boolean[LIMIT + 1];
    
    // 筛法生成素数
    static void sieve() {
        Arrays.fill(isPrimeSmall, true);
        isPrimeSmall[0] = isPrimeSmall[1] = false;
        for (int i = 2; i <= LIMIT; i++) {
            if (isPrimeSmall[i]) {
                primes.add(i);
                if ((long) i * i <= LIMIT) {
                    for (int j = i * i; j <= LIMIT; j += i) {
                        isPrimeSmall[j] = false;
                    }
                }
            }
        }
    }
    
    // 快速幂取模
    static long modPow(long a, long d, long n) {
        long result = 1;
        a %= n;
        while (d > 0) {
            if ((d & 1) == 1) result = (result * a) % n;
            a = (a * a) % n;
            d >>= 1;
        }
        return result;
    }
    
    // Miller-Rabin 素性测试
    static boolean millerRabin(long n) {
        if (n < 2) return false;
        if (n <= LIMIT) return isPrimeSmall[(int) n];
        
        // 小素数试除
        int[] smallPrimes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
        for (int p : smallPrimes) {
            if (n % p == 0) return n == p;
        }
        
        // 分解 n-1 = d * 2^s
        long d = n - 1;
        int s = 0;
        while (d % 2 == 0) {
            d /= 2;
            s++;
        }
        
        // 测试基底
        int[] bases = {2, 3, 5, 7, 11, 13};
        for (int a : bases) {
            if (a >= n) continue;
            long x = modPow(a, d, n);
            if (x == 1 || x == n - 1) continue;
            
            boolean composite = true;
            for (int r = 0; r < s - 1; r++) {
                x = (x * x) % n;
                if (x == n - 1) {
                    composite = false;
                    break;
                }
            }
            if (composite) return false;
        }
        return true;
    }
    
    // 素性测试包装函数
    static boolean isPrime(long n) {
        if (n <= LIMIT) return isPrimeSmall[(int) n];
        return millerRabin(n);
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        
        // 预处理素数表
        sieve();
        
        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            long n = Long.parseLong(br.readLine());
            
            boolean found = false;
            // 枚举第一个质数 p1
            for (int p1 : primes) {
                if (p1 > n) break;
                long m = n - p1;
                if (m < 6) continue;  // 三个质数之和至少为6
                
                // 枚举第二个质数 p2
                for (int p2 : primes) {
                    if (p2 > m) break;
                    long k = m - p2;
                    if (k < 4) continue;  // 两个质数之和至少为4
                    
                    if (k % 2 == 1) {
                        // k为奇数，只能分解为 2 和 k-2
                        if (k - 2 >= 2 && isPrime(k - 2)) {
                            pw.println(p1 + " " + p2 + " 2 " + (k - 2));
                            found = true;
                            break;
                        }
                    } else {
                        // k为偶数，枚举第三个质数 p3
                        for (int p3 : primes) {
                            if (p3 > k / 2) break;
                            if (isPrime(k - p3)) {
                                pw.println(p1 + " " + p2 + " " + p3 + " " + (k - p3));
                                found = true;
                                break;
                            }
                        }
                        if (found) break;
                    }
                }
                if (found) break;
            }
            
            if (!found) {
                pw.println("-1");
            }
        }
        
        pw.flush();
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
)

const LIMIT = 500000

var (
	primes       []int
	isPrimeSmall []bool
)

// 筛法生成素数
func sieve() {
	isPrimeSmall = make([]bool, LIMIT+1)
	for i := range isPrimeSmall {
		isPrimeSmall[i] = true
	}
	isPrimeSmall[0], isPrimeSmall[1] = false, false
	
	for i := 2; i <= LIMIT; i++ {
		if isPrimeSmall[i] {
			primes = append(primes, i)
			if i*i <= LIMIT {
				for j := i * i; j <= LIMIT; j += i {
					isPrimeSmall[j] = false
				}
			}
		}
	}
}

// 快速幂取模
func modPow(a, d, n int64) int64 {
	var result int64 = 1
	a %= n
	for d > 0 {
		if d&1 == 1 {
			result = (result * a) % n
		}
		a = (a * a) % n
		d >>= 1
	}
	return result
}

// Miller-Rabin 素性测试
func millerRabin(n int64) bool {
	if n < 2 {
		return false
	}
	if n <= LIMIT {
		return isPrimeSmall[n]
	}
	
	// 小素数试除
	smallPrimes := []int64{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}
	for _, p := range smallPrimes {
		if n%p == 0 {
			return n == p
		}
	}
	
	// 分解 n-1 = d * 2^s
	d := n - 1
	s := 0
	for d%2 == 0 {
		d /= 2
		s++
	}
	
	// 测试基底
	bases := []int64{2, 3, 5, 7, 11, 13}
	for _, a := range bases {
		if a >= n {
			continue
		}
		x := modPow(a, d, n)
		if x == 1 || x == n-1 {
			continue
		}
		
		composite := true
		for r := 0; r < s-1; r++ {
			x = (x * x) % n
			if x == n-1 {
				composite = false
				break
			}
		}
		if composite {
			return false
		}
	}
	return true
}

// 素性测试包装函数
func isPrime(n int64) bool {
	if n <= LIMIT {
		return isPrimeSmall[n]
	}
	return millerRabin(n)
}

func main() {
	reader := bufio.NewReader(os.Stdin)
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()
	
	// 预处理素数表
	sieve()
	
	var t int
	fmt.Fscan(reader, &t)
	
	for i := 0; i < t; i++ {
		var n int64
		fmt.Fscan(reader, &n)
		
		found := false
		// 枚举第一个质数 p1
		for _, p1 := range primes {
			if int64(p1) > n {
				break
			}
			m := n - int64(p1)
			if m < 6 { // 三个质数之和至少为6
				continue
			}
			
			// 枚举第二个质数 p2
			for _, p2 := range primes {
				if int64(p2) > m {
					break
				}
				k := m - int64(p2)
				if k < 4 { // 两个质数之和至少为4
					continue
				}
				
				if k%2 == 1 {
					// k为奇数，只能分解为 2 和 k-2
					if k-2 >= 2 && isPrime(k-2) {
						fmt.Fprintf(writer, "%d %d 2 %d\n", p1, p2, k-2)
						found = true
						break
					}
				} else {
					// k为偶数，枚举第三个质数 p3
					for _, p3 := range primes {
						if int64(p3) > k/2 {
							break
						}
						if isPrime(k - int64(p3)) {
							fmt.Fprintf(writer, "%d %d %d %d\n", p1, p2, p3, k-int64(p3))
							found = true
							break
						}
					}
					if found {
						break
					}
				}
			}
			if found {
				break
			}
		}
		
		if !found {
			fmt.Fprintln(writer, "-1")
		}
	}
}
```