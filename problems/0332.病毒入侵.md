# 模拟
[题目链接](https://kamacoder.com/problempage.php?pid=1412)
## 思路分析
题目意思是将所有连续一段的相同字符归为一段，然后求每种字符共有几段。最后结果有几个字符的段数大于n。并且要注意最小值是1，所以输出答案时要max(1, ans)。
## 复杂度分析
1. 时间复杂度：O(n * m)；
2. 空间复杂度：O(1)。
## 代码实现
### Cpp
``` cpp
#include <bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n, m;
    cin >> n >> m;
    while (m--) {
        string s;
        cin >> s;
        int k = s.length();
        int cnt[128]{};
        for (int i = 0; i < k;) {
            int j = i + 1;
            while (j < k && s[j] == s[i]) ++j;
            cnt[s[i]]++;
            i = j;
        }
        int ans = 0;
        for (int i = 'A'; i <= 'Z'; ++i) {
            if (cnt[i] > n) ++ans;
        }
        cout << max(1, ans) << endl;
    }
    return 0;
}
```
### Python
``` python
import sys
from collections import defaultdict

def main() -> None:
    input = sys.stdin.readline
    n, m = map(int, input().split())
    
    out_lines = []
    for _ in range(m):
        s = input().strip()
        k = len(s)
        
        # 统计连续字符段落数
        cnt = defaultdict(int)
        i = 0
        while i < k:
            j = i + 1
            while j < k and s[j] == s[i]:
                j += 1
            cnt[s[i]] += 1
            i = j
        
        # 统计超过n的字符数
        ans = 0
        for ch in range(ord('A'), ord('Z') + 1):
            if cnt[chr(ch)] > n:
                ans += 1
        
        out_lines.append(str(max(1, ans)))
    
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        
        for (int t = 0; t < m; t++) {
            String s = br.readLine().trim();
            int k = s.length();
            
            int[] cnt = new int[128];  // ASCII码范围
            
            // 统计连续字符段落数
            for (int i = 0; i < k; ) {
                int j = i + 1;
                while (j < k && s.charAt(j) == s.charAt(i)) {
                    j++;
                }
                cnt[s.charAt(i)]++;
                i = j;
            }
            
            // 统计超过n的字符数
            int ans = 0;
            for (int i = 'A'; i <= 'Z'; i++) {
                if (cnt[i] > n) {
                    ans++;
                }
            }
            
            pw.println(Math.max(1, ans));
        }
        
        pw.flush();
        pw.close();
        br.close();
    }
}
```
### Go
``` go
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    reader := bufio.NewReader(os.Stdin)
    writer := bufio.NewWriter(os.Stdout)
    defer writer.Flush()
    
    var n, m int
    fmt.Fscan(reader, &n, &m)
    
    for i := 0; i < m; i++ {
        var s string
        fmt.Fscan(reader, &s)
        
        // 统计连续字符段落数
        cnt := make([]int, 128)
        k := len(s)
        
        for j := 0; j < k; {
            char := s[j]
            next := j + 1
            for next < k && s[next] == char {
                next++
            }
            cnt[char]++
            j = next
        }
        
        // 统计超过n的字符数
        ans := 0
        for ch := 'A'; ch <= 'Z'; ch++ {
            if cnt[ch] > n {
                ans++
            }
        }
        
        // 输出结果，至少为1
        if ans < 1 {
            ans = 1
        }
        fmt.Fprintln(writer, ans)
    }
}
```