# 数学
[题目链接](https://kamacoder.com/problempage.php?pid=1391)
## 思路分析
假设一开始不进行任何交换，那么答案就是old=Σ(bi-ai)*ci。 那么假如我们交换a数组的第i个元素和第j个元素。那么总和会变成什么呢？

``` total = old - (bi - ai) * ci - (bj - aj) * cj + (bi - aj) * ci + (bj - ai) * cj ```

得到这个增量``` diff = (ai - aj)(ci - cj) ```。

故只需要求diff的最大值即可。最终结果就是old + diff

那么由于直接枚举时间复杂度是n^2的，所以需要优化，由于c数组的值域区间为[1, 1000]，那么我们可以直接枚举c的值域ci，然后维护每个ci对应的ai的最大值和最小值是多少。

最后更新每一步的diff的值。

## 复杂度分析
1. 时间复杂度：O(m^2), m为c的值域；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n;
    cin >> n;
    vector<int> a(n), b(n), c(n);
    for (int i = 0; i < n; ++i) cin >> a[i];
    for (int i = 0; i < n; ++i) cin >> b[i];
    for (int i = 0; i < n; ++i) cin >> c[i];

    // 计算原始值
    LL old = 0;
    for (int i = 0; i < n; ++i) old += (b[i] - a[i]) * c[i];

    // 按照c进行分组,记录每一组的a的最大值和最小值
    vector<int> mxv(1001, -1001), mnv(1001, 1001);
    for (int i = 0; i < n; ++i) {
        int t = c[i];
        mxv[t] = max(mxv[t], a[i]);
        mnv[t] = min(mnv[t], a[i]);
    }

    // 枚举所有的组合
    LL delta = -MOD;
    for (int i = 1; i <= 1000; ++i) {
        for (int j = i; j <= 1000; ++j) {
            int d = j - i;   // j-i 一定> =0
            LL cur = (mxv[j] - mnv[i]) * d;
            delta = max(delta, cur);
        }
    }
    cout << old + delta << endl;
    return 0;
}
```
### Python
``` python
import sys

def main():
    input = sys.stdin.read().split()
    idx = 0
    n = int(input[idx]); idx += 1
    
    a = []
    b = []
    c = []
    
    for i in range(n):
        a.append(int(input[idx])); idx += 1
    for i in range(n):
        b.append(int(input[idx])); idx += 1
    for i in range(n):
        c.append(int(input[idx])); idx += 1
    
    # 计算原始值
    old = 0
    for i in range(n):
        old += (b[i] - a[i]) * c[i]
    
    # 按照c进行分组，记录每一组的a的最大值和最小值
    mxv = [-1001] * 1001
    mnv = [1001] * 1001
    
    for i in range(n):
        t = c[i]
        mxv[t] = max(mxv[t], a[i])
        mnv[t] = min(mnv[t], a[i])
    
    # 枚举所有的组合
    delta = -10**18
    for i in range(1, 1001):
        for j in range(i, 1001):
            d = j - i
            if mxv[j] != -1001 and mnv[i] != 1001:
                cur = (mxv[j] - mnv[i]) * d
                delta = max(delta, cur)
    
    print(old + delta)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        int n = Integer.parseInt(br.readLine());
        int[] a = new int[n];
        int[] b = new int[n];
        int[] c = new int[n];
        
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            a[i] = Integer.parseInt(st.nextToken());
        }
        
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            b[i] = Integer.parseInt(st.nextToken());
        }
        
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            c[i] = Integer.parseInt(st.nextToken());
        }
        
        // 计算原始值
        long old = 0;
        for (int i = 0; i < n; i++) {
            old += (long) (b[i] - a[i]) * c[i];
        }
        
        // 按照c进行分组
        int[] mxv = new int[1001];
        int[] mnv = new int[1001];
        Arrays.fill(mxv, -1001);
        Arrays.fill(mnv, 1001);
        
        for (int i = 0; i < n; i++) {
            int t = c[i];
            mxv[t] = Math.max(mxv[t], a[i]);
            mnv[t] = Math.min(mnv[t], a[i]);
        }
        
        // 枚举所有的组合
        long delta = Long.MIN_VALUE;
        for (int i = 1; i <= 1000; i++) {
            for (int j = i; j <= 1000; j++) {
                int d = j - i;
                if (mxv[j] != -1001 && mnv[i] != 1001) {
                    long cur = (long) (mxv[j] - mnv[i]) * d;
                    delta = Math.max(delta, cur);
                }
            }
        }
        
        System.out.println(old + delta);
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	const bufferSize = 1 << 20
	reader := bufio.NewReaderSize(os.Stdin, bufferSize)
	writer := bufio.NewWriterSize(os.Stdout, bufferSize)
	defer writer.Flush()

	var n int
	fmt.Fscan(reader, &n)

	a := make([]int, n)
	b := make([]int, n)
	c := make([]int, n)

	for i := 0; i < n; i++ {
		fmt.Fscan(reader, &a[i])
	}
	for i := 0; i < n; i++ {
		fmt.Fscan(reader, &b[i])
	}
	for i := 0; i < n; i++ {
		fmt.Fscan(reader, &c[i])
	}

	// 计算原始值
	var old int64
	for i := 0; i < n; i++ {
		old += int64(b[i]-a[i]) * int64(c[i])
	}

	// 按照c进行分组
	mxv := make([]int, 1001)
	mnv := make([]int, 1001)
	for i := range mxv {
		mxv[i] = -1001
		mnv[i] = 1001
	}

	for i := 0; i < n; i++ {
		t := c[i]
		if a[i] > mxv[t] {
			mxv[t] = a[i]
		}
		if a[i] < mnv[t] {
			mnv[t] = a[i]
		}
	}

	// 枚举所有的组合
	delta := int64(-1e18)
	for i := 1; i <= 1000; i++ {
		for j := i; j <= 1000; j++ {
			d := j - i
			if mxv[j] != -1001 && mnv[i] != 1001 {
				cur := int64(mxv[j]-mnv[i]) * int64(d)
				if cur > delta {
					delta = cur
				}
			}
		}
	}

	fmt.Fprintln(writer, old+delta)
}
```