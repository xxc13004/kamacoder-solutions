# 动态规划
[题目链接](https://kamacoder.com/problempage.php?pid=1379)
## 思路分析
**状态定义：** 定义dp[i]为拼接成长度为i的木材所需要的最少原料的数量。

**状态转移：** 由于每个原材料不限数量，所以需要外层循环遍历拼接的长度j，内层循环遍历所有的原材料woods[i]。如果当前的原材料的长度小于等于j, 那么就可以更新dp数组, 表示可以使用这个原料进行拼接, 此时应该从j - woods[i]进行转移.

**转移方程：** 
1. dp[j] = min(dp[j], dp[j - woods[i]), if j >= woods[i].

初始时刻, 需要将dp[0]初始化为0, 其余所有数初始化为无穷大inf(很大的数), 最后输出dp[m]. 如果dp[m] == inf, 那么说明无法拼接成, 此时应该输出-1, 否则就是dp[m].
## 复杂度分析
1. 时间复杂度：O(n * m)；
2. 空间复杂度：O(m)。
## 代码实现
### Cpp
``` cpp
#include <bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    int n, m;
    cin >> n >> m;
    vector<int> woods(n);
    for (int i = 0; i < n; i++) cin >> woods[i];
    vector<int> dp(m + 1, MOD);
    dp[0] = 0;
    for (int j = 1; j <= m; j++) {
        for (int i = 0; i < n; i++) {
            if (woods[i] <= j) {
                dp[j] = min(dp[j], dp[j - woods[i]] + 1);
            }
        }
    }
    cout << (dp[m] == MOD ? -1 : dp[m]) << endl;
    return 0;
}
```
### Python
``` python
import math

n, m = map(int, input().split())
woods = list(map(int, input().split()))
dp = [math.inf] * (m + 1)
dp[0] = 0
for j in range(1, m + 1):
    for i in range(n):
        if woods[i] <= j:
            dp[j] = min(dp[j], dp[j - woods[i]] + 1)
print(-1 if dp[m] == math.inf else dp[m])
```
### Java
``` java
import java.io.*;
import java.util.*;
public class Main {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());
		int m = Integer.parseInt(st.nextToken());
		int[] woods = new int[n];
		st = new StringTokenizer(br.readLine());
		for (int i = 0; i < n; i++) {
			woods[i] = Integer.parseInt(st.nextToken());
		}
		int[] dp = new int[m + 1];
		Arrays.fill(dp, Integer.MAX_VALUE >> 1);
		dp[0] = 0;
		for (int j = 1; j <= m; j++) {
			for (int i = 0; i < n; i++) {
				if (woods[i] <= j) {
					dp[j] = Math.min(dp[j], dp[j - woods[i]] + 1);
				}
			}
		}
		System.out.println(dp[m] == Integer.MAX_VALUE / 2 ? -1 : dp[m]);
		br.close();
	}
}
```
### Go
``` go
package main
import (
	"fmt"
)

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func main() {
	var n, m int
	fmt.Scan(&n, &m)
	woods := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Scan(&woods[i])
	}
	dp := make([]int, m+1)
	for i := range dp {
		dp[i] = 1 << 30 // 使用一个较大的数表示无穷大
	}
	dp[0] = 0
	for j := 1; j <= m; j++ {
		for i := 0; i < n; i++ {
			if woods[i] <= j {
				dp[j] = min(dp[j], dp[j-woods[i]]+1)
			}
		}
	}
	if dp[m] == 1<<30 {
		fmt.Println(-1)
	} else {
		fmt.Println(dp[m])
	}
}
```