# 模拟 + 快速幂
[题目链接](https://kamacoder.com/problempage.php?pid=1399)
## 思路分析
分析题意可知，我们要保证删除数字之后逆序对的数量不减少，那么就说明这个数字对逆序对没有任何贡献，那么这个数字之前不能有大于他的数，之后不能有小于他的数。只有这样才不会影响总逆序对的数量。

由于是一个排列，也就是说每个数字只会出现一次，如果这个数字在他自己的位置上，且之前没有大于他的数，那么就说明之后一定不会有小于他的数。在自己的位置意思是这个数等于他的下标加一，如[2, 1, 3, 5, 4]，其中的3就是在自己的位置。如果3的前面有大于他的数，那么一定会有一个比3小的数因此跑到他后面去，所以如果他前面没有比他他的数，也不会有更小的数能到他后面去。

因此，我们维护当前数组的前缀最大值，统计不能贡献逆序对的数字的数量。最终的结果就是这些数的组合数之和，例如cnt=3，那么我们可以选择不删除，删除1个，删除2个，删除3个。答案就是``` C(3, 0) + C(3, 1) + C(3, 2) + C(3, 3) = 2 ^ 3 ```。所以需要用快速幂计算并在此过程中求余数。

最后注意不能全部删除，那么如果遇到cnt=n的情况，需要特判掉，然后将结果减一。
## 复杂度分析
1. 时间复杂度：O(tn)；
2. 空间复杂度：O(1)。
## 代码实现
### Cpp
``` cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

const int MOD = 998244353;

// 快速幂取模
long long pow_mod(long long base, long long exp, long long mod) {
    long long result = 1;
    base %= mod;
    while (exp > 0) {
        if (exp & 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp >>= 1;
    }
    return result;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t;
    cin >> t;
    
    while (t--) {
        int n;
        cin >> n;
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        
        int pmx = -1; // 前缀最值
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            if (arr[i] == i + 1 && arr[i] > pmx) {
                cnt++;
            }
            pmx = max(pmx, arr[i]);
        }
        
        if (cnt == n) {  // 排除掉全部删除的组合
            cout << (pow_mod(2, cnt, MOD) - 1 + MOD) % MOD << "\n";
        } else {    // 正常输出
            cout << pow_mod(2, cnt, MOD) << "\n";
        }
    }
    
    return 0;
}
```
### Python
``` python
MOD = 998244353
t = int(input())
for _ in range(t):
    n = int(input())
    arr = list(map(int, input().split()))
    pmx = -1 # 前缀最值
    cnt = 0
    for i in range(n):
        if arr[i] == i + 1 and arr[i] > pmx:
            cnt += 1
        pmx = max(pmx, arr[i])
    if cnt == n:  # 排除掉全部删除的组合
        print((pow(2 , cnt, MOD) - 1 + MOD) % MOD)
    else:    # 正常输出
        print(pow(2, cnt, MOD))
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    static final int MOD = 998244353;
    
    // 快速幂取模
    static long powMod(long base, long exp, long mod) {
        long result = 1;
        base %= mod;
        while (exp > 0) {
            if ((exp & 1) == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp >>= 1;
        }
        return result;
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        
        int t = Integer.parseInt(br.readLine());
        
        while (t-- > 0) {
            int n = Integer.parseInt(br.readLine());
            int[] arr = new int[n];
            StringTokenizer st = new StringTokenizer(br.readLine());
            for (int i = 0; i < n; i++) {
                arr[i] = Integer.parseInt(st.nextToken());
            }
            
            int pmx = -1; // 前缀最值
            int cnt = 0;
            for (int i = 0; i < n; i++) {
                if (arr[i] == i + 1 && arr[i] > pmx) {
                    cnt++;
                }
                pmx = Math.max(pmx, arr[i]);
            }
            
            if (cnt == n) {  // 排除掉全部删除的组合
                pw.println((powMod(2, cnt, MOD) - 1 + MOD) % MOD);
            } else {    // 正常输出
                pw.println(powMod(2, cnt, MOD));
            }
        }
        
        pw.flush();
        pw.close();
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
)

const MOD = 998244353

// 快速幂取模
func powMod(base, exp, mod int64) int64 {
	var result int64 = 1
	base %= mod
	for exp > 0 {
		if exp&1 == 1 {
			result = (result * base) % mod
		}
		base = (base * base) % mod
		exp >>= 1
	}
	return result
}

func main() {
	reader := bufio.NewReader(os.Stdin)
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()

	var t int
	fmt.Fscan(reader, &t)

	for ; t > 0; t-- {
		var n int
		fmt.Fscan(reader, &n)
		arr := make([]int, n)
		for i := 0; i < n; i++ {
			fmt.Fscan(reader, &arr[i])
		}

		pmx := -1 // 前缀最值
		cnt := 0
		for i := 0; i < n; i++ {
			if arr[i] == i+1 && arr[i] > pmx {
				cnt++
			}
			if arr[i] > pmx {
				pmx = arr[i]
			}
		}

		if cnt == n { // 排除掉全部删除的组合
			result := (powMod(2, int64(cnt), MOD) - 1 + MOD) % MOD
			fmt.Fprintln(writer, result)
		} else { // 正常输出
			result := powMod(2, int64(cnt), MOD)
			fmt.Fprintln(writer, result)
		}
	}
}
```