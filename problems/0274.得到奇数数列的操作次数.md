# 模拟 + 二进制
[题目链接](https://kamacoder.com/problempage.php?pid=1354)
## 思路分析
首先我们应该发现了这么两个规律：

1. 所有的偶数都可以通过除以2操作变成一个奇数；
2. 两个数相加等于奇数的情况一定是奇数 + 偶数。

有了上述两个规律后，我们发现，如果数组中至少存在一个奇数的话，那我我们的答案就是数组中偶数的数量，因为我们只需要对每一个偶数执行第二种操作即可。但是如果数组中没有奇数的话，我们就需要先将一个偶数变成奇数，然后对剩下的每个偶数分别执行第二种操作。执行第二种一定是最少得情况，因为每个偶数都只需要一次就能变成奇数。所以问题转化为，对哪一个偶数执行第一种操作使其变成奇数是操作次数最少的，这里就涉及到二进制的原理了，由于奇数的二进制最低位一定是1，而偶数不是，而除以2的操作其实就是位移操作，只需要将与一个偶数的最低位的1移到整个二进制的最低位即可，位移的次数就是这个偶数变成奇数的最少次数。另外我们记录数组中是否原本就存在奇数，最后输出的时候特判即可。


## 复杂度分析
1. 时间复杂度：O(nlog(C))；
2. 空间复杂度：O(1)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
LL ans = 0;
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n;
    cin >> t;
    // 计算这个数的最近的1在哪一位
    auto bit_length = [](LL x) -> int {
        int cnt = 0;
        while ((x & 1) == 0) {
            ++cnt;
            x >>= 1;
        }
        return cnt;
    };
    while (t--) {
        int ans = 0;
        cin >> n;
        vector<LL> nums(n);
        for (int i = 0; i < n; ++i) cin >> nums[i];
        int cnt = 100;
        bool flag = false;
        // 遍历找到是否存在奇数，以及计算偶数的数量
        for (int i = 0; i < n; ++i) {
            if (nums[i] % 2 == 0) {
                ++ans;
                cnt = min(cnt, bit_length(nums[i]));
            } else flag = true;
        }
        if (!flag) cout << ans + cnt - 1 << endl;
        else cout << ans << endl;
    }
    return 0;
}
```
### Python
``` python
import sys

#// 计算这个数的最近的1在哪一位
def bit_length(x):
    cnt = 0
    while (x & 1) == 0:
        cnt += 1
        x >>= 1
    return cnt

def main():
    input = sys.stdin.read().split()
    ptr = 0
    t = int(input[ptr])
    ptr += 1
    for _ in range(t):
        ans = 0
        n = int(input[ptr])
        ptr += 1
        nums = list(map(int, input[ptr:ptr+n]))
        ptr += n
        
        cnt = 100
        flag = False
        for num in nums:
            if num % 2 == 0:
                ans += 1
                cnt = min(cnt, bit_length(num))
            else:
                flag = True
        
        if not flag:
            print(ans + cnt - 1)
        else:
            print(ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.util.*;
import java.io.*;

public class Main {

    // 计算二进制位最近的1在哪
    static int bitLength(long x) {
        int cnt = 0;
        while ((x & 1) == 0) {
            ++cnt;
            x >>= 1;
        }
        return cnt;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            int ans = 0;
            int n = Integer.parseInt(br.readLine());
            long[] nums = new long[n];
            String[] tokens = br.readLine().split(" ");
            for (int i = 0; i < n; i++) {
                nums[i] = Long.parseLong(tokens[i]);
            }
            
            int cnt = 100;
            boolean flag = false;
            for (int i = 0; i < n; i++) {
                if (nums[i] % 2 == 0) {
                    ++ans;
                    cnt = Math.min(cnt, bitLength(nums[i]));
                } else {
                    flag = true;
                }
            }
            
            if (!flag) {
                bw.write((ans + cnt - 1) + "\n");
            } else {
                bw.write(ans + "\n");
            }
        }
        
        bw.flush();
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	const bufferSize = 1 << 20 // 1MB 缓冲区
	reader := bufio.NewReaderSize(os.Stdin, bufferSize)
	writer := bufio.NewWriterSize(os.Stdout, bufferSize)
	defer writer.Flush()

	// 快速读取数字
	readInt := func() int {
		var x int
		for {
			b, err := reader.ReadByte()
			if err != nil || b < '0' || b > '9' {
				if x == 0 { // 处理前导0的情况
					continue
				}
				return x
			}
			x = x*10 + int(b-'0')
		}
	}

	readLong := func() int64 {
		var x int64
		for {
			b, err := reader.ReadByte()
			if err != nil || b < '0' || b > '9' {
				if x == 0 { // 处理前导0的情况
					continue
				}
				return x
			}
			x = x*10 + int64(b-'0')
		}
	}

	bitLength := func(x int64) int {
		cnt := 0
		for (x & 1) == 0 {
			cnt++
			x >>= 1
		}
		return cnt
	}

	t := readInt()
	for ; t > 0; t-- {
		ans := 0
		n := readInt()
		nums := make([]int64, n)
		for i := 0; i < n; i++ {
			nums[i] = readLong()
		}

		minBits := 100
		hasOdd := false
		for _, num := range nums {
			if num%2 == 0 {
				ans++
				bits := bitLength(num)
				if bits < minBits {
					minBits = bits
				}
			} else {
				hasOdd = true
			}
		}

		if !hasOdd {
			fmt.Fprintln(writer, ans+minBits-1)
		} else {
			fmt.Fprintln(writer, ans)
		}
	}
}
```