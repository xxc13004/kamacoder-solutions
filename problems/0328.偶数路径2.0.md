# dfs
[题目链接](https://kamacoder.com/problempage.php?pid=1408)
## 思路分析
题目要我们求的是权值为偶数的路径数，而权值又是路径上所有节点的gcd（最大公约数），那么我们就可以知道，既然gcd是个偶数，这条路径上的所有节点也必须都是偶数，因为如果一个数是偶数的倍数，那么这个数肯定是偶数，而如果一个数的因子里面存在偶数（gcd为偶数表示有偶数因子），那么他肯定是偶数的倍数。所以**我们要找的就是所有偶数节点组成的路径**。

我们按照偶数和奇数对树中的节点进行分类，将所有偶数节点组成的子树归为一类，即所有相连的偶数节点组成的联通块。那么在当前的子树中，假设其有n个节点，这里面任意两个节点组成的路径都符合要求，因为都是偶数，所以都包含因子2，满足题意。那么这个路径的条数就是``` C(n, 2) + n = n * (n + 1) / 2 ```。对所有的联通块求这个值就是答案。由于题目说单个节点也算一个路径，所以结果需要加上n。
## 复杂度分析
1. 时间复杂度：O(n)；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n;
    cin >> n;
    vector<int> vals(n + 1);
    // 读取节点的权值
    for (int i = 1; i <= n; ++i) cin >> vals[i];
    // 读取边
    vector<vector<int>> paths(n + 1);
    for (int i = 1; i < n; ++i) {
        int x, y;
        cin >> x >> y;
        paths[x].push_back(y);
        paths[y].push_back(x);
    }
    // 记录节点是否已经访问过
    vector<int> vis(n + 1);
    // 找到当前联通块的节点数量
    function<int(int)> dfs = [&](int x) -> int {
        vis[x] = 1;
        int cnt = 1;
        for (int t : paths[x]) {
            if (!vis[t] && vals[t] % 2 == 0) {
                cnt += dfs(t);
            }
        }
        return cnt;
    };
    // 遍历所有节点，求路径数
    LL ans = 0;
    for (int i = 1; i <= n; ++i) {
        if (!vis[i] && vals[i] % 2 == 0) {
            LL ret = dfs(i);
            ans += ret * (ret + 1) / 2;
        }
    }
    cout << ans << endl;
    return 0;
}
```
### Python
``` python
import sys
sys.setrecursionlimit(300000)  # 增加递归深度以处理大树

def main():
    # 优化输入处理
    data = sys.stdin.read().split()
    if not data:
        return
    
    idx = 0
    n = int(data[idx]); idx += 1
    
    # 读取节点的权值，索引从1开始
    vals = [0] * (n + 1)
    for i in range(1, n + 1):
        vals[i] = int(data[idx]); idx += 1
    
    # 构建邻接表
    paths = [[] for _ in range(n + 1)]
    for _ in range(n - 1):
        x = int(data[idx]); idx += 1
        y = int(data[idx]); idx += 1
        paths[x].append(y)
        paths[y].append(x)
    
    # 记录节点是否已经访问过
    vis = [0] * (n + 1)
    
    def dfs(x):
        """DFS遍历连通块，返回节点数量"""
        vis[x] = 1
        cnt = 1
        for t in paths[x]:
            if not vis[t] and vals[t] % 2 == 0:
                cnt += dfs(t)
        return cnt
    
    # 遍历所有节点，求路径数
    ans = 0
    for i in range(1, n + 1):
        if not vis[i] and vals[i] % 2 == 0:
            ret = dfs(i)
            # 计算连通块内的路径数：C(ret, 2) + ret = ret*(ret+1)//2
            ans += ret * (ret + 1) // 2
    
    print(ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    static List<Integer>[] paths;
    static int[] vals;
    static boolean[] vis;
    
    public static void main(String[] args) throws IOException {
        // 优化输入输出
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        int n = Integer.parseInt(st.nextToken());
        
        // 读取节点的权值
        vals = new int[n + 1];
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= n; i++) {
            vals[i] = Integer.parseInt(st.nextToken());
        }
        
        // 构建邻接表
        paths = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++) {
            paths[i] = new ArrayList<>();
        }
        
        for (int i = 0; i < n - 1; i++) {
            st = new StringTokenizer(br.readLine());
            int x = Integer.parseInt(st.nextToken());
            int y = Integer.parseInt(st.nextToken());
            paths[x].add(y);
            paths[y].add(x);
        }
        
        // 记录节点是否已经访问过
        vis = new boolean[n + 1];
        
        // 遍历所有节点，求路径数
        long ans = 0;
        for (int i = 1; i <= n; i++) {
            if (!vis[i] && vals[i] % 2 == 0) {
                long ret = dfs(i);
                // 计算连通块内的路径数：ret*(ret+1)/2
                ans += ret * (ret + 1) / 2;
            }
        }
        
        pw.println(ans);
        pw.flush();
        pw.close();
    }
    
    static int dfs(int x) {
        vis[x] = true;
        int cnt = 1;
        for (int t : paths[x]) {
            if (!vis[t] && vals[t] % 2 == 0) {
                cnt += dfs(t);
            }
        }
        return cnt;
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
)

var (
	paths [][]int
	vals  []int
	vis   []bool
)

func main() {
	// 优化输入输出
	in := bufio.NewScanner(os.Stdin)
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()
	
	// 设置缓冲区大小
	const bufferSize = 1 << 20
	in.Buffer(make([]byte, bufferSize), bufferSize)
	
	// 读取n
	in.Scan()
	n, _ := strconv.Atoi(in.Text())
	
	// 读取节点的权值
	vals = make([]int, n+1)
	in.Scan()
	valsStr := splitToInts(in.Text())
	for i := 1; i <= n; i++ {
		vals[i] = valsStr[i-1]
	}
	
	// 构建邻接表
	paths = make([][]int, n+1)
	for i := range paths {
		paths[i] = make([]int, 0)
	}
	
	for i := 0; i < n-1; i++ {
		in.Scan()
		edge := splitToInts(in.Text())
		x, y := edge[0], edge[1]
		paths[x] = append(paths[x], y)
		paths[y] = append(paths[y], x)
	}
	
	// 记录节点是否已经访问过
	vis = make([]bool, n+1)
	
	// 遍历所有节点，求路径数
	var ans int64
	for i := 1; i <= n; i++ {
		if !vis[i] && vals[i]%2 == 0 {
			ret := dfs(i)
			// 计算连通块内的路径数：ret*(ret+1)/2
			ans += int64(ret) * int64(ret+1) / 2
		}
	}
	
	fmt.Fprintln(out, ans)
}

func dfs(x int) int {
	vis[x] = true
	cnt := 1
	for _, t := range paths[x] {
		if !vis[t] && vals[t]%2 == 0 {
			cnt += dfs(t)
		}
	}
	return cnt
}

// 辅助函数：将字符串分割为整数数组
func splitToInts(s string) []int {
	var result []int
	start := -1
	for i, ch := range s {
		if ch == ' ' {
			if start != -1 {
				num, _ := strconv.Atoi(s[start:i])
				result = append(result, num)
				start = -1
			}
		} else if start == -1 {
			start = i
		}
	}
	if start != -1 {
		num, _ := strconv.Atoi(s[start:])
		result = append(result, num)
	}
	return result
}
```