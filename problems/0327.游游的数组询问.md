# 数学 + 滑动窗口
[题目链接](https://kamacoder.com/problempage.php?pid=1407)
## 思路分析
先预处理[1, 10000]内所有的素数，然后就可以快速求出每个元素的质因数的个数，将其添加到数组中，形成一个长度为n的新数组factors，表示原数组中每个元素的质因数的个数。

然后在这个新数组上维护一个长度为k的滑动窗口，将窗口内的所有数全部加起来，求所有窗口的最小值。因为题目要求的是删除k个元素还剩下的最大值，所以我们逆向思维，求窗口的最小值。这样数组的总和减去这个最小值，就是最大值。删除最小值，剩下的自然是最大值。
## 复杂度分析
1. 时间复杂度：O(n * sqrt(m))，实际上还要加上素数筛的时间，m为数组的元素；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
bool PRIME[10001]{1, 1};
void init() {  // 预处理[1, 10000]所有的素数
    for (int i = 2; i <= 10000; ++i) {
        if (PRIME[i]) continue;
        for (int j = i * 2; j <= 10000; j += i) {
            PRIME[j] = true;
        }
    }
}
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n, k;
    cin >> n >> k;
    vector<int> nums(n);
    for (int i = 0; i < n; ++i) cin >> nums[i];
    auto get_prime_factor = [](int x) {  // 获取质因子的个数
        int ans = 0;
        for (int i = 1; i * i <= x; ++i) {
            if (x % i == 0) {
                ans += !PRIME[i];
                if (i * i != x) ans += !PRIME[x / i];
            }
        }
        return ans;
    };
    init(); // 预处理质数
    vector<int> factors(n);  // 存储质因子的个数
    for (int i = 0; i < n; ++i) factors[i] = get_prime_factor(nums[i]);
    int ans = MOD, cnt = 0;
    for (int i = 0, j = 0; j < n; ++j) {
        cnt += factors[j];
        if (j - i + 1 < k) continue;
        ans = min(ans, cnt);
        cnt -= factors[i++];
    }
    int total = accumulate(factors.begin(), factors.end(), 0);
    cout << total - ans << endl;
    return 0;
}
```
### Python
``` python
import sys
import math

# 常量定义
MOD = 1000000007

def main():
    # 优化输入处理
    data = sys.stdin.read().split()
    if not data:
        return
    
    n, k = int(data[0]), int(data[1])
    nums = list(map(int, data[2:2+n]))
    
    # 预处理素数表 [0, 10000]
    PRIME = [False] * 10001
    PRIME[0] = PRIME[1] = True  # 0和1不是素数
    
    def init():
        """预处理[1, 10000]所有的素数"""
        for i in range(2, 10001):
            if PRIME[i]:
                continue
            # 标记i的倍数为非素数
            for j in range(i * 2, 10001, i):
                PRIME[j] = True
    
    def get_prime_factor(x):
        """获取质因子的个数（包括1和本身）"""
        if x == 0:
            return 0
        ans = 0
        # 遍历所有因子
        for i in range(1, int(math.sqrt(x)) + 1):
            if x % i == 0:
                # 检查i是否是素数
                if not PRIME[i]:
                    ans += 1
                # 检查对应的因子x/i是否是素数
                if i * i != x and not PRIME[x // i]:
                    ans += 1
        return ans
    
    # 初始化素数表
    init()
    
    # 计算每个数字的质因子个数
    factors = [get_prime_factor(num) for num in nums]
    
    # 使用滑动窗口找到长度为k的最小质因子和
    ans = MOD
    current_sum = 0
    left = 0
    
    for right in range(n):
        current_sum += factors[right]
        
        # 当窗口达到k大小时
        if right - left + 1 >= k:
            ans = min(ans, current_sum)
            current_sum -= factors[left]
            left += 1
    
    # 总质因子个数减去最小窗口和
    total = sum(factors)
    print(total - ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

// 常量定义
public class Main {
    static final int MOD = 1000000007;
    static boolean[] PRIME = new boolean[10001];
    
    // 预处理素数表
    static void init() {
        PRIME[0] = PRIME[1] = true;  // 0和1不是素数
        for (int i = 2; i <= 10000; i++) {
            if (PRIME[i]) continue;
            for (int j = i * 2; j <= 10000; j += i) {
                PRIME[j] = true;
            }
        }
    }
    
    // 获取质因子的个数
    static int getPrimeFactor(int x) {
        if (x == 0) return 0;
        int ans = 0;
        for (int i = 1; i * i <= x; i++) {
            if (x % i == 0) {
                if (!PRIME[i]) ans++;
                if (i * i != x && !PRIME[x / i]) ans++;
            }
        }
        return ans;
    }
    
    public static void main(String[] args) throws IOException {
        // 优化输入输出
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        
        int[] nums = new int[n];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            nums[i] = Integer.parseInt(st.nextToken());
        }
        
        // 初始化素数表
        init();
        
        // 计算每个数字的质因子个数
        int[] factors = new int[n];
        for (int i = 0; i < n; i++) {
            factors[i] = getPrimeFactor(nums[i]);
        }
        
        // 滑动窗口找到长度为k的最小质因子和
        int ans = MOD;
        int currentSum = 0;
        int left = 0;
        
        for (int right = 0; right < n; right++) {
            currentSum += factors[right];
            
            if (right - left + 1 >= k) {
                ans = Math.min(ans, currentSum);
                currentSum -= factors[left];
                left++;
            }
        }
        
        // 计算总质因子个数
        int total = 0;
        for (int factor : factors) {
            total += factor;
        }
        
        pw.println(total - ans);
        pw.flush();
        pw.close();
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
)

// 常量定义
const MOD = 1000000007
const MAX_N = 10000

var PRIME [MAX_N + 1]bool

// 初始化素数表
func initPrime() {
	PRIME[0] = true
	PRIME[1] = true // 0和1不是素数
	
	for i := 2; i <= MAX_N; i++ {
		if PRIME[i] {
			continue
		}
		// 标记i的倍数为非素数
		for j := i * 2; j <= MAX_N; j += i {
			PRIME[j] = true
		}
	}
}

// 获取质因子的个数
func getPrimeFactor(x int) int {
	if x == 0 {
		return 0
	}
	ans := 0
	for i := 1; i*i <= x; i++ {
		if x%i == 0 {
			// 检查i是否是素数
			if !PRIME[i] {
				ans++
			}
			// 检查对应的因子x/i是否是素数
			if i*i != x && !PRIME[x/i] {
				ans++
			}
		}
	}
	return ans
}

func main() {
	// 优化输入输出
	in := bufio.NewScanner(os.Stdin)
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()
	
	// 设置缓冲区大小
	const bufferSize = 1 << 20
	in.Buffer(make([]byte, bufferSize), bufferSize)
	
	// 读取n和k
	in.Scan()
	nk := splitToInts(in.Text())
	n, k := nk[0], nk[1]
	
	// 读取数组
	in.Scan()
	nums := splitToInts(in.Text())
	
	// 初始化素数表
	initPrime()
	
	// 计算每个数字的质因子个数
	factors := make([]int, n)
	for i, num := range nums {
		factors[i] = getPrimeFactor(num)
	}
	
	// 滑动窗口找到长度为k的最小质因子和
	ans := MOD
	currentSum := 0
	left := 0
	
	for right := 0; right < n; right++ {
		currentSum += factors[right]
		
		// 当窗口达到k大小时
		if right-left+1 >= k {
			if currentSum < ans {
				ans = currentSum
			}
			currentSum -= factors[left]
			left++
		}
	}
	
	// 计算总质因子个数
	total := 0
	for _, factor := range factors {
		total += factor
	}
	
	fmt.Fprintln(out, total-ans)
}

// 辅助函数：将字符串分割为整数数组
func splitToInts(s string) []int {
	var result []int
	start := -1
	for i, ch := range s {
		if ch == ' ' {
			if start != -1 {
				num, _ := strconv.Atoi(s[start:i])
				result = append(result, num)
				start = -1
			}
		} else if start == -1 {
			start = i
		}
	}
	if start != -1 {
		num, _ := strconv.Atoi(s[start:])
		result = append(result, num)
	}
	return result
}
```