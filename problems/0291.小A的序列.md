# 动态规划
[题目链接](https://kamacoder.com/problempage.php?pid=1371)
## 思路分析
初步分析：我们知道一个数是x的倍数，那么说明这个数对x求余且余数就是0。特殊的，0也是x的倍数。不难发现，最终的答案一定不会超过x，因为我们每次对序列中的一个数加1，那么也就是对总和进行加1，假设一开始（没经过任何操作）的序列之和为s，且s % x == a，那么假设我们只能对序列进行加法操作，最终的答案最坏也就是x - a。因为加了x - a次之后，这个总和就一定是x的倍数了。那么在这个基础上加上删除操作，最坏的情况是多少呢？其实就是min(n, x - a)。因为我们只需要把所有数全部删掉就一定是x的倍数了（最终和为0）。因此，不管怎么样， **最终的答案一定是 <= n的，** 所以平均分摊到每个数字上，要进行加法的操作次数一定不会大于1。所以我们就可以考虑对于每个数，要不要执行 **一次** 加法操作就行了。

**状态定义：** 定义dp\[i\]\[j\]为前i个数字之和对x求余且余数为j的最少得操作次数。 

**状态转移：** 对于每个数，有三种选择，（保持不变），（进行一次加1），（删除）。

**转移方程：** 设当前的数为t。

1. dp\[i][j] = dp\[i - 1][(j - (t % x) + x) % x] if j - (t % x) + x >= 0，不变的情况；
2. dp\[i][j] = min(dp\[i][j], dp\[i - 1][(j - (t % x) - 1 + x) % x] + 1)，加一的情况，条件同上，注意下标；
3. dp\[i][j] = min(dp\[i][j], dp\[i - 1][j] + 1)，删除的情况；

可以直接使用记忆化搜索实现上述过程，也可以使用递推的方式，看个人的编码习惯，我这里使用记忆化搜索实现。最终的结果就是dp\[n][0]。
## 复杂度分析
1. 时间复杂度：O(nx)；
2. 空间复杂度：O(nx)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#include <vector>
using namespace std;
const int N = 10005, MOD = 1000000007;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
int t, ans = 0;
int main() {
    int n, x;
    cin >> n >> x;
    int *nums = new int[n];
    for (int i = 0; i < n; ++i) scanf("%d", nums + i);
    vector<vector<int>> dp(n, vector<int> (x, -1));
    auto dfs = [&](auto&& dfs, int i, int j) -> int {
        if (i == n) return j == 0 ? 0 : n;
        if (dp[i][j] >= 0) return dp[i][j];
        int t = j + nums[i];
        return dp[i][j] = min({dfs(dfs, i + 1, t % x), dfs(dfs, i + 1, j) + 1, dfs(dfs, i + 1, (t + 1) % x) + 1});
    }
    ans = min(n, dfs(dfs, 0, 0));
    cout << ans << endl;
    return 0;
}
```
### Python
``` python
import sys

def main():
    sys.setrecursionlimit(1 << 25)
    n, x = map(int, sys.stdin.readline().split())
    nums = list(map(int, sys.stdin.readline().split()))
    
    # Initialize DP table with -1
    dp = [[-1 for _ in range(x)] for _ in range(n)]
    
    def dfs(i, j):
        if i == n:
            return 0 if j == 0 else n
        if dp[i][j] != -1:
            return dp[i][j]
        t = j + nums[i]
        res = min(
            dfs(i + 1, t % x),
            dfs(i + 1, j) + 1,
            dfs(i + 1, (t + 1) % x) + 1
        )
        dp[i][j] = res
        return res
    
    ans = min(n, dfs(0, 0))
    print(ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    static int n, x;
    static int[] nums;
    static int[][] dp;
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        x = Integer.parseInt(st.nextToken());
        
        nums = new int[n];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            nums[i] = Integer.parseInt(st.nextToken());
        }
        
        dp = new int[n][x];
        for (int[] row : dp) {
            Arrays.fill(row, -1);
        }
        
        int ans = Math.min(n, dfs(0, 0));
        System.out.println(ans);
    }
    
    static int dfs(int i, int j) {
        if (i == n) return j == 0 ? 0 : n;
        if (dp[i][j] != -1) return dp[i][j];
        
        int t = j + nums[i];
        dp[i][j] = Math.min(
            Math.min(
                dfs(i + 1, t % x),
                dfs(i + 1, j) + 1
            ),
            dfs(i + 1, (t + 1) % x) + 1
        );
        return dp[i][j];
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

func main() {
	reader := bufio.NewReader(os.Stdin)
	
	line, _ := reader.ReadString('\n')
	parts := strings.Fields(line)
	n, _ := strconv.Atoi(parts[0])
	x, _ := strconv.Atoi(parts[1])
	
	nums := make([]int, n)
	line, _ = reader.ReadString('\n')
	parts = strings.Fields(line)
	for i := 0; i < n; i++ {
		nums[i], _ = strconv.Atoi(parts[i])
	}
	
	dp := make([][]int, n)
	for i := range dp {
		dp[i] = make([]int, x)
		for j := range dp[i] {
			dp[i][j] = -1
		}
	}
	
	var dfs func(int, int) int
	dfs = func(i, j int) int {
		if i == n {
			if j == 0 {
				return 0
			}
			return n
		}
		if dp[i][j] != -1 {
			return dp[i][j]
		}
		t := j + nums[i]
		dp[i][j] = min(
			min(
				dfs(i+1, t%x),
				dfs(i+1, j)+1,
			),
			dfs(i+1, (t+1)%x)+1,
		)
		return dp[i][j]
	}
	
	ans := min(n, dfs(0, 0))
	fmt.Println(ans)
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```