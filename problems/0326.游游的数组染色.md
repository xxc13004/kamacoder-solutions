# 排序 + 贪心
[题目链接](https://kamacoder.com/problempage.php?pid=1406)
## 思路分析
将数组倒序排序（从大到小），然后依次遍历每一个元素，求最大值``` ans = max(nums[i] + i + 1, ans) ```。
## 复杂度分析
1. 时间复杂度：O(nlogn)；
2. 空间复杂度：O(1)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n;
    cin >> t;
    while (t--) {
        cin >> n;
        vector<int> nums(n);
        for (int i = 0; i < n; ++i) cin >> nums[i];
        sort(nums.rbegin(), nums.rend());
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans = max(nums[i] + i + 1, ans);
        }
        cout << ans << endl;
    }
    return 0;
}
```
### Python
``` python
import sys

def main():
    # 优化输入处理，支持大量输入
    input = sys.stdin.read().split()
    idx = 0
    t = int(input[idx]); idx += 1
    
    for _ in range(t):
        n = int(input[idx]); idx += 1
        nums = []
        for i in range(n):
            nums.append(int(input[idx])); idx += 1
        
        # 降序排序
        nums.sort(reverse=True)
        ans = 0
        for i in range(n):
            ans = max(nums[i] + i + 1, ans)
        
        print(ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

class Main {
    public static void main(String[] args) throws IOException {
        // 使用BufferedReader和StringTokenizer（比Scanner快很多）
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st;
        
        int t = Integer.parseInt(br.readLine());
        
        while (t-- > 0) {
            int n = Integer.parseInt(br.readLine());
            int[] nums = new int[n];
            
            st = new StringTokenizer(br.readLine());
            for (int i = 0; i < n; i++) {
                nums[i] = Integer.parseInt(st.nextToken());
            }
            
            // 优化：使用原生数组和并行排序
            Arrays.sort(nums);
            
            int ans = 0;
            // 从后往前遍历（因为升序排序，最大值在最后）
            for (int i = n - 1, j = 1; i >= 0; i--, j++) {
                ans = Math.max(nums[i] + j, ans);
            }
            
            pw.println(ans);
        }
        
        pw.flush();
        pw.close();
    }
}
```
### Go
``` go
package main

import (
    "bufio"
    "fmt"
    "os"
    "sort"
)

func main() {
    // 优化输入输出处理，支持大量数据
    in := bufio.NewReader(os.Stdin)
    out := bufio.NewWriter(os.Stdout)
    defer out.Flush() // 确保程序结束时刷新所有缓冲数据
    
    // 读取测试用例数量
    var t int
    fmt.Fscan(in, &t)
    
    for ; t > 0; t-- {
        var n int
        fmt.Fscan(in, &n)
        
        nums := make([]int, n)
        for i := 0; i < n; i++ {
            fmt.Fscan(in, &nums[i])
        }
        
        // 降序排序
        sort.Sort(sort.Reverse(sort.IntSlice(nums)))
        ans := 0
        for i := 0; i < n; i++ {
            if nums[i]+i+1 > ans {
                ans = nums[i] + i + 1
            }
        }
        
        fmt.Fprintln(out, ans)
    }
}
```