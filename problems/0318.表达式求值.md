# 排序 + 二分
[题目链接](https://kamacoder.com/problempage.php?pid=1398)
## 思路分析
其实分析题目我们发现，这个是一个双重的求和运算符，也就是说自带两层循环的特性，这样是不行的。进一步分析发现，这个题目其实所有的数都要做数组中所有数的分母一次，然后再将他们累加起来，根据分数相加的特性，只要分母相同，可以先把所有的分子全部相加之后再除以分母，即可得出答案。于是就有一种思路是，先算出所有数的和，然后将这个和依次除以数组中所有的数一次，再相加。但是这样得出的结果是不正确的。因为题目要求的是每一次除都要向下取整，而我们全部累加起来再取整就会导致结果偏大。因为每一次向下取整的过程就是舍去余数的过程，而将所有结果相加再除一个数，舍去的余数不会超过这个数本身，故舍掉的数最终会偏小，实际结果会偏大。

正确的做法：

我们可以将数组排序，然后对于每一个数而言，都将其作为分母，求他能给所有数带来的贡献（就是公式中每一项表达式的结果）。但是如果枚举分子的话是两重循环，但是由于已经提前排序，所以我们可以二分枚举分子。**假设当前的数是k，那么我们枚举能作为分子的[k, 2k, 3k, 4k, ..., nk]，当分子在[k, 2k)之间，那么他能带来的贡献是1，分子在[2k, 3k)之间能带来的贡献是2，以此类推。** 只要知道每个区间包含的数的个数，将其乘以贡献值即可，直到找到数组的末尾。在枚举分子的过程中，要注意特判1，因为如果分母是1的话，我们枚举的范围就是[1, 2, 3, ..., n]，这样做实际上效率很差，我们知道如果1做分母，那么实际上他能给答案增加的值就是整个数组的和。另外，在遇到相同的数的时候，我们可以直接特判，因为分母是相同的数，那么第一次求了，第二次就不用求了。比如对于序列[1, 1, 3, 3, 3, 3, 8, 10]，我们求了第一个3的时候，下一次在遇到3的时候，只要要将上一次的结果加一次就好了，不用继续枚举了。

由于数组的值域在[1, 100000]之间，所以实际的时间复杂度是比较小的，可以接受，总体是在nlogn的级别的。
## 复杂度分析
1. 时间复杂度：O(nlogn)；
2. 空间复杂度：O(1)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n;
    cin >> n;
    vector<int> nums(n);
    for (int i = 0; i < n; ++i) cin >> nums[i];
    // 排序 + 二分
    sort(nums.begin(), nums.end());
    int mx = nums.back();  // 最大的元素
    LL sum = accumulate(nums.begin(), nums.end(), 0LL);
    LL ans = 0, cnt = 0;
    // 二分枚举k, 2k, 3k, ..., nk.
    for (int i = 0; i < n; ++i) {
        if (nums[i] == 1) {  // 1需要特判，否则可能会超时
            ans += sum;
            continue;
        }
        if (i && nums[i] == nums[i - 1]) {  // 剪枝，前一个数与当前的数一样，不用重复计算
            ans += cnt;
            continue;
        }
        int end = mx / nums[i]; // 二分的次数
        int val = nums[i] << 1;  // 每次的基准值
        int l = i, r = n; // 每段区间的左，右和这个数这一轮的和
        cnt = 0;  // 重置当前的数的和
        for (int j = 1; j <= end; ++j) {
            r = lower_bound(nums.begin() + i, nums.end(), val) - nums.begin();  // 下一次的位置
            cnt += j * (r - l);
            l = r;
            val += nums[i];
        }
        ans += cnt;
    }
    cout << ans << endl;
    return 0;
}
```
### Python
``` python
import sys
import bisect

def main():
    input = sys.stdin.read
    data = input().split()
    
    n = int(data[0])
    nums = list(map(int, data[1:1+n]))
    
    nums.sort()
    mx = nums[-1]
    total_sum = sum(nums)
    
    ans = 0
    cnt = 0
    
    for i in range(n):
        if nums[i] == 1:
            ans += total_sum
            continue
        
        if i > 0 and nums[i] == nums[i-1]:
            ans += cnt
            continue
        
        end = mx // nums[i]
        val = nums[i] * 2
        l = i
        r = n
        cnt = 0
        
        for j in range(1, end + 1):
            r = bisect.bisect_left(nums, val, l)
            cnt += j * (r - l)
            l = r
            val += nums[i]
        
        ans += cnt
    
    print(ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        int n = Integer.parseInt(br.readLine());
        int[] nums = new int[n];
        
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            nums[i] = Integer.parseInt(st.nextToken());
        }
        
        Arrays.sort(nums);
        int mx = nums[n - 1];
        long totalSum = 0;
        for (int num : nums) {
            totalSum += num;
        }
        
        long ans = 0;
        long cnt = 0;
        
        for (int i = 0; i < n; i++) {
            if (nums[i] == 1) {
                ans += totalSum;
                continue;
            }
            
            if (i > 0 && nums[i] == nums[i - 1]) {
                ans += cnt;
                continue;
            }
            
            int end = mx / nums[i];
            int val = nums[i] * 2;
            int l = i;
            int r = n;
            cnt = 0;
            
            for (int j = 1; j <= end; j++) {
                r = lowerBound(nums, val, l);
                cnt += (long) j * (r - l);
                l = r;
                val += nums[i];
            }
            
            ans += cnt;
        }
        
        System.out.println(ans);
    }
    
    private static int lowerBound(int[] nums, int target, int start) {
        int left = start;
        int right = nums.length;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        return left;
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
)

func main() {
	reader := bufio.NewReaderSize(os.Stdin, 1<<20)
	writer := bufio.NewWriterSize(os.Stdout, 1<<20)
	defer writer.Flush()

	var n int
	fmt.Fscan(reader, &n)

	nums := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Fscan(reader, &nums[i])
	}

	sort.Ints(nums)
	mx := nums[n-1]
	var totalSum int64
	for _, num := range nums {
		totalSum += int64(num)
	}

	var ans int64
	var cnt int64

	for i := 0; i < n; i++ {
		if nums[i] == 1 {
			ans += totalSum
			continue
		}

		if i > 0 && nums[i] == nums[i-1] {
			ans += cnt
			continue
		}

		end := mx / nums[i]
		val := nums[i] * 2
		l := i
		r := n
		cnt = 0

		for j := 1; j <= end; j++ {
			r = lowerBound(nums, val, l)
			cnt += int64(j) * int64(r-l)
			l = r
			val += nums[i]
		}

		ans += cnt
	}

	fmt.Fprintln(writer, ans)
}

func lowerBound(nums []int, target int, start int) int {
	left, right := start, len(nums)
	for left < right {
		mid := left + (right-left)/2
		if nums[mid] < target {
			left = mid + 1
		} else {
			right = mid
		}
	}
	return left
}
```