# 排序 + 双指针 + 哈希表
[题目链接](https://kamacoder.com/problempage.php?pid=1360)
## 思路分析
这道题其实就是一道典型的双指针题目，与之前的[最接近的三数之和](https://kamacoder.com/problempage.php?pid=1306)差不多，那道题也是虾皮的题目，只不过这个要返回数组的下标。而在排序过后数字的顺序就乱了，所以需要用哈希表记录每个数字在原数组的位置。

然后将两个指针一个指向第一个数组（已经排序）的起始位置，一个指向第二数组（已经排序）的最后一个位置，然后根据两个数的和分别控制左右指针的移动，直到某一个指针无法继续移动了结束。
## 复杂度分析
1. 时间复杂度：O(nlog(n))；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n, m, x;
    cin >> m >> n >> x;
    vector<int> a(m), b(n);
    // 保存当前的数字在原数组的位置
    unordered_map<int, int> umpa, umpb;
    for (int i = 0; i < m; ++i) cin >> a[i];
    for (int i = 0; i < m; ++i) umpa[a[i]] = i;
    for (int i = 0; i < n; ++i) cin >> b[i];
    for (int i = 0; i < n; ++i) umpb[b[i]] = i;
    // 对两个数组进行排序
    sort(a.begin(), a.end());
    sort(b.begin(), b.end());
    int l = 0, r = n - 1;
    int p = m, q = n, d = INT_MAX;
    auto cmp = [](PII a, PII b) {
        if (a.first == b.first) return a.second < b.second;
        return a.first < b.first;
    };
    while (l < m && r >= 0) {
        int t = a[l] + b[r] - x;
        if (abs(t) <= d) {
            // 找到当前数组在原数组中的位置
            int pl = umpa[a[l]], pr = umpb[b[r]];
            if (abs(t) == d) {
                // cmp函数返回true表示需要更新，即现在的结果更小
                if (cmp({pl, pr}, {p, q})) p = pl, q = pr, d = abs(t);
            } else p = pl, q = pr, d = abs(t);
        }
        if (t > 0) --r;
        else ++l;
    }
    cout << p << ' ' << q << endl;
    return 0;
}
```
### Python
``` python
import sys
import math

def main():
    m, n, x = map(int, sys.stdin.readline().split())
    a = list(map(int, sys.stdin.readline().split()))
    b = list(map(int, sys.stdin.readline().split()))
    
    # 保存当前的数字在原数组的位置
    umpa = {val: idx for idx, val in enumerate(a)}
    umpb = {val: idx for idx, val in enumerate(b)}
    
    # 对两个数组进行排序
    a_sorted = sorted(a)
    b_sorted = sorted(b)
    
    l, r = 0, n - 1
    p, q, d = m, n, math.inf
    
    while l < m and r >= 0:
        t = a_sorted[l] + b_sorted[r] - x
        if abs(t) <= d:
            # 找到当前数组在原数组中的位置
            pl = umpa[a_sorted[l]]
            pr = umpb[b_sorted[r]]
            if abs(t) == d:
                # 比较函数，返回True表示需要更新，即现在的结果更小
                if (pl, pr) < (p, q):
                    p, q = pl, pr
                    d = abs(t)
            else:
                p, q = pl, pr
                d = abs(t)
        if t > 0:
            r -= 1
        else:
            l += 1
    
    print(p, q)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] firstLine = br.readLine().split(" ");
        int m = Integer.parseInt(firstLine[0]);
        int n = Integer.parseInt(firstLine[1]);
        int x = Integer.parseInt(firstLine[2]);
        
        int[] a = new int[m];
        int[] b = new int[n];
        
        String[] aLine = br.readLine().split(" ");
        for (int i = 0; i < m; i++) {
            a[i] = Integer.parseInt(aLine[i]);
        }
        
        String[] bLine = br.readLine().split(" ");
        for (int i = 0; i < n; i++) {
            b[i] = Integer.parseInt(bLine[i]);
        }
        
        // 保存当前的数字在原数组的位置
        Map<Integer, Integer> umpa = new HashMap<>();
        Map<Integer, Integer> umpb = new HashMap<>();
        for (int i = 0; i < m; i++) umpa.put(a[i], i);
        for (int i = 0; i < n; i++) umpb.put(b[i], i);
        
        // 对两个数组进行排序
        int[] aSorted = a.clone();
        int[] bSorted = b.clone();
        Arrays.sort(aSorted);
        Arrays.sort(bSorted);
        
        int l = 0, r = n - 1;
        int p = m, q = n;
        int d = Integer.MAX_VALUE;
        
        while (l < m && r >= 0) {
            int t = aSorted[l] + bSorted[r] - x;
            if (Math.abs(t) <= d) {
                // 找到当前数组在原数组中的位置
                int pl = umpa.get(aSorted[l]);
                int pr = umpb.get(bSorted[r]);
                if (Math.abs(t) == d) {
                    // 比较函数，返回true表示需要更新，即现在的结果更小
                    if (pl < p || (pl == p && pr < q)) {
                        p = pl;
                        q = pr;
                        d = Math.abs(t);
                    }
                } else {
                    p = pl;
                    q = pr;
                    d = Math.abs(t);
                }
            }
            if (t > 0) {
                r--;
            } else {
                l++;
            }
        }
        
        System.out.println(p + " " + q);
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"math"
	"os"
	"sort"
)

func main() {
	reader := bufio.NewReader(os.Stdin)
	
	var m, n, x int
	fmt.Fscan(reader, &m, &n, &x)
	
	a := make([]int, m)
	for i := 0; i < m; i++ {
		fmt.Fscan(reader, &a[i])
	}
	
	b := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Fscan(reader, &b[i])
	}
	
	// 保存当前的数字在原数组的位置
	umpa := make(map[int]int)
	umpb := make(map[int]int)
	for idx, val := range a {
		umpa[val] = idx
	}
	for idx, val := range b {
		umpb[val] = idx
	}
	
	// 对两个数组进行排序
	aSorted := make([]int, m)
	copy(aSorted, a)
	sort.Ints(aSorted)
	
	bSorted := make([]int, n)
	copy(bSorted, b)
	sort.Ints(bSorted)
	
	l, r := 0, n-1
	p, q := m, n
	d := math.MaxInt32
	
	for l < m && r >= 0 {
		t := aSorted[l] + bSorted[r] - x
		absT := abs(t)
		if absT <= d {
			// 找到当前数组在原数组中的位置
			pl := umpa[aSorted[l]]
			pr := umpb[bSorted[r]]
			if absT == d {
				// 比较函数，返回true表示需要更新，即现在的结果更小
				if pl < p || (pl == p && pr < q) {
					p, q = pl, pr
					d = absT
				}
			} else {
				p, q = pl, pr
				d = absT
			}
		}
		if t > 0 {
			r--
		} else {
			l++
		}
	}
	
	fmt.Println(p, q)
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}
```