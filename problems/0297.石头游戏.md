# 模拟
[题目链接](https://kamacoder.com/problempage.php?pid=1377)
## 思路分析
根据题意直接模拟即可，只需要找到每个连续的数量大于1的字符，只保留其中的一个，其余的删除即可。
## 复杂度分析
1. 时间复杂度：O(n)；
2. 空间复杂度：O(1)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n, ans = 0;
    cin >> n;
    string s;
    cin >> s;
    for (int i = 1, j = 0; i < n; i++) {
        if (s[i] == s[j]) {
            ans++;
        } else {
            j = i;
        }
    }
    cout << ans << endl;
    return 0;
}
```
### Python
``` python
n = int(input().strip())
s = input().strip()
ans = j = 0
for i in range(1, n):
    if s[i] == s[j]:
        ans += 1
    else:
        j = i
print(ans)
```
### Java
``` java
import java.io.*;
import java.util.*;
public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine().trim());
		String s = br.readLine().trim();
		int ans = 0, j = 0;
		for (int i = 1; i < n; i++) {
			if (s.charAt(i) == s.charAt(j)) {
				ans++;
			} else {
				j = i;
			}
		}
		System.out.println(ans);
	}
}
```
### Go
``` go
package main
import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	reader := bufio.NewReader(os.Stdin)
	var n int
	fmt.Fscanln(reader, &n)
	var s string
	fmt.Fscanln(reader, &s)
	ans, j := 0, 0
	for i := 1; i < n; i++ {
		if s[i] == s[j] {
			ans++
		} else {
			j = i
		}
	}
	fmt.Println(ans)
}
```