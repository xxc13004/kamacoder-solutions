# 双向链表 + 哈希表
[题目链接](https://kamacoder.com/problempage.php?pid=1414)
## 思路分析

题目的意思是假如我们有一个堆叠起来的书，我们限制了最高只能堆到几层，即缓存的容量。我们每次用完这本书，就要把书放到这堆书的顶上。如果里面没找到我们想要的书，就将这本书买过来放到堆顶。如果超过了层数的限制，就将底部的书移除，再将新书加到堆顶。

那么我们需要在O(1)的时间内完成书的**查找、移除和新增**操作。我们知道哈希表可以在O(1)的时间完成查找操作。链表可以在O(1)的时间完成新增和移除操作，所以这道题可以用哈希表结合双向链表来实现。我们需要对链表的头，尾（书堆顶，堆底）进行操作，所以采用双向链表。

查询操作：就是书的查找操作，直接找哈希表即可。如果没找到就返回-1，如果找到了，就将该书从原来的位置移除，然后添加到书顶。

插入操作：不管怎么样都需要将书添加到书顶。然后看是否有这本书，没有就不管，有的话，就从原来的位置移除。

插入过后超出容量：那就在书的最底部移除一本书。

双向链表的实现，见下面的具体代码。

## 复杂度分析
1. 时间复杂度：O(L)；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include <bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
struct Node {
    int key, value;
    Node *next, *prev;
    Node(int k = 0, int v = 0) : key(k), value(v) {}
};
class LRUCache {
private:
    Node *dummy;
    int capacity;
    unordered_map<int, Node*> ump2node;
    // 移除一个节点
    void remove(Node* cur) {
        cur -> prev -> next = cur -> next;
        cur -> next -> prev = cur -> prev;
    }
    // 添加一个节点到链表头
    void add(Node* cur) {
        cur -> next = dummy -> next;
        cur -> prev = dummy;
        dummy -> next = cur;
        cur -> next -> prev = cur;
    }
    // 获取节点的值
    Node* get_node(int key) {
        auto it = ump2node.find(key);
        if (it == ump2node.end()) {  // 没找到
            return nullptr;
        }
        Node* node = it -> second;  // 当前节点的地址
        remove(node);  // 删除这个节点，然后移动到头部
        add(node);
        return node;
    }
public:
    LRUCache(int capacity) {
        this -> capacity = capacity;
        dummy = new Node();
        dummy -> prev = dummy;
        dummy -> next = dummy;
    }
    
    int get(int key) {  // 查询
        Node* node = get_node(key);
        return node ? node -> value : -1;
    }
    
    void put(int key, int value) {
        Node* node = get_node(key);
        if (node) {  // 有这个节点
            node -> value = value;  // 更新这个节点的值
            return;
        }
        node = new Node(key, value);  // 没有就新建一个节点
        ump2node[key] = node;  // 记录到哈希表
        add(node);
        if (ump2node.size() > capacity) {  // 容量超过了限制,删除链尾的元素
            Node* end_node = dummy -> prev;  // 链尾的元素
            ump2node.erase(end_node -> key);  // 从哈希表中删除
            remove(end_node);
            delete end_node;
        }
    }
};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n, l;
    cin >> n >> l;
    LRUCache lru(n);
    while (l--) {
        char op;
        cin >> op;
        if (op == 's') {
            int key, value;
            cin >> key >> value;
            lru.put(key, value);
        } else {
            int key;
            cin >> key;
            cout << lru.get(key) << endl;
        }
    }
    return 0;
}
```
### Python
``` python
class Node:
    """双向链表节点"""
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:
    """LRU缓存实现"""
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}  # 哈希表，存储key到节点的映射
        # 使用虚拟头尾节点简化链表操作
        self.head = Node()
        self.tail = Node()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.size = 0

    def get(self, key: int) -> int:
        """获取key对应的value，如果不存在返回-1"""
        if key not in self.cache:
            return -1
        
        # 将访问的节点移到链表头部
        node = self.cache[key]
        self._move_to_head(node)
        return node.value

    def set(self, key: int, value: int) -> None:
        """插入或更新key-value对"""
        if key in self.cache:
            # key已存在，更新值并移到头部
            node = self.cache[key]
            node.value = value
            self._move_to_head(node)
        else:
            # 创建新节点
            node = Node(key, value)
            self.cache[key] = node
            self._add_to_head(node)
            self.size += 1
            
            # 如果超出容量，删除尾部节点
            if self.size > self.capacity:
                removed = self._remove_tail()
                del self.cache[removed.key]
                self.size -= 1

    def _add_to_head(self, node: Node) -> None:
        """将节点添加到链表头部"""
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node

    def _remove_node(self, node: Node) -> None:
        """从链表中删除节点"""
        node.prev.next = node.next
        node.next.prev = node.prev

    def _move_to_head(self, node: Node) -> None:
        """将节点移到链表头部"""
        self._remove_node(node)
        self._add_to_head(node)

    def _remove_tail(self) -> Node:
        """删除链表尾部节点并返回"""
        node = self.tail.prev
        self._remove_node(node)
        return node

def solve():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    idx = 0
    N = int(data[idx]); idx += 1
    L = int(data[idx]); idx += 1
    
    cache = LRUCache(N)
    results = []
    
    for _ in range(L):
        op = data[idx]; idx += 1
        if op == 's':
            key = int(data[idx]); idx += 1
            value = int(data[idx]); idx += 1
            cache.set(key, value)
        elif op == 'g':
            key = int(data[idx]); idx += 1
            results.append(str(cache.get(key)))
    
    print("\n".join(results))

if __name__ == "__main__":
    solve()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    static class LRUCacheBruteForce {
        private int capacity;
        private Map<Integer, Integer> cache;  // 存储key-value
        private List<Integer> order;  // 存储访问顺序
        
        public LRUCacheBruteForce(int capacity) {
            this.capacity = capacity;
            this.cache = new HashMap<>();
            this.order = new ArrayList<>();
        }
        
        public int get(int key) {
            if (!cache.containsKey(key)) {
                return -1;
            }
            
            // 更新访问顺序：O(n)操作
            int index = order.indexOf(key);  // O(n) 查找
            if (index != -1) {
                order.remove(index);  // O(n) 删除
            }
            order.add(key);  // O(1) 添加到末尾
            return cache.get(key);
        }
        
        public void set(int key, int value) {
            if (cache.containsKey(key)) {
                cache.put(key, value);
                // 更新访问顺序
                int index = order.indexOf(key);  // O(n)
                if (index != -1) {
                    order.remove(index);  // O(n)
                }
                order.add(key);  // O(1)
            } else {
                if (cache.size() >= capacity) {
                    // 删除最久未使用的（列表第一个元素）
                    int lruKey = order.get(0);  // O(1)
                    order.remove(0);  // O(n) 删除第一个元素
                    cache.remove(lruKey);
                }
                
                cache.put(key, value);
                order.add(key);  // O(1)
            }
        }
    }
    
    public static void main(String[] args) throws IOException {
        // 使用BufferedReader优化输入
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        // 读取第一行：N和L
        String[] firstLine = br.readLine().split(" ");
        int N = Integer.parseInt(firstLine[0]);
        int L = Integer.parseInt(firstLine[1]);
        
        LRUCacheBruteForce cache = new LRUCacheBruteForce(N);
        
        for (int i = 0; i < L; i++) {
            String[] line = br.readLine().split(" ");
            char op = line[0].charAt(0);  // 操作类型：'s'或'g'
            
            if (op == 's') {
                int key = Integer.parseInt(line[1]);
                int value = Integer.parseInt(line[2]);
                cache.set(key, value);
            } else if (op == 'g') {
                int key = Integer.parseInt(line[1]);
                bw.write(String.valueOf(cache.get(key)));
                bw.newLine();
            }
        }
        
        bw.flush();
        bw.close();
        br.close();
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"os"
	"strconv"
	"strings"
)

type LRUCacheBruteForce struct {
	capacity int
	cache    map[int]int // 存储key-value
	order    []int       // 存储访问顺序
}

func NewLRUCacheBruteForce(capacity int) *LRUCacheBruteForce {
	return &LRUCacheBruteForce{
		capacity: capacity,
		cache:    make(map[int]int),
		order:    make([]int, 0),
	}
}

func (lru *LRUCacheBruteForce) get(key int) int {
	if value, exists := lru.cache[key]; exists {
		// 更新访问顺序：O(n)操作
		for i, k := range lru.order {
			if k == key {
				// 删除元素：O(n)时间，因为需要移动后续元素
				lru.order = append(lru.order[:i], lru.order[i+1:]...)
				break
			}
		}
		lru.order = append(lru.order, key) // O(1) 添加到末尾
		return value
	}
	return -1
}

func (lru *LRUCacheBruteForce) set(key, value int) {
	if _, exists := lru.cache[key]; exists {
		lru.cache[key] = value
		// 更新访问顺序
		for i, k := range lru.order {
			if k == key {
				// 删除元素
				lru.order = append(lru.order[:i], lru.order[i+1:]...)
				break
			}
		}
		lru.order = append(lru.order, key) // O(1)
	} else {
		if len(lru.cache) >= lru.capacity {
			// 删除最久未使用的（列表第一个元素）
			lruKey := lru.order[0]          // O(1)
			lru.order = lru.order[1:]       // O(1) 但底层是数组拷贝
			delete(lru.cache, lruKey)
		}

		lru.cache[key] = value
		lru.order = append(lru.order, key) // O(1)
	}
}

func main() {
	// 使用bufio优化输入输出
	reader := bufio.NewReader(os.Stdin)
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()
	
	// 读取第一行：N和L
	line, _ := reader.ReadString('\n')
	line = strings.TrimSpace(line)
	parts := strings.Split(line, " ")
	
	N, _ := strconv.Atoi(parts[0])
	L, _ := strconv.Atoi(parts[1])
	
	cache := NewLRUCacheBruteForce(N)
	
	for i := 0; i < L; i++ {
		line, _ := reader.ReadString('\n')
		line = strings.TrimSpace(line)
		opParts := strings.Split(line, " ")
		
		op := opParts[0]
		if op == "s" {
			key, _ := strconv.Atoi(opParts[1])
			value, _ := strconv.Atoi(opParts[2])
			cache.set(key, value)
		} else if op == "g" {
			key, _ := strconv.Atoi(opParts[1])
			result := cache.get(key)
			writer.WriteString(strconv.Itoa(result) + "\n")
		}
	}
}
```