# 二分+优先队列
[题目链接](https://kamacoder.com/problempage.php?pid=1380)
## 思路分析
我们需要从n个任务中选择k个任务，保持原始顺序，并将这些任务分成两部分（小明和小白各一部分），使得两人编辑时间中的较大值最小。类似于二分中最小化最大值的特征，所以可以采用二分。

为了方便起见，可以直接将下界设置为1，上界设置为一个较大的数，如1e18。二分的思路是枚举时间，判断在当前时间下是否能选择至少k个任务，使其满足能分割成两个部分，并且两边的和都不大于这个时间。

**check函数：**

我们需要枚举一个切割点，但是我们不关心切割点左边和右边的任务的顺序是什么，而只需要知道左边和右边的和各是多少。所以这里可以采取贪心的方式选取左边和右边的任务，需要用到优先队列实现。

具体做法是：设当前二分的答案是x

我们需要留下的任务一定不能超过x，因为超过x之后所有的，就很明显一边的总和不会小于等于x了。用两个数组L，R分别表开始从左边和从右边能选择的最大的任务数，L[i]表示前i个任务中能选择的总和不超过x的任务数，R[i]表示后i个任务中能选择的总和不超过x的任务数。那么之后枚举切割点的时候，只需要将L[i] + R[i]，并判断这个数是不是大于k就可以了。

如果在选择数的过程中，发现总和大于x了，就从堆顶取出当前最大的数，将其移出堆直至总和小于等于x，这样就能保证堆中的元素之和一定是小于等于x的，并且堆的大小就是能选择的任务的个数。

## 复杂度分析
1. 时间复杂度：O(nlog(C)log(n))；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include <bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
bool check(vector<int> &nums, int n, int k, LL mid) {
    priority_queue<LL> pq;
    // 分别计算左边和右边的和
    LL sum_l = 0, sum_r = 0;
    // 记录左边和右边最多能选择的数字的个数
    vector<int> L(n), R(n);
    // 计算左边能选择的数字个数
    for (int i = 0; i < n; ++i) {
        if (nums[i] <= mid) {
            pq.push(nums[i]);
            sum_l += nums[i];
            while (sum_l > mid && !pq.empty()) {
                sum_l -= pq.top();
                pq.pop();
            }
        }
        L[i] = pq.size();
    }
    // 清空优先队列，准备计算右边能选择的数字个数
    while (!pq.empty()) pq.pop();
    for (int i = n - 1; i >= 0; --i) {
        if (nums[i] <= mid) {
            pq.push(nums[i]);
            sum_r += nums[i];
            while (sum_r > mid && !pq.empty()) {
                sum_r -= pq.top();
                pq.pop();
            }
        }
        R[i] = pq.size();
    }

    // 检查是否存在一个划分点，使得左边和右边能选择的数字个数之和至少为 k
    if (L[n - 1] >= k) return true;
    if (R[0] >= k) return true;
    for (int i = 0; i < n - 1; ++i) {
        if (L[i] + R[i + 1] >= k) return true;
    }
    return false;
}
int main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    int n, k;
    cin >> t;
    while (t--) {
        cin >> n >> k;
        vector<int> nums(n);
        for (int i = 0; i < n; ++i)  cin >> nums[i];
        vector<int> idxs(n);
        LL l = 1, r = 1e18, mid = -1;
        while (l <= r) {
            mid = l + (r - l) / 2;
            if (check(nums, n, k, mid)) r = mid - 1;
            else l = mid + 1;
        }
        cout << l << endl;
    }
    return 0;
}
```
### Python
``` python
import heapq
import sys

def main():
    data = sys.stdin.read().split()
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n = int(data[index]); index += 1
        k = int(data[index]); index += 1
        tasks = list(map(int, data[index:index+n]))
        index += n
        
        low = 0
        high = 10**18
        ans = high
        while low <= high:
            mid = (low + high) // 2
            if check(mid, tasks, k):
                ans = mid
                high = mid - 1
            else:
                low = mid + 1
        results.append(str(ans))
    
    sys.stdout.write("\n".join(results))

def check(mid, tasks, k):
    if mid == 0:
        return k == 0
    n = len(tasks)
    L = [0] * n
    heap = []
    current_sum = 0
    for i in range(n):
        if tasks[i] <= mid:
            heapq.heappush(heap, -tasks[i])
            current_sum += tasks[i]
            while current_sum > mid and heap:
                max_val = -heapq.heappop(heap)
                current_sum -= max_val
        L[i] = len(heap)
    
    R = [0] * n
    heap_r = []
    current_sum_r = 0
    for i in range(n-1, -1, -1):
        if tasks[i] <= mid:
            heapq.heappush(heap_r, -tasks[i])
            current_sum_r += tasks[i]
            while current_sum_r > mid and heap_r:
                max_val = -heapq.heappop(heap_r)
                current_sum_r -= max_val
        R[i] = len(heap_r)
    
    if R[0] >= k:
        return True
    if L[n-1] >= k:
        return True
    for i in range(0, n-1):
        if L[i] + R[i+1] >= k:
            return True
    return False

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine());
        
        long[] results = new long[T];
        for (int t = 0; t < T; t++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            int k = Integer.parseInt(st.nextToken());
            
            int[] tasks = new int[n];
            st = new StringTokenizer(br.readLine());
            for (int i = 0; i < n; i++) {
                tasks[i] = Integer.parseInt(st.nextToken());
            }
            
            long low = 0;
            long high = (long) 1e18;
            
            while (low <= high) {
                long mid = low + (high - low) / 2;
                if (check(mid, tasks, k)) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            results[t] = low;
        }
        
        for (long res : results) {
            System.out.println(res);
        }
    }
    
    private static boolean check(long mid, int[] tasks, int k) {
        if (mid == 0) {
            return k == 0;
        }
        
        int n = tasks.length;
        int[] L = new int[n];
        int[] R = new int[n];
        
        // Calculate L array (left to right)
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
        long currentSum = 0;
        for (int i = 0; i < n; i++) {
            if (tasks[i] <= mid) {
                maxHeap.offer(tasks[i]);
                currentSum += tasks[i];
                while (currentSum > mid && !maxHeap.isEmpty()) {
                    int maxVal = maxHeap.poll();
                    currentSum -= maxVal;
                }
            }
            L[i] = maxHeap.size();
        }
        
        // Calculate R array (right to left)
        PriorityQueue<Integer> maxHeap2 = new PriorityQueue<>(Collections.reverseOrder());
        long currentSum2 = 0;
        for (int i = n - 1; i >= 0; i--) {
            if (tasks[i] <= mid) {
                maxHeap2.offer(tasks[i]);
                currentSum2 += tasks[i];
                while (currentSum2 > mid && !maxHeap2.isEmpty()) {
                    int maxVal = maxHeap2.poll();
                    currentSum2 -= maxVal;
                }
            }
            R[i] = maxHeap2.size();
        }
        
        // Check all possible cases
        if (R[0] >= k) {
            return true;
        }
        if (L[n - 1] >= k) {
            return true;
        }
        for (int i = 0; i < n - 1; i++) {
            if (L[i] + R[i + 1] >= k) {
                return true;
            }
        }
        
        return false;
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"container/heap"
	"os"
	"strconv"
	"strings"
)

type IntHeap []int

func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] > h[j] }
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	return x
}

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Buffer(make([]byte, 1<<20), 1<<20) // 设置缓冲区大小

	var T int
	scanner.Scan()
	T, _ = strconv.Atoi(scanner.Text())
	
	results := make([]int, T)
	for t := 0; t < T; t++ {
		scanner.Scan()
		line := strings.Fields(scanner.Text())
		n, _ := strconv.Atoi(line[0])
		k, _ := strconv.Atoi(line[1])
		
		tasks := make([]int, n)
		scanner.Scan()
		taskLine := strings.Fields(scanner.Text())
		for i := 0; i < n; i++ {
			tasks[i], _ = strconv.Atoi(taskLine[i])
		}
		
		low, high := 0, 1<<62
		ans := high
		for low <= high {
			mid := low + (high-low)/2
			if check(mid, tasks, k) {
				ans = mid
				high = mid - 1
			} else {
				low = mid + 1
			}
		}
		results[t] = ans
	}
	
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()
	for _, res := range results {
		writer.WriteString(strconv.Itoa(res) + "\n")
	}
}

func check(mid int, tasks []int, k int) bool {
	if mid == 0 {
		return k == 0
	}
	
	n := len(tasks)
	L := make([]int, n)
	R := make([]int, n)
	
	// Calculate L array (left to right)
	h := &IntHeap{}
	heap.Init(h)
	currentSum := 0
	for i := 0; i < n; i++ {
		if tasks[i] <= mid {
			heap.Push(h, tasks[i])
			currentSum += tasks[i]
			for currentSum > mid && h.Len() > 0 {
				maxVal := heap.Pop(h).(int)
				currentSum -= maxVal
			}
		}
		L[i] = h.Len()
	}
	
	// Calculate R array (right to left)
	h2 := &IntHeap{}
	heap.Init(h2)
	currentSum2 := 0
	for i := n - 1; i >= 0; i-- {
		if tasks[i] <= mid {
			heap.Push(h2, tasks[i])
			currentSum2 += tasks[i]
			for currentSum2 > mid && h2.Len() > 0 {
				maxVal := heap.Pop(h2).(int)
				currentSum2 -= maxVal
			}
		}
		R[i] = h2.Len()
	}
	
	// Check all possible cases
	if R[0] >= k {
		return true
	}
	if L[n-1] >= k {
		return true
	}
	for i := 0; i < n-1; i++ {
		if L[i]+R[i+1] >= k {
			return true
		}
	}
	
	return false
}
```