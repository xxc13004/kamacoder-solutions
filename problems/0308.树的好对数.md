# LCA + 状态机
[题目链接](https://kamacoder.com/problempage.php?pid=1388)
## 思路分析
由于本题难度过大，这里给出的代码并非最优解，但是可以通过极大部分代码。如果有能写出最优解的录友，可以在评论区分享。

具体思路是通过LCA（最近公共祖先）倍增算法计算出两个节点的最近公共祖先LCA(u, v) = p，然后就可以将这两个点的路径分为u -> p -> v即上行的部分和下行的部分。关于LCA算法如果不懂，可以先去学习再来。求LCA的目的是找到唯一的一条路径从u -> v，这是树的性质，这个路径一定经过这两个节点的LCA。

通过状态机对路径经过的字符串进行解析，看是否包含"BUG"子序列。这是关键的步骤，上述所说的非最优解难在这里，因为如果直接暴力匹配整条路径上的字符串，那么时间复杂度实际上是线性的，所以需要对这里进行优化，但是目前还没有找到好的办法。所以先用暴力匹配进行求解。状态定义如下：

- 0: 初始状态，或者没有匹配任何字符
- 1: 已经匹配了'B'
- 2: 已经匹配了'BU'
- 3: 已经匹配了'BUG'

**状态转移：**

- 在状态0：遇到'B' -> 状态1；其他字符 -> 状态0；
- 在状态1：遇到'U' -> 状态2；其他字符 -> 状态1；
- 在状态2：遇到'G' -> 状态3；其他字符 -> 状态2。

至此整个过程就变成了一个简单的从字符串中检测是否包含"BUG"子序列的问题。

## 复杂度分析
1. 时间复杂度：……；
2. 空间复杂度：……。
## 代码实现
### Cpp
``` cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

const int MAXN = 100005;
const int LOG = 17;

vector<int> tree[MAXN];
int parent[MAXN][LOG + 1];
int depth[MAXN];
char chars[MAXN];
int n, q;

void dfs(int u, int p) {
    parent[u][0] = p;
    for (int i = 1; i <= LOG; i++) {
        if (parent[u][i - 1] != -1) {
            parent[u][i] = parent[parent[u][i - 1]][i - 1];
        } else {
            parent[u][i] = -1;
        }
    }
    
    for (int v : tree[u]) {
        if (v != p) {
            depth[v] = depth[u] + 1;
            dfs(v, u);
        }
    }
}

int lca(int u, int v) {
    if (depth[u] < depth[v]) swap(u, v);
    
    int diff = depth[u] - depth[v];
    for (int i = LOG; i >= 0; i--) {
        if (diff >= (1 << i)) {
            u = parent[u][i];
            diff -= (1 << i);
        }
    }
    
    if (u == v) return u;
    
    for (int i = LOG; i >= 0; i--) {
        if (parent[u][i] != -1 && parent[u][i] != parent[v][i]) {
            u = parent[u][i];
            v = parent[v][i];
        }
    }
    return parent[u][0];
}

// 暴力获取路径上的字符序列
bool hasBug(int u, int v) {
    int w = lca(u, v);
    
    vector<char> sequence;
    
    // 从u走到w
    int curr = u;
    while (curr != w) {
        sequence.push_back(chars[curr]);
        curr = parent[curr][0];
    }
    sequence.push_back(chars[w]);
    
    // 从v走到w（不包括w）
    vector<char> temp;
    curr = v;
    while (curr != w) {
        temp.push_back(chars[curr]);
        curr = parent[curr][0];
    }
    // 将temp逆序加入sequence
    for (int i = temp.size() - 1; i >= 0; i--) {
        sequence.push_back(temp[i]);
    }
    
    // 在sequence中检查子序列"BUG"
    int state = 0;
    for (char c : sequence) {
        switch (state) {
            case 0: if (c == 'B') state = 1; break;
            case 1: if (c == 'U') state = 2; break;
            case 2: if (c == 'G') state = 3; break;
            default: break;
        }
        if (state == 3) return true;
    }
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    cin >> n >> q;
    
    for (int i = 1; i <= n; i++) {
        int p;
        cin >> p;
        if (p != 0) {
            tree[p].push_back(i);
            tree[i].push_back(p);
        }
    }
    
    for (int i = 1; i <= n; i++) {
        cin >> chars[i];
    }
    
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= LOG; j++) {
            parent[i][j] = -1;
        }
    }
    
    depth[1] = 0;
    dfs(1, -1);
    
    while (q--) {
        int u, v;
        cin >> u >> v;
        
        if (hasBug(u, v)) {
            cout << "NO\n";
        } else {
            cout << "YES\n";
        }
    }
    
    return 0;
}
```
### Python
``` python
import sys

MAXN = 100005
LOG = 17

tree = [[] for _ in range(MAXN)]
parent = [[-1] * (LOG + 1) for _ in range(MAXN)]
depth = [0] * MAXN
chars = [''] * MAXN

def dfs(u, p):
    parent[u][0] = p
    for i in range(1, LOG + 1):
        if parent[u][i - 1] != -1:
            parent[u][i] = parent[parent[u][i - 1]][i - 1]
        else:
            parent[u][i] = -1
            
    for v in tree[u]:
        if v != p:
            depth[v] = depth[u] + 1
            dfs(v, u)

def lca(u, v):
    if depth[u] < depth[v]:
        u, v = v, u
        
    diff = depth[u] - depth[v]
    for i in range(LOG, -1, -1):
        if diff >= (1 << i):
            u = parent[u][i]
            diff -= (1 << i)
            
    if u == v:
        return u
        
    for i in range(LOG, -1, -1):
        if parent[u][i] != -1 and parent[u][i] != parent[v][i]:
            u = parent[u][i]
            v = parent[v][i]
            
    return parent[u][0]

def has_bug(u, v):
    w = lca(u, v)
    
    sequence = []
    
    # 从 u 走到 w
    curr = u
    while curr != w:
        sequence.append(chars[curr])
        curr = parent[curr][0]
    sequence.append(chars[w])
    
    # 从 v 走到 w（不包括 w）
    temp = []
    curr = v
    while curr != w:
        temp.append(chars[curr])
        curr = parent[curr][0]
        
    # 将 temp 逆序加入 sequence
    for i in range(len(temp) - 1, -1, -1):
        sequence.append(temp[i])
        
    # 在 sequence 中检查子序列 "BUG"
    state = 0
    for c in sequence:
        if state == 0:
            if c == 'B':
                state = 1
        elif state == 1:
            if c == 'U':
                state = 2
        elif state == 2:
            if c == 'G':
                state = 3
                
        if state == 3:
            return True
            
    return False

def main():
    data = sys.stdin.read().split()
    it = iter(data)
    n = int(next(it)); q = int(next(it))
    
    for i in range(1, n + 1):
        p = int(next(it))
        if p != 0:
            tree[p].append(i)
            tree[i].append(p)
            
    for idx, x in enumerate(next(it)):
        chars[idx + 1] = x
        
        
    depth[1] = 0
    dfs(1, -1)
    
    out_lines = []
    for _ in range(q):
        u = int(next(it)); v = int(next(it))
        if has_bug(u, v):
            out_lines.append("NO")
        else:
            out_lines.append("YES")
            
    sys.stdout.write("\n".join(out_lines))

main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    static final int MAXN = 100005;
    static final int LOG = 17;
    
    static List<Integer>[] tree = new ArrayList[MAXN];
    static int[][] parent = new int[MAXN][LOG + 1];
    static int[] depth = new int[MAXN];
    static char[] chars = new char[MAXN];
    static int n, q;
    
    public static void main(String[] args) throws IOException {
        FastReader fr = new FastReader();
        PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        
        n = fr.nextInt();
        q = fr.nextInt();
        
        for (int i = 1; i <= n; i++) {
            tree[i] = new ArrayList<>();
        }
        
        for (int i = 1; i <= n; i++) {
            int p = fr.nextInt();
            if (p != 0) {
                tree[p].add(i);
                tree[i].add(p);
            }
        }
        
        String s = fr.next();  // 读取整个字符串
        for (int i = 1; i <= n; i++) {
            chars[i] = s.charAt(i - 1);  // 从字符串中获取字符
        }
        
        for (int i = 0; i <= n; i++) {
            Arrays.fill(parent[i], -1);
        }
        
        depth[1] = 0;
        dfs(1, -1);
        
        for (int i = 0; i < q; i++) {
            int u = fr.nextInt();
            int v = fr.nextInt();
            if (hasBug(u, v)) {
                pw.println("NO");
            } else {
                pw.println("YES");
            }
        }
        
        pw.flush();
        pw.close();
    }
    
    static void dfs(int u, int p) {
        parent[u][0] = p;
        for (int i = 1; i <= LOG; i++) {
            if (parent[u][i - 1] != -1) {
                parent[u][i] = parent[parent[u][i - 1]][i - 1];
            } else {
                parent[u][i] = -1;
            }
        }
        
        for (int v : tree[u]) {
            if (v != p) {
                depth[v] = depth[u] + 1;
                dfs(v, u);
            }
        }
    }
    
    static int lca(int u, int v) {
        if (depth[u] < depth[v]) {
            int temp = u;
            u = v;
            v = temp;
        }
        
        int diff = depth[u] - depth[v];
        for (int i = LOG; i >= 0; i--) {
            if (diff >= (1 << i)) {
                u = parent[u][i];
                diff -= (1 << i);
            }
        }
        
        if (u == v) return u;
        
        for (int i = LOG; i >= 0; i--) {
            if (parent[u][i] != -1 && parent[u][i] != parent[v][i]) {
                u = parent[u][i];
                v = parent[v][i];
            }
        }
        return parent[u][0];
    }
    
    static boolean hasBug(int u, int v) {
        int w = lca(u, v);
        
        List<Character> sequence = new ArrayList<>();
        
        int curr = u;
        while (curr != w) {
            sequence.add(chars[curr]);
            curr = parent[curr][0];
        }
        sequence.add(chars[w]);
        
        List<Character> temp = new ArrayList<>();
        curr = v;
        while (curr != w) {
            temp.add(chars[curr]);
            curr = parent[curr][0];
        }
        for (int i = temp.size() - 1; i >= 0; i--) {
            sequence.add(temp.get(i));
        }
        
        int state = 0;
        for (char c : sequence) {
            switch (state) {
                case 0: if (c == 'B') state = 1; break;
                case 1: if (c == 'U') state = 2; break;
                case 2: if (c == 'G') state = 3; break;
            }
            if (state == 3) return true;
        }
        return false;
    }
    
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;
        
        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }
        
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        
        int nextInt() {
            return Integer.parseInt(next());
        }
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"os"
)

const (
	MAXN = 100005
	LOG  = 17
)

var (
	tree   [MAXN][]int
	parent [MAXN][LOG + 1]int
	depth  [MAXN]int
	chars  [MAXN]byte
	n, q   int
)

func dfs(u, p int) {
	parent[u][0] = p
	for i := 1; i <= LOG; i++ {
		if parent[u][i-1] != -1 {
			parent[u][i] = parent[parent[u][i-1]][i-1]
		} else {
			parent[u][i] = -1
		}
	}

	for _, v := range tree[u] {
		if v != p {
			depth[v] = depth[u] + 1
			dfs(v, u)
		}
	}
}

func lca(u, v int) int {
	if depth[u] < depth[v] {
		u, v = v, u
	}

	diff := depth[u] - depth[v]
	for i := LOG; i >= 0; i-- {
		if diff >= (1 << uint(i)) {
			u = parent[u][i]
			diff -= (1 << uint(i))
		}
	}

	if u == v {
		return u
	}

	for i := LOG; i >= 0; i-- {
		if parent[u][i] != -1 && parent[u][i] != parent[v][i] {
			u = parent[u][i]
			v = parent[v][i]
		}
	}
	return parent[u][0]
}

func hasBug(u, v int) bool {
	w := lca(u, v)

	sequence := make([]byte, 0)

	curr := u
	for curr != w {
		sequence = append(sequence, chars[curr])
		curr = parent[curr][0]
	}
	sequence = append(sequence, chars[w])

	temp := make([]byte, 0)
	curr = v
	for curr != w {
		temp = append(temp, chars[curr])
		curr = parent[curr][0]
	}
	for i := len(temp) - 1; i >= 0; i-- {
		sequence = append(sequence, temp[i])
	}

	state := 0
	for _, c := range sequence {
		switch state {
		case 0:
			if c == 'B' {
				state = 1
			}
		case 1:
			if c == 'U' {
				state = 2
			}
		case 2:
			if c == 'G' {
				state = 3
			}
		}
		if state == 3 {
			return true
		}
	}
	return false
}

func main() {
	// 使用更大的缓冲区
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Buffer(make([]byte, 64*1024), 1024*1024) // 64KB初始，最大1MB
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()

	// 读取第一行：n和q
	scanner.Scan()
	line := scanner.Text()
	pos := 0
	for i := 0; i < 2; i++ {
		num := 0
		for pos < len(line) && line[pos] >= '0' && line[pos] <= '9' {
			num = num*10 + int(line[pos]-'0')
			pos++
		}
		pos++ // 跳过空格
		if i == 0 {
			n = num
		} else {
			q = num
		}
	}

	// 初始化树
	for i := 1; i <= n; i++ {
		tree[i] = make([]int, 0)
	}

	// 读取父节点信息
	scanner.Scan()
	parentLine := scanner.Text()
	pos = 0
	for i := 1; i <= n; i++ {
		num := 0
		for pos < len(parentLine) && parentLine[pos] >= '0' && parentLine[pos] <= '9' {
			num = num*10 + int(parentLine[pos]-'0')
			pos++
		}
		pos++ // 跳过空格
		if num != 0 {
			tree[num] = append(tree[num], i)
			tree[i] = append(tree[i], num)
		}
	}

	// 读取字符
	scanner.Scan()
	s := scanner.Text()
	for i := 1; i <= n; i++ {
		chars[i] = s[i-1]
	}

	// 初始化parent数组
	for i := 0; i <= n; i++ {
		for j := 0; j <= LOG; j++ {
			parent[i][j] = -1
		}
	}

	depth[1] = 0
	dfs(1, -1)

	// 处理查询
	for i := 0; i < q; i++ {
		scanner.Scan()
		queryLine := scanner.Text()
		pos := 0
		u, v := 0, 0
		for j := 0; j < 2; j++ {
			num := 0
			for pos < len(queryLine) && queryLine[pos] >= '0' && queryLine[pos] <= '9' {
				num = num*10 + int(queryLine[pos]-'0')
				pos++
			}
			pos++ // 跳过空格
			if j == 0 {
				u = num
			} else {
				v = num
			}
		}

		if hasBug(u, v) {
			writer.WriteString("NO\n")
		} else {
			writer.WriteString("YES\n")
		}
	}
}
```