# 图论 + 广搜
[题目链接](https://kamacoder.com/problempage.php?pid=1359)
## 思路分析
对于每个起始人：

1. 如果起始人u是类型2，则只有u自己听到流言；
2. 如果起始人u是类型1，则流言会传播到以下人群：
    - 所有在子图G'（仅包含类型1节点及其之间的边）中与u连通的其他类型1节点；
    - 所有与上述类型1节点相邻的类型2节点。

所以对图进行预处理，创建一个新图，仅包含类型1节点及其之间的边，然后在G'上使用BFS或DFS找出所有连通分量，并为每个分量分配唯一ID。

对于每一个联通分量C：
- 计算分量大小|C|（类型1节点数）；
- 计算邻接的类型2节点数|N(C)|。

最后，对于查询数组，若起始人u是类型2，输出1；
若起始人u是类型1，找到其所在的联通分量C，输出|C| + |N(C)|。

## 复杂度分析
1. 时间复杂度：O(n + q)；
2. 空间复杂度：O(n + m)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n, m, q;
    cin >> n >> m >> q;
    // 建无向立图
    vector<vector<int>> adj(n+1);
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    // 读取每个节点的类型
    vector<int> type(n+1);
    for (int i = 1; i <= n; i++) {
        cin >> type[i];
    }
    // 准备创建子图，将每个类型1节点的朋友(类型1)，全部放进子图中
    vector<vector<int>> adj_g(n+1);
    for (int u = 1; u <= n; u++) {
        if (type[u] == 1) {
            for (int v : adj[u]) {
                if (type[v] == 1) {
                    adj_g[u].push_back(v);
                }
            }
        }
    }
    
    vector<int> comp_id(n+1, -1);  // 记录每一个节点所属的联通量的id
    vector<int> comp_size;  // 对应id联通量的大小（类型1的朋友）
    vector<int> comp_n_size;  // 对应id联通量的类型2朋友数量
    vector<bool> visited(n+1, false);  // 是否访问过
    int comp_count = 0;  // 控制id进行自增
    
    for (int u = 1; u <= n; u++) {
        if (type[u] == 1 && !visited[u]) {
            // 当前联通分量的id
            int cid = comp_count;
            comp_count++;
            vector<int> comp_nodes;
            // 从这个节点开始进行广搜
            queue<int> q_bfs;
            q_bfs.push(u);
            visited[u] = true;
            // 将当前联通分量的节点的id全部标记为1
            comp_id[u] = cid;
            
            // 找到当前节点的所有联通量
            while (!q_bfs.empty()) {
                int node = q_bfs.front();
                q_bfs.pop();
                comp_nodes.push_back(node);
                for (int neighbor : adj_g[node]) {
                    if (!visited[neighbor]) {
                        visited[neighbor] = true;
                        comp_id[neighbor] = cid;
                        q_bfs.push(neighbor);
                    }
                }
            }
            
            comp_size.push_back(comp_nodes.size());
            
            // 找到第二种类型的朋友，即上面所述的第二类数量
            unordered_set<int> n_set;
            for (int node : comp_nodes) {
                for (int neighbor : adj[node]) {
                    if (type[neighbor] == 2) {
                        n_set.insert(neighbor);
                    }
                }
            }
            comp_n_size.push_back(n_set.size());
        }
    }
    
    while (q--) {
        int u;
        cin >> u;
        if (type[u] == 2) {
            cout << 1 << ' ';
        } else {
            int cid = comp_id[u];
            cout << comp_size[cid] + comp_n_size[cid] << ' ';
        }
    }
    return 0;
}
```
### Python
``` python
import sys
from collections import deque, defaultdict

def main():
    input = sys.stdin.read().split()
    ptr = 0
    n, m, q = map(int, input[ptr:ptr+3])
    ptr += 3
    
    # Build graph
    adj = [[] for _ in range(n+1)]
    for _ in range(m):
        u, v = map(int, input[ptr:ptr+2])
        ptr += 2
        adj[u].append(v)
        adj[v].append(u)
    
    # Read types
    type = [0] * (n+1)
    for i in range(1, n+1):
        type[i] = int(input[ptr])
        ptr += 1
    
    # Build subgraph for type 1 nodes
    adj_g = [[] for _ in range(n+1)]
    for u in range(1, n+1):
        if type[u] == 1:
            for v in adj[u]:
                if type[v] == 1:
                    adj_g[u].append(v)
    
    comp_id = [-1] * (n+1)
    comp_size = []
    comp_n_size = []
    visited = [False] * (n+1)
    comp_count = 0
    
    for u in range(1, n+1):
        if type[u] == 1 and not visited[u]:
            cid = comp_count
            comp_count += 1
            comp_nodes = []
            q_bfs = deque([u])
            visited[u] = True
            comp_id[u] = cid
            
            while q_bfs:
                node = q_bfs.popleft()
                comp_nodes.append(node)
                for neighbor in adj_g[node]:
                    if not visited[neighbor]:
                        visited[neighbor] = True
                        comp_id[neighbor] = cid
                        q_bfs.append(neighbor)
            
            comp_size.append(len(comp_nodes))
            
            n_set = set()
            for node in comp_nodes:
                for neighbor in adj[node]:
                    if type[neighbor] == 2:
                        n_set.add(neighbor)
            comp_n_size.append(len(n_set))
    
    # Process queries
    output = []
    for _ in range(q):
        u = int(input[ptr])
        ptr += 1
        if type[u] == 2:
            output.append('1')
        else:
            cid = comp_id[u]
            output.append(str(comp_size[cid] + comp_n_size[cid]))
    
    print(' '.join(output))

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        String[] firstLine = br.readLine().split(" ");
        int n = Integer.parseInt(firstLine[0]);
        int m = Integer.parseInt(firstLine[1]);
        int q = Integer.parseInt(firstLine[2]);
        
        // Build graph
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i <= n; i++) adj.add(new ArrayList<>());
        for (int i = 0; i < m; i++) {
            String[] edge = br.readLine().split(" ");
            int u = Integer.parseInt(edge[0]);
            int v = Integer.parseInt(edge[1]);
            adj.get(u).add(v);
            adj.get(v).add(u);
        }
        
        // Read types
        int[] type = new int[n+1];
        String[] types = br.readLine().split(" ");
        for (int i = 1; i <= n; i++) {
            type[i] = Integer.parseInt(types[i-1]);
        }
        
        // Build subgraph for type 1 nodes
        List<List<Integer>> adj_g = new ArrayList<>();
        for (int i = 0; i <= n; i++) adj_g.add(new ArrayList<>());
        for (int u = 1; u <= n; u++) {
            if (type[u] == 1) {
                for (int v : adj.get(u)) {
                    if (type[v] == 1) {
                        adj_g.get(u).add(v);
                    }
                }
            }
        }
        
        int[] compId = new int[n+1];
        Arrays.fill(compId, -1);
        List<Integer> compSize = new ArrayList<>();
        List<Integer> compNSize = new ArrayList<>();
        boolean[] visited = new boolean[n+1];
        int compCount = 0;
        
        for (int u = 1; u <= n; u++) {
            if (type[u] == 1 && !visited[u]) {
                int cid = compCount++;
                List<Integer> compNodes = new ArrayList<>();
                Queue<Integer> queue = new LinkedList<>();
                queue.add(u);
                visited[u] = true;
                compId[u] = cid;
                
                while (!queue.isEmpty()) {
                    int node = queue.poll();
                    compNodes.add(node);
                    for (int neighbor : adj_g.get(node)) {
                        if (!visited[neighbor]) {
                            visited[neighbor] = true;
                            compId[neighbor] = cid;
                            queue.add(neighbor);
                        }
                    }
                }
                
                compSize.add(compNodes.size());
                
                Set<Integer> nSet = new HashSet<>();
                for (int node : compNodes) {
                    for (int neighbor : adj.get(node)) {
                        if (type[neighbor] == 2) {
                            nSet.add(neighbor);
                        }
                    }
                }
                compNSize.add(nSet.size());
            }
        }
        
        // Process queries
        String[] queries = br.readLine().split(" ");
        for (int i = 0; i < q; i++) {
            int u = Integer.parseInt(queries[i]);
            if (type[u] == 2) {
                bw.write("1 ");
            } else {
                int cid = compId[u];
                bw.write((compSize.get(cid) + compNSize.get(cid)) + " ");
            }
        }
        bw.flush();
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Split(bufio.ScanWords)
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()

	// Read n, m, q
	scanner.Scan()
	n, _ := strconv.Atoi(scanner.Text())
	scanner.Scan()
	m, _ := strconv.Atoi(scanner.Text())
	scanner.Scan()
	q, _ := strconv.Atoi(scanner.Text())

	// Build graph
	adj := make([][]int, n+1)
	for i := 0; i < m; i++ {
		scanner.Scan()
		u, _ := strconv.Atoi(scanner.Text())
		scanner.Scan()
		v, _ := strconv.Atoi(scanner.Text())
		adj[u] = append(adj[u], v)
		adj[v] = append(adj[v], u)
	}

	// Read types
	typeArr := make([]int, n+1)
	for i := 1; i <= n; i++ {
		scanner.Scan()
		typeArr[i], _ = strconv.Atoi(scanner.Text())
	}

	// Build subgraph for type 1 nodes
	adjG := make([][]int, n+1)
	for u := 1; u <= n; u++ {
		if typeArr[u] == 1 {
			for _, v := range adj[u] {
				if typeArr[v] == 1 {
					adjG[u] = append(adjG[u], v)
				}
			}
		}
	}

	compId := make([]int, n+1)
	for i := range compId {
		compId[i] = -1
	}
	var compSize, compNSize []int
	visited := make([]bool, n+1)
	compCount := 0

	for u := 1; u <= n; u++ {
		if typeArr[u] == 1 && !visited[u] {
			cid := compCount
			compCount++
			var compNodes []int
			queue := []int{u}
			visited[u] = true
			compId[u] = cid

			for len(queue) > 0 {
				node := queue[0]
				queue = queue[1:]
				compNodes = append(compNodes, node)
				for _, neighbor := range adjG[node] {
					if !visited[neighbor] {
						visited[neighbor] = true
						compId[neighbor] = cid
						queue = append(queue, neighbor)
					}
				}
			}

			compSize = append(compSize, len(compNodes))

			nSet := make(map[int]bool)
			for _, node := range compNodes {
				for _, neighbor := range adj[node] {
					if typeArr[neighbor] == 2 {
						nSet[neighbor] = true
					}
				}
			}
			compNSize = append(compNSize, len(nSet))
		}
	}

	// Process queries
	for i := 0; i < q; i++ {
		scanner.Scan()
		u, _ := strconv.Atoi(scanner.Text())
		if typeArr[u] == 2 {
			fmt.Fprint(writer, "1 ")
		} else {
			cid := compId[u]
			fmt.Fprintf(writer, "%d ", compSize[cid]+compNSize[cid])
		}
	}
}
```