# 字符串 + 双指针
[题目链接](https://kamacoder.com/problempage.php?pid=1390)
## 思路分析
这道题实际上有点偏思维题，需要分析题目中去重递增的性质。

假设我们知道一个子串中没有重复的字符，如何判断这个串是不是满足题意的串呢？很简单，那就是这个串中是否存在一个逆序对就可以了，如果不存在，那就满足；反之则不满足。快速判断是否存在逆序对的方法是维护这个串之前出现过的（最大或最小的字符），然后判断是不是比当前的字符大（或者小）。

但是现在题目的子串明显是可能存在重复字符的。我们可以倒序遍历这个字符串（表示以当前字符s[i]为左边界直到字符串末尾的所有子串中满足题意的串数量），然后用一个数组last维护: 每一个字符最后一次出现的位置（倒序遍历最后一次遍历的位置，而不是在实际串中下标最大的位置），然后从'z' -> 'a'的顺序枚举字符，记为c，与此同时维护右边界k与当前最大字符出现的最靠左的位置j。

如果这个字符c在我们已经遍历过得字符中出现过，那么就与j作比较：

1. 如果j < last[c]，就说明存在逆序对，需要缩小右边界k；
2. 同时，只要字符c已经出现过，我们都一定要更新j为最小。

最后的答案就是**右边界 - 左边界**，即k - i。

## 复杂度分析
1. 时间复杂度：O(26n)；
2. 空间复杂度：O(1)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n;
    cin >> n;
    char *s = new char[n + 1];
    cin >> s;
    vector<int> last(128, -1);
    LL ans = 0;
    for (int i = n - 1; i >= 0; --i) {
        last[s[i]] = i;
        int j = n, k = n;  // 当前最大字符最左的位置，和实际的窗口
        for (int c = 'z'; c >= 'a'; --c) {
            if (last[c] != -1) {
                if (j < last[c]) k = min(k, last[c]);
                j = min(j, last[c]);
            }
        }
        ans += k - i;
    }
    cout << ans << endl;
    return 0;
}
```
### Python
``` python
import sys

def main():
    input = sys.stdin.read().splitlines()
    n = int(input[0])
    s = input[1].strip()
    
    last = [-1] * 128
    ans = 0
    
    for i in range(n - 1, -1, -1):
        last[ord(s[i])] = i
        j = n
        k = n
        
        for c in range(ord('z'), ord('a') - 1, -1):
            if last[c] != -1:
                if j < last[c]:
                    k = min(k, last[c])
                j = min(j, last[c])
        
        ans += k - i
    
    print(ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        int n = Integer.parseInt(br.readLine());
        String s = br.readLine();
        
        int[] last = new int[128];
        Arrays.fill(last, -1);
        
        long ans = 0;
        
        for (int i = n - 1; i >= 0; i--) {
            last[s.charAt(i)] = i;
            int j = n, k = n;
            
            for (int c = 'z'; c >= 'a'; c--) {
                if (last[c] != -1) {
                    if (j < last[c]) {
                        k = Math.min(k, last[c]);
                    }
                    j = Math.min(j, last[c]);
                }
            }
            
            ans += k - i;
        }
        
        System.out.println(ans);
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

func main() {
	const bufferSize = 1 << 20 // 1MB缓冲区
	reader := bufio.NewReaderSize(os.Stdin, bufferSize)
	writer := bufio.NewWriterSize(os.Stdout, bufferSize)
	defer writer.Flush()

	// 读取第一行
	line, _ := reader.ReadString('\n')
	var n int
	fmt.Sscanf(strings.TrimSpace(line), "%d", &n)

	// 读取字符串
	s, _ := reader.ReadString('\n')
	s = strings.TrimSpace(s)

	last := make([]int, 128)
	for i := range last {
		last[i] = -1
	}

	var ans int

	for i := n - 1; i >= 0; i-- {
		last[s[i]] = i
		j, k := n, n

		// 从'z'到'a'遍历
		for c := 'z'; c >= 'a'; c-- {
			if last[c] != -1 {
				if j < last[c] {
					if last[c] < k {
						k = last[c]
					}
				}
				if last[c] < j {
					j = last[c]
				}
			}
		}

		ans += k - i
	}

	fmt.Fprintln(writer, ans)
}
```