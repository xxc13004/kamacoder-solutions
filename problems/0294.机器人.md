# 深度优先搜索
[题目链接](https://kamacoder.com/problempage.php?pid=1374)
## 思路分析
因为时间给的足够大，而机器人每时刻会移动一格，所以在最终时刻还存在网格中的机器人一定是陷入了循环的机器人。所以我们只需要找图中存在的环即可，环中所有的机器人一定出不去。

但是直接找环可能不好找，所以我们可以逆向思维，如果一个机器人最终可以从边缘出去，那么一定可以按照反方向从边缘到他原来的位置，所以我们可以直接从网格的四条边开始遍历，按照逆向的移动规则，依次往里面走，经过的格子一定是可以逃出去的机器人。因为机器人一定只能从网格的边缘逃出去。

使用dfs以四条边为入口，往里面遍历，能够到达的格子一定是损坏的机器人数量cnt。最终的答案就是n * m - cnt。
## 复杂度分析
1. 时间复杂度：O(n * m)；
2. 空间复杂度：O(n * m)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n, m;
    cin >> n >> m;
    vector<string> grids(n);
    for (int i = 0; i < n; ++i) cin >> grids[i];
    vector<vector<int>> vis(n, vector<int> (m, 0));
    auto dfs = [&](auto&& dfs, int x, int y) -> void {
        vis[x][y] = 1;
        for (int i = 0; i < 4; ++i) {
            int dx = x + dir[i], dy = y + dir[i + 1];
            if (dx < 0 || dx >= n || dy < 0 || dy >= m || vis[dx][dy]) continue;
            // 下，左，上，右
            if (i == 0 && grids[dx][dy] == 'U') dfs(dfs, dx, dy);
            if (i == 1 && grids[dx][dy] == 'R') dfs(dfs, dx, dy);
            if (i == 2 && grids[dx][dy] == 'D') dfs(dfs, dx, dy);
            if (i == 3 && grids[dx][dy] == 'L') dfs(dfs, dx, dy);
        }
    };
    // 遍历四条外边框
    for (int i = 0; i < m; ++i) {
        if (grids[0][i] == 'U') dfs(dfs, 0, i);
        if (grids[n - 1][i] == 'D') dfs(dfs, n - 1, i);
    }
    for (int i = 0; i < n; ++i) {
        if (grids[i][0] == 'L') dfs(dfs, i, 0);
        if (grids[i][m - 1] == 'R') dfs(dfs, i, m - 1);
    }
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            ans += vis[i][j];
        }
    }
    cout << n * m - ans << endl;
    return 0;
}
```
### Python
``` python
import sys
sys.setrecursionlimit(1000000)

def main():
    data = sys.stdin.read().splitlines()
    if not data:
        return
    n, m = map(int, data[0].split())
    grids = []
    for i in range(1, 1 + n):
        grids.append(data[i].strip())
    
    vis = [[0] * m for _ in range(n)]
    dirs = [1, 0, -1, 0, 1]
    
    def dfs(x, y):
        vis[x][y] = 1
        for i in range(4):
            dx = x + dirs[i]
            dy = y + dirs[i + 1]
            if dx < 0 or dx >= n or dy < 0 or dy >= m or vis[dx][dy]:
                continue
            if i == 0 and grids[dx][dy] == 'U':
                dfs(dx, dy)
            if i == 1 and grids[dx][dy] == 'R':
                dfs(dx, dy)
            if i == 2 and grids[dx][dy] == 'D':
                dfs(dx, dy)
            if i == 3 and grids[dx][dy] == 'L':
                dfs(dx, dy)
                
    # 遍历四条外边框
    for j in range(m):
        if grids[0][j] == 'U':
            dfs(0, j)
        if grids[n-1][j] == 'D':
            dfs(n-1, j)
            
    for i in range(n):
        if grids[i][0] == 'L':
            dfs(i, 0)
        if grids[i][m-1] == 'R':
            dfs(i, m-1)
            
    ans = 0
    for i in range(n):
        for j in range(m):
            ans += vis[i][j]
            
    print(n * m - ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.util.*;
import java.io.*;

public class Main {
    static int n, m;
    static String[] grids;
    static int[][] vis;
    static int[] dir = {1, 0, -1, 0, 1};
    
    static void dfs(int x, int y) {
        vis[x][y] = 1;
        for (int i = 0; i < 4; i++) {
            int dx = x + dir[i];
            int dy = y + dir[i + 1];
            if (dx < 0 || dx >= n || dy < 0 || dy >= m || vis[dx][dy] == 1) 
                continue;
            if (i == 0 && grids[dx].charAt(dy) == 'U') dfs(dx, dy);
            if (i == 1 && grids[dx].charAt(dy) == 'R') dfs(dx, dy);
            if (i == 2 && grids[dx].charAt(dy) == 'D') dfs(dx, dy);
            if (i == 3 && grids[dx].charAt(dy) == 'L') dfs(dx, dy);
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] firstLine = br.readLine().split(" ");
        n = Integer.parseInt(firstLine[0]);
        m = Integer.parseInt(firstLine[1]);
        grids = new String[n];
        for (int i = 0; i < n; i++) {
            grids[i] = br.readLine();
        }
        vis = new int[n][m];
        
        // 遍历四条外边框
        for (int i = 0; i < m; i++) {
            if (grids[0].charAt(i) == 'U') dfs(0, i);
            if (grids[n-1].charAt(i) == 'D') dfs(n-1, i);
        }
        for (int i = 0; i < n; i++) {
            if (grids[i].charAt(0) == 'L') dfs(i, 0);
            if (grids[i].charAt(m-1) == 'R') dfs(i, m-1);
        }
        
        int ans = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                ans += vis[i][j];
            }
        }
        System.out.println(n * m - ans);
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
)

var (
	n, m  int
	grids []string
	vis   [][]int
	dir   = []int{1, 0, -1, 0, 1}
)

func dfs(x, y int) {
	vis[x][y] = 1
	for i := 0; i < 4; i++ {
		dx := x + dir[i]
		dy := y + dir[i+1]
		if dx < 0 || dx >= n || dy < 0 || dy >= m || vis[dx][dy] == 1 {
			continue
		}
		if i == 0 && grids[dx][dy] == 'U' {
			dfs(dx, dy)
		}
		if i == 1 && grids[dx][dy] == 'R' {
			dfs(dx, dy)
		}
		if i == 2 && grids[dx][dy] == 'D' {
			dfs(dx, dy)
		}
		if i == 3 && grids[dx][dy] == 'L' {
			dfs(dx, dy)
		}
	}
}

func main() {
	reader := bufio.NewReader(os.Stdin)
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()

	fmt.Fscan(reader, &n, &m)
	grids = make([]string, n)
	for i := 0; i < n; i++ {
		fmt.Fscan(reader, &grids[i])
	}

	vis = make([][]int, n)
	for i := range vis {
		vis[i] = make([]int, m)
	}

	// 遍历四条外边框
	for j := 0; j < m; j++ {
		if grids[0][j] == 'U' {
			dfs(0, j)
		}
		if grids[n-1][j] == 'D' {
			dfs(n-1, j)
		}
	}
	for i := 0; i < n; i++ {
		if grids[i][0] == 'L' {
			dfs(i, 0)
		}
		if grids[i][m-1] == 'R' {
			dfs(i, m-1)
		}
	}

	ans := 0
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			ans += vis[i][j]
		}
	}
	fmt.Fprintln(writer, n*m-ans)
}
```