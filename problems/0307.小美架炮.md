# 有序集合+二分
[题目链接](https://kamacoder.com/problempage.php?pid=1387)
## 思路分析
将x轴和y轴分开进行求解，因为一个棋子只会有4个方向，x轴代表左右，y轴代表上下。对两个轴分别进行排序处理并按照另一个轴进行分类，如按y轴进行分类，就是将y=c所代表的这条线上的点全部归类，可以通过哈希表实现。然后按照这些点的x坐标进行排序，这样就可以知道所有的点的左右方向能吃到的棋子了。具体通过二分进行求解。

设当前点的坐标为(x, y)

1. 求左边：找到x在有序集合中的位置，如果这个位置不在集合的前两个位置，那么说明可以攻击到左边的炮。

2. 求右边：只需要二分找到第一个大于x的元素的位置，然后这个位置不在集合的最后一个元素的位置即可，这个元素可以理解为给炮垫脚的棋子，只要这个垫脚石不在最后一个位置，就说明这个炮可以攻击到其他的棋子。

3. 上面和下面的原理与左右一样。

上述是基于c++，set的性质来做的，因为c++的容器的迭代器的特殊性，所以这样做。其他语言也可以这么做，反正就是找到给炮垫脚的棋子，这个垫脚的棋子不能是集合的第一个和最后一个元素即可。

## 复杂度分析
1. 时间复杂度：O(nlogn)；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n;
    cin >> n;
    map<int, set<int>> xmp, ymp;
    vector<PII> vps;
    for (int i = 0, x, y; i < n; ++i) {
        cin >> x >> y;
        vps.emplace_back(x, y);
        xmp[x].insert(y);
        ymp[y].insert(x);
    }
    for (auto [x, y] : vps) {
        int ans = 0;
        const auto &my = ymp[y], &mx = xmp[x];
        // 找到左边和右边的受害者
        auto lit = my.find(x);
        if (lit != my.begin() && prev(lit) != my.begin()) ++ans;
        auto rit = my.lower_bound(x + 1);
        if (rit != my.end() && next(rit) != my.end()) ++ans;
        // 找到上面和下面的受害者
        auto uit = mx.find(y);
        if (uit != mx.begin() && prev(uit) != mx.begin()) ++ans;
        auto dit = mx.lower_bound(y + 1);
        if (dit != mx.end() && next(dit) != mx.end()) ++ans;
        cout << ans << endl;
    }
    return 0;
}
```
### Python
``` python
import sys
from collections import defaultdict

def main():
    input = sys.stdin.readline
    n = int(input().strip())
    xmp = defaultdict(set)
    ymp = defaultdict(set)
    vps = []
    
    for _ in range(n):
        x, y = map(int, input().split())
        vps.append((x, y))
        xmp[x].add(y)
        ymp[y].add(x)
    
    # 对每个坐标的集合进行排序
    for x in xmp:
        xmp[x] = sorted(xmp[x])
    for y in ymp:
        ymp[y] = sorted(ymp[y])
    
    for x, y in vps:
        ans = 0
        my = ymp[y]  # 同一y坐标的所有x值
        mx = xmp[x]  # 同一x坐标的所有y值
        
        # 找到左边和右边的受害者
        idx_x = my.index(x)
        if idx_x >= 2:  # 左边至少有两个点
            ans += 1
        if len(my) - idx_x - 1 >= 2:  # 右边至少有两个点
            ans += 1
        
        # 找到上面和下面的受害者
        idx_y = mx.index(y)
        if idx_y >= 2:  # 下面至少有两个点
            ans += 1
        if len(mx) - idx_y - 1 >= 2:  # 上面至少有两个点
            ans += 1
        
        print(ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        
        int n = Integer.parseInt(br.readLine());
        Map<Integer, TreeSet<Integer>> xmp = new HashMap<>();
        Map<Integer, TreeSet<Integer>> ymp = new HashMap<>();
        List<int[]> vps = new ArrayList<>();
        
        for (int i = 0; i < n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int x = Integer.parseInt(st.nextToken());
            int y = Integer.parseInt(st.nextToken());
            vps.add(new int[]{x, y});
            
            xmp.computeIfAbsent(x, k -> new TreeSet<>()).add(y);
            ymp.computeIfAbsent(y, k -> new TreeSet<>()).add(x);
        }
        
        for (int[] point : vps) {
            int x = point[0], y = point[1];
            int ans = 0;
            
            TreeSet<Integer> my = ymp.get(y);  // 同一y坐标的所有x值
            TreeSet<Integer> mx = xmp.get(x);  // 同一x坐标的所有y值
            
            // 找到左边和右边的受害者
            Integer lower = my.lower(x);
            if (lower != null) {
                Integer lower2 = my.lower(lower);
                if (lower2 != null) ans++;
            }
            
            Integer higher = my.higher(x);
            if (higher != null) {
                Integer higher2 = my.higher(higher);
                if (higher2 != null) ans++;
            }
            
            // 找到上面和下面的受害者
            Integer lowerY = mx.lower(y);
            if (lowerY != null) {
                Integer lowerY2 = mx.lower(lowerY);
                if (lowerY2 != null) ans++;
            }
            
            Integer higherY = mx.higher(y);
            if (higherY != null) {
                Integer higherY2 = mx.higher(higherY);
                if (higherY2 != null) ans++;
            }
            
            pw.println(ans);
        }
        
        pw.flush();
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
)

func main() {
	reader := bufio.NewReader(os.Stdin)
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()

	var n int
	fmt.Fscan(reader, &n)

	xmp := make(map[int][]int)
	ymp := make(map[int][]int)
	vps := make([][2]int, n)

	for i := 0; i < n; i++ {
		var x, y int
		fmt.Fscan(reader, &x, &y)
		vps[i] = [2]int{x, y}
		xmp[x] = append(xmp[x], y)
		ymp[y] = append(ymp[y], x)
	}

	// 对每个坐标的切片进行排序
	for x := range xmp {
		sort.Ints(xmp[x])
	}
	for y := range ymp {
		sort.Ints(ymp[y])
	}

	for _, point := range vps {
		x, y := point[0], point[1]
		ans := 0

		my := ymp[y] // 同一y坐标的所有x值
		mx := xmp[x] // 同一x坐标的所有y值

		// 找到当前点在对应列表中的位置
		idxX := sort.SearchInts(my, x)
		idxY := sort.SearchInts(mx, y)

		// 检查左边和右边
		if idxX >= 2 { // 左边至少有两个点
			ans++
		}
		if len(my)-idxX-1 >= 2 { // 右边至少有两个点
			ans++
		}

		// 检查上面和下面
		if idxY >= 2 { // 下面至少有两个点
			ans++
		}
		if len(mx)-idxY-1 >= 2 { // 上面至少有两个点
			ans++
		}

		fmt.Fprintln(writer, ans)
	}
}
```