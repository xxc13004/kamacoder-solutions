# 模拟
[题目链接](https://kamacoder.com/problempage.php?pid=1363)
## 思路分析
记差值数组d为：先计算两个数组每个位置与前一个位置的差值，然后比较两个数组的差值，如果相等就记为1，不相等就记为0。

最后就是求差值数组的最长的连续1的数量就可以了。注意对最后一个数字需要特殊判断。
## 复杂度分析
1. 时间复杂度：O(n)；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n;
    cin >> n;
    int a[N], b[N], d[N], ans = 1;
    for (int i = 0; i < n; ++i) cin >> a[i];
    for (int i = 0; i < n; ++i) cin >> b[i];
    d[0] = 1;
    for (int i = 1; i < n; ++i) {
        int t1 = a[i] - a[i - 1];
        int t2 = b[i] - b[i - 1];
        if (t1 == t2) d[i] = 1;
        else d[i] = 0;
    }
    // 保证最后一个一定是不等的，哨兵作用
    d[n] = 0;
    for (int i = 0, j = 0; i <= n; ++i) {
        if (d[i]) continue;
        else {
            ans = max(ans, i - j);
            j = i;
        }
    }
    cout << ans << endl;
    return 0;
}
```
### Python
``` python
import sys

n = int(sys.stdin.readline())
a = list(map(int, sys.stdin.readline().split()))
b = list(map(int, sys.stdin.readline().split()))

d = [0] * (n + 1)  # 额外加一个位置作为哨兵
d[0] = 1

for i in range(1, n):
    t1 = a[i] - a[i-1]
    t2 = b[i] - b[i-1]
    d[i] = 1 if t1 == t2 else 0

d[n] = 0  # 哨兵，保证最后一个是不等的
ans = 1
j = 0

for i in range(n + 1):
    if d[i]:
        continue
    else:
        ans = max(ans, i - j)
        j = i

print(ans)
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        // 使用BufferedReader优化输入
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        
        int[] a = new int[n];
        int[] b = new int[n];
        
        // 读取并解析数组a
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            a[i] = Integer.parseInt(st.nextToken());
        }
        
        // 读取并解析数组b
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            b[i] = Integer.parseInt(st.nextToken());
        }
        
        int[] d = new int[n + 1]; // 额外加一个位置作为哨兵
        d[0] = 1;
        
        for (int i = 1; i < n; i++) {
            int t1 = a[i] - a[i - 1];
            int t2 = b[i] - b[i - 1];
            d[i] = (t1 == t2) ? 1 : 0;
        }
        
        d[n] = 0; // 哨兵，保证最后一个是不等的
        int ans = 1;
        int j = 0;
        
        for (int i = 0; i <= n; i++) {
            if (d[i] == 0) {
                ans = Math.max(ans, i - j);
                j = i;
            }
        }
        
        // 使用PrintWriter优化输出
        PrintWriter out = new PrintWriter(System.out);
        out.println(ans);
        out.flush();
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

func main() {
	// 使用bufio.Reader处理大量输入，设置较大的缓冲区
	reader := bufio.NewReaderSize(os.Stdin, 1<<20) // 1MB缓冲区
	data, _ := reader.ReadString('\n')
	n, _ := strconv.Atoi(strings.TrimSpace(data))

	// 读取并解析数组a
	data, _ = reader.ReadString('\n')
	aStr := strings.Fields(strings.TrimSpace(data))
	a := make([]int, n)
	for i := 0; i < n; i++ {
		a[i], _ = strconv.Atoi(aStr[i])
	}

	// 读取并解析数组b
	data, _ = reader.ReadString('\n')
	bStr := strings.Fields(strings.TrimSpace(data))
	b := make([]int, n)
	for i := 0; i < n; i++ {
		b[i], _ = strconv.Atoi(bStr[i])
	}

	d := make([]int, n+1) // 额外加一个位置作为哨兵
	d[0] = 1

	for i := 1; i < n; i++ {
		t1 := a[i] - a[i-1]
		t2 := b[i] - b[i-1]
		if t1 == t2 {
			d[i] = 1
		} else {
			d[i] = 0
		}
	}

	d[n] = 0 // 哨兵，保证最后一个是不等的
	ans := 1
	j := 0

	for i := 0; i <= n; i++ {
		if d[i] == 0 {
			if i-j > ans {
				ans = i - j
			}
			j = i
		}
	}

	// 使用bufio.Writer优化输出
	writer := bufio.NewWriter(os.Stdout)
	fmt.Fprintln(writer, ans)
	writer.Flush()
}
```