# 并查集
[题目链接](https://kamacoder.com/problempage.php?pid=1367)
## 思路分析
由于题目问的是两个节点之间是否存在一条路径，使得路径上的每个节点差值都小于等于指定的值。那么首先要保证的是这两个节点互通，那么有什么算法可以快速知道两个节点间是不是互通的呢？并查集可以实现这个功能。

首先我们可以注意到，这道题目的查询是无关顺序的，也就是说如果询问已经确定下来了，每次的询问的顺序发生了变化，不影响结果。即询问是独立的，可以称其为离线算法。

一般来讲，这种就可以往排序上面想，对询问进行排序，按照询问的高度差（k值）进行排序，并且对每条边进行同样的操作，计算每两个节点的边之间的高度差，按照高度差进行排序。

我们处理每一条询问（排序后），检查这个询问的k值，将路径数组的小于等于k的值的路径全部加入到并查集，即视为他们之间的边是有效的。然后检查这两个节点是不是联通的。这样只要是在并查集里面的节点一定是满足题意的。因为我们加入的是小于等于每一次询问的k值的所有边。

这里需要注意由于对询问进行了排序，所以最后的答案的顺序也会改变，所以需要注意记录排序之前的询问顺序。
## 复杂度分析
1. 时间复杂度：O(nlog(n) + qlog(q))；
2. 空间复杂度：O(n + q)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 200005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
// 并查集
vector<int> parent(N);
int find(int x) {
    if (parent[x] == x) {
        return x;
    }
    return parent[x] = find(parent[x]);
}
void merge(int x, int y) {
    int px = find(x);
    int py = find(y);
    if (px != py) {
        parent[px] = py;  // 将x的根节点指向y的根节点
    }
}
void init(int n) {
    for (int i = 0; i < n; ++i) {
        parent[i] = i;
    }
}
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n, m, q;
    cin >> n >> m >> q;
    init(n);  // 初始化并查集
    // 存储每座山的高度
    vector<int> heights(n);
    for (int i = 0; i < n; ++i) cin >> heights[i];
    // 按照每条路的高度差存储，从小到大
    vector<T3I> vt, queries;
    for (int i = 0, u, v; i < m; ++i) {
        cin >> u >> v;
        --u, --v;
        int diff = abs(heights[u] - heights[v]);
        vt.emplace_back(diff, u, v);
    }
    sort(vt.begin(), vt.end());
    reverse(vt.begin(), vt.end());  // 反转，方便从后往前处理
    // 读取查询
    for (int i = 0, u, v, k; i < q; ++i) {
        cin >> u >> v >> k;
        --u, --v;
        queries.emplace_back(k, u, v);
    }
    // 存储原来的查询顺序，并排序
    vector<int> indices(q);
    iota(indices.begin(), indices.end(), 0);
    sort(indices.begin(), indices.end(), [&](int i, int j) {
        return get<0>(queries[i]) < get<0>(queries[j]);
    });
    // 结果数组
    vector<int> ans(q);
    // 处理每个查询
    for (int i : indices) {
        auto [k, u, v] = queries[i];
        // 处理所有高度差小于等于k的边
        while (!vt.empty() && get<0>(vt.back()) <= k) {
            auto [_, x, y] = vt.back();
            vt.pop_back();
            merge(x, y);
        }
        // 检查u和v是否连通
        if (find(u) == find(v)) {
            ans[i] = 1;  // 连通
        } else {
            ans[i] = 0;  // 不连通
        }
    }
    // 输出结果
    for (int i = 0; i < q; ++i) {
        if (ans[i]) {
            cout << "YES" << endl;
        }
        else {
            cout << "NO" << endl;
        }
    }
    return 0;
}
```
### Python
``` python
import sys
from sys import stdin
from collections import defaultdict
sys.setrecursionlimit(1 << 25)

def main():
    n, m, q = map(int, stdin.readline().split())
    
    # 并查集
    parent = list(range(n))
    
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def merge(x, y):
        px = find(x)
        py = find(y)
        if px != py:
            parent[px] = py  # 将x的根节点指向y的根节点
    
    # 存储每座山的高度
    heights = list(map(int, stdin.readline().split()))
    
    # 按照每条路的高度差存储，从小到大
    vt = []
    for _ in range(m):
        u, v = map(int, stdin.readline().split())
        u -= 1
        v -= 1
        diff = abs(heights[u] - heights[v])
        vt.append((diff, u, v))
    
    vt.sort(reverse=True)  # 反转，方便从后往前处理
    
    # 读取查询
    queries = []
    for i in range(q):
        u, v, k = map(int, stdin.readline().split())
        u -= 1
        v -= 1
        queries.append((k, u, v, i))  # 保存原始索引
    
    # 按照k从小到大排序查询
    queries.sort()
    
    # 结果数组
    ans = [0] * q
    
    # 处理每个查询
    for k, u, v, idx in queries:
        # 处理所有高度差小于等于k的边
        while vt and vt[-1][0] <= k:
            _, x, y = vt.pop()
            merge(x, y)
        # 检查u和v是否连通
        if find(u) == find(v):
            ans[idx] = 1  # 连通
        else:
            ans[idx] = 0  # 不连通
    
    # 输出结果
    print('\n'.join('YES' if x else 'NO' for x in ans))

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.util.*;
import java.io.*;

public class Main {
    static int[] parent;
    
    static int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    static void merge(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px != py) {
            parent[px] = py;  // 将x的根节点指向y的根节点
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        
        String[] parts = br.readLine().split(" ");
        int n = Integer.parseInt(parts[0]);
        int m = Integer.parseInt(parts[1]);
        int q = Integer.parseInt(parts[2]);
        
        // 并查集初始化
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        
        // 存储每座山的高度
        int[] heights = new int[n];
        parts = br.readLine().split(" ");
        for (int i = 0; i < n; i++) {
            heights[i] = Integer.parseInt(parts[i]);
        }
        
        // 按照每条路的高度差存储，从小到大
        List<int[]> vt = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            parts = br.readLine().split(" ");
            int u = Integer.parseInt(parts[0]) - 1;
            int v = Integer.parseInt(parts[1]) - 1;
            int diff = Math.abs(heights[u] - heights[v]);
            vt.add(new int[]{diff, u, v});
        }
        
        // 按高度差降序排序
        vt.sort((a, b) -> Integer.compare(b[0], a[0]));
        
        // 读取查询
        List<int[]> queries = new ArrayList<>();
        for (int i = 0; i < q; i++) {
            parts = br.readLine().split(" ");
            int u = Integer.parseInt(parts[0]) - 1;
            int v = Integer.parseInt(parts[1]) - 1;
            int k = Integer.parseInt(parts[2]);
            queries.add(new int[]{k, u, v, i});
        }
        
        // 按照k从小到大排序查询
        queries.sort(Comparator.comparingInt(a -> a[0]));
        
        // 结果数组
        int[] ans = new int[q];
        
        // 处理每个查询
        for (int[] query : queries) {
            int k = query[0];
            int u = query[1];
            int v = query[2];
            int idx = query[3];
            
            // 处理所有高度差小于等于k的边
            while (!vt.isEmpty() && vt.get(vt.size() - 1)[0] <= k) {
                int[] edge = vt.remove(vt.size() - 1);
                merge(edge[1], edge[2]);
            }
            
            // 检查u和v是否连通
            if (find(u) == find(v)) {
                ans[idx] = 1;  // 连通
            } else {
                ans[idx] = 0;  // 不连通
            }
        }
        
        // 输出结果
        for (int i = 0; i < q; i++) {
            pw.println(ans[i] == 1 ? "YES" : "NO");
        }
        pw.flush();
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"os"
	"sort"
	"strconv"
)


var parent []int

func find(x int) int {
	if parent[x] != x {
		parent[x] = find(parent[x])
	}
	return parent[x]
}

func merge(x, y int) {
	px := find(x)
	py := find(y)
	if px != py {
		parent[px] = py // 将x的根节点指向y的根节点
	}
}

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Split(bufio.ScanWords)
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()

	scanner.Scan()
	n, _ := strconv.Atoi(scanner.Text())
	scanner.Scan()
	m, _ := strconv.Atoi(scanner.Text())
	scanner.Scan()
	q, _ := strconv.Atoi(scanner.Text())

	// 并查集初始化
	parent = make([]int, n)
	for i := 0; i < n; i++ {
		parent[i] = i
	}

	// 存储每座山的高度
	heights := make([]int, n)
	for i := 0; i < n; i++ {
		scanner.Scan()
		heights[i], _ = strconv.Atoi(scanner.Text())
	}

	// 按照每条路的高度差存储，从小到大
	type edge struct {
		diff int
		u    int
		v    int
	}
	edges := make([]edge, m)
	for i := 0; i < m; i++ {
		scanner.Scan()
		u, _ := strconv.Atoi(scanner.Text())
		scanner.Scan()
		v, _ := strconv.Atoi(scanner.Text())
		u--
		v--
		diff := heights[u] - heights[v]
		if diff < 0 {
			diff = -diff
		}
		edges[i] = edge{diff, u, v}
	}

	// 按高度差降序排序
	sort.Slice(edges, func(i, j int) bool {
		return edges[i].diff > edges[j].diff
	})

	// 读取查询
	type query struct {
		k     int
		u     int
		v     int
		index int
	}
	queries := make([]query, q)
	for i := 0; i < q; i++ {
		scanner.Scan()
		u, _ := strconv.Atoi(scanner.Text())
		scanner.Scan()
		v, _ := strconv.Atoi(scanner.Text())
		scanner.Scan()
		k, _ := strconv.Atoi(scanner.Text())
		u--
		v--
		queries[i] = query{k, u, v, i}
	}

	// 按照k从小到大排序查询
	sort.Slice(queries, func(i, j int) bool {
		return queries[i].k < queries[j].k
	})

	// 结果数组
	ans := make([]bool, q)

	// 处理每个查询
	for _, qry := range queries {
		k := qry.k
		u := qry.u
		v := qry.v
		idx := qry.index

		// 处理所有高度差小于等于k的边
		for len(edges) > 0 && edges[len(edges)-1].diff <= k {
			e := edges[len(edges)-1]
			edges = edges[:len(edges)-1]
			merge(e.u, e.v)
		}

		// 检查u和v是否连通
		if find(u) == find(v) {
			ans[idx] = true // 连通
		} else {
			ans[idx] = false // 不连通
		}
	}

	// 输出结果
	for i := 0; i < q; i++ {
		if ans[i] {
			writer.WriteString("YES\n")
		} else {
			writer.WriteString("NO\n")
		}
	}
}
```