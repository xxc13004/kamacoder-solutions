# 模拟
[题目链接](https://kamacoder.com/problempage.php?pid=1349)
## 思路分析
由于数据范围只有1000，所以分析题目，不难发现，一定存在一个答案，就算前面的所有字符都不成周期，整个字符串也一定可以构成周期。

这个周期可以通过枚举字符串的长度来求解，由于周期的范围一定会在[1, n]之间，n是字符串的长度。所以直接枚举周期即可。每次枚举的时候，假设当前枚举的周期是k，我们每隔k截取这个字符串，然后依次判断是否与前一段相同，如果遇到当前字符是\*号，那么就直接跳过，如果发现前一段是\*号，那么就要将周期字符串中当前这一位的字符更新为当前的字符。初始时刻，周期字符串是[0,k-1]这一段的字符串，依次在后续的过程中更新。如果找到每一段都相同，那么可以直接输出答案，由于是从小到大的枚举周期的，所以求出来的周期一定是最短的。

## 复杂度分析
1. 时间复杂度：O(n^2)；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    string s;
    cin >> s;
    int n = s.length();
    auto cmp = [&s, n](int j, string& last) -> bool {
        int i = last.length();
        int end = min(j + i, n);
        for (int p = j, q = 0; p < end; ++p, ++q) {
            // 如果两个字母有一个是'*'，那么一定能匹配上
            if (last[q] == '*' || s[p] == '*') {
                // 要将对应的周期确定下来
                if (s[p] != '*') last[q] = s[p];
                continue;
            }
            if (s[p] != last[q]) {
                return false;
            }
        }
        return true;
    };
    // 从小到大枚举周期
    for (int i = 1; i <= n; ++i) {
        bool flag = true;
        string last = s.substr(0, i);
        for (int j = i; j < n; j += i) {
            if (!cmp(j, last)) {
                flag = false;
                break;
            }
        }
        // 如果找到了一个周期，直接输出
        if (flag) {
            cout << i << endl << last << endl;
            break;
        }
    }
    return 0;
}
```
### Python
``` python
import sys

def main():
    s = sys.stdin.readline().strip()
    n = len(s)
    
    def cmp(j, last):
        i = len(last)
        end = min(j + i, n)
        q = 0
        for p in range(j, end):
            # 如果两个字母有一个是'*'，那么一定能匹配上
            if last[q] == '*' or s[p] == '*':
                # 要将对应的周期确定下来
                if s[p] != '*':
                    last[q] = s[p]
                q += 1
                continue
            if s[p] != last[q]:
                return False
            q += 1
        return True
    
    # 从小到大枚举周期
    for i in range(1, n + 1):
        flag = True
        last = list(s[:i])  # Convert to list for mutability
        for j in range(i, n, i):
            if not cmp(j, last):
                flag = False
                break
        # 如果找到了一个周期，直接输出
        if flag:
            print(i)
            print(''.join(last))
            break

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = br.readLine();
        int n = s.length();
        
        // Comparator function
        Cmp cmp = (j, last) -> {
            int i = last.length;
            int end = Math.min(j + i, n);
            int q = 0;
            for (int p = j; p < end; p++) {
                // 如果两个字母有一个是'*'，那么一定能匹配上
                if (last[q] == '*' || s.charAt(p) == '*') {
                    // 要将对应的周期确定下来
                    if (s.charAt(p) != '*') {
                        last[q] = s.charAt(p);
                    }
                    q++;
                    continue;
                }
                if (s.charAt(p) != last[q]) {
                    return false;
                }
                q++;
            }
            return true;
        };
        
        // 从小到大枚举周期
        for (int i = 1; i <= n; i++) {
            boolean flag = true;
            char[] last = s.substring(0, i).toCharArray();
            for (int j = i; j < n; j += i) {
                if (!cmp.compare(j, last)) {
                    flag = false;
                    break;
                }
            }
            // 如果找到了一个周期，直接输出
            if (flag) {
                System.out.println(i);
                System.out.println(new String(last));
                break;
            }
        }
    }
    
    interface Cmp {
        boolean compare(int j, char[] last);
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Scan()
	s := scanner.Text()
	n := len(s)

	cmp := func(j int, last []byte) bool {
		i := len(last)
		end := min(j+i, n)
		q := 0
		for p := j; p < end; p++ {
			// 如果两个字母有一个是'*'，那么一定能匹配上
			if last[q] == '*' || s[p] == '*' {
				// 要将对应的周期确定下来
				if s[p] != '*' {
					last[q] = s[p]
				}
				q++
				continue
			}
			if s[p] != last[q] {
				return false
			}
			q++
		}
		return true
	}

	// 从小到大枚举周期
	for i := 1; i <= n; i++ {
		flag := true
		last := []byte(s[:i])
		for j := i; j < n; j += i {
			if !cmp(j, last) {
				flag = false
				break
			}
		}
		// 如果找到了一个周期，直接输出
		if flag {
			fmt.Println(i)
			fmt.Println(string(last))
			break
		}
	}
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```