# 单调队列
[题目链接](https://kamacoder.com/problempage.php?pid=1384)
## 思路分析
我们需要求一个定长的窗口的最大值和最小值，如果我们直接暴力求解，那么枚举窗口左端点（或右端点）需要O(n), 求最大值最小值需要O(n)显然复杂度为O(n^2). 是过不了这道题的, 所以需要一个数据结构来优化这个算法.

单调队列: 可以维护一个窗口的最大值和最小值, 维护一个单调递增的和一个单调递减的队列, 队头的元素就是当前窗口的最大值或者最小值. 如果当前的元素比队列尾部的元素大, 那么可以把队尾的元素弹出, 直到这个元素是最大的队尾元素. 此时队头的元素就是最大的元素, 因为每一个元素都是以最大的队尾元素添加到队列的(说明这个元素前面的元素都比他大, 后面的元素都比他小), 所以等他到队头的时候, 那一定是最大的元素, 只有他前面的元素才会比他大, 但是这个元素成为队头的时候, 他前面已经没有元素了, 而后面的元素又都比他小, 所以他是最大的元素, 即队头元素是最大的元素. 对于最小值的维护只需要维护一个递减的序列即可, 此时队头的元素是最小的元素.

另外, 为了保证维护的是长度为k的窗口, 我们只需要在维护队列的时候存数组的下标即可, 这样每次队头的元素出队的时候, 判断这个下标是不是小于等于i-k的.
## 复杂度分析
1. 时间复杂度：O(n)；
2. 空间复杂度：O(k)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n, k;
    cin >> n >> k;
    vector<int> nums(n), ans;
    for (int i = 0; i < n; ++i) cin >> nums[i];
    deque<int> mxq, mnq;  // 维护滑动窗口最大值和最小值
    for (int i = 0; i < n; ++i) {
        while (!mxq.empty() && nums[mxq.back()] < nums[i]) mxq.pop_back();
        mxq.push_back(i);
        while (!mxq.empty() && mxq.front() <= i - k) mxq.pop_front();
        while (!mnq.empty() && nums[mnq.back()] > nums[i]) mnq.pop_back();
        mnq.push_back(i);
        while (!mnq.empty() && mnq.front() <= i - k) mnq.pop_front();
        if (i >= k - 1) ans.push_back(nums[mxq.front()] - nums[mnq.front()]);
    }
    for (int t : ans) cout << t << ',';
    return 0;
}
```
### Python
``` python
import sys
from collections import deque

def main():
    data = sys.stdin.read().split()
    n = int(data[0])
    k = int(data[1])
    nums = list(map(int, data[2:2+n]))
    
    mxq = deque()
    mnq = deque()
    ans = []
    
    for i in range(n):
        # 维护最大值队列（单调递减）
        while mxq and nums[mxq[-1]] < nums[i]:
            mxq.pop()
        mxq.append(i)
        if mxq[0] <= i - k:
            mxq.popleft()
            
        # 维护最小值队列（单调递增）
        while mnq and nums[mnq[-1]] > nums[i]:
            mnq.pop()
        mnq.append(i)
        if mnq[0] <= i - k:
            mnq.popleft()
            
        # 当窗口形成时计算差值
        if i >= k - 1:
            ans.append(nums[mxq[0]] - nums[mnq[0]])
    
    print(','.join(map(str, ans)))

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        
        int[] nums = new int[n];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            nums[i] = Integer.parseInt(st.nextToken());
        }
        
        Deque<Integer> mxq = new ArrayDeque<>();
        Deque<Integer> mnq = new ArrayDeque<>();
        List<Integer> ans = new ArrayList<>();
        
        for (int i = 0; i < n; i++) {
            // 维护最大值队列（单调递减）
            while (!mxq.isEmpty() && nums[mxq.peekLast()] < nums[i]) {
                mxq.pollLast();
            }
            mxq.offerLast(i);
            if (mxq.peekFirst() <= i - k) {
                mxq.pollFirst();
            }
            
            // 维护最小值队列（单调递增）
            while (!mnq.isEmpty() && nums[mnq.peekLast()] > nums[i]) {
                mnq.pollLast();
            }
            mnq.offerLast(i);
            if (mnq.peekFirst() <= i - k) {
                mnq.pollFirst();
            }
            
            // 当窗口形成时计算差值
            if (i >= k - 1) {
                ans.add(nums[mxq.peekFirst()] - nums[mnq.peekFirst()]);
            }
        }
        
        // 输出结果
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < ans.size(); i++) {
            if (i > 0) sb.append(',');
            sb.append(ans.get(i));
        }
        System.out.println(sb.toString());
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Split(bufio.ScanWords)
	
	scanner.Scan()
	n, _ := strconv.Atoi(scanner.Text())
	scanner.Scan()
	k, _ := strconv.Atoi(scanner.Text())
	
	nums := make([]int, n)
	for i := 0; i < n; i++ {
		scanner.Scan()
		nums[i], _ = strconv.Atoi(scanner.Text())
	}
	
	mxq := make([]int, 0)
	mnq := make([]int, 0)
	ans := make([]int, 0)
	
	for i := 0; i < n; i++ {
		// 维护最大值队列（单调递减）
		for len(mxq) > 0 && nums[mxq[len(mxq)-1]] < nums[i] {
			mxq = mxq[:len(mxq)-1]
		}
		mxq = append(mxq, i)
		if mxq[0] <= i-k {
			mxq = mxq[1:]
		}
		
		// 维护最小值队列（单调递增）
		for len(mnq) > 0 && nums[mnq[len(mnq)-1]] > nums[i] {
			mnq = mnq[:len(mnq)-1]
		}
		mnq = append(mnq, i)
		if mnq[0] <= i-k {
			mnq = mnq[1:]
		}
		
		// 当窗口形成时计算差值
		if i >= k-1 {
			ans = append(ans, nums[mxq[0]]-nums[mnq[0]])
		}
	}
	
	// 输出结果
	if len(ans) > 0 {
		result := make([]string, len(ans))
		for i, v := range ans {
			result[i] = strconv.Itoa(v)
		}
		fmt.Println(strings.Join(result, ","))
	} else {
		fmt.Println()
	}
}
```