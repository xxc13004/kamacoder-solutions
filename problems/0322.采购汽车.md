# 动态规划
[题目链接](https://kamacoder.com/problempage.php?pid=1402)
## 思路分析
由于题目给的车型的方案是相对价格，所以需要先将其转换为绝对价格。然后题目就是一个二维完全背包的问题。但是有一个特殊的点就是这题的可选择的物品属性可以超过背包的容量。

**状态定义：** dp[i][j]为装满i个人，j单位货物的最小价格。

**状态转移：** 对于第k辆车，对于当前已经遍历到的背包容量i, j，假设当前汽车的花费为c，载人数为m，载货数为n，那么令ni = min(x, i + m), nj = min(y, j + n)就是我们下一步可以转移的目标。如果选择这辆车就可以转移到ni, nj处，如果不选，则不变。其中x, y是题目中描述的目标，即背包容量。

**转移方程：** 
1. dp[ni][nj] = min(dp[ni][nj], dp[i][j] + c)

最终结果就是dp[x][y]。

## 复杂度分析
1. 时间复杂度：O(nxy)；
2. 空间复杂度：O(xy)。
## 代码实现
### Cpp
``` cpp
#include <bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    int x, y, n;
    cin >> x >> y >> n;
    vector<T3I> ops;  // 每种型号汽车的多种方案
    for (int i = 0; i < n; ++i) {
        int m, a, b, k;
        cin >> m >> a >> b >> k;
        // 默认方案
        ops.emplace_back(m, a, b);
        for (int j = 0; j < k; ++j) {
            int km, ka, kb;
            cin >> km >> ka >> kb;
            // 其他可选的方案，价格和载人，载货要相应累加
            ops.emplace_back(m + km, a + ka, b + kb);
        }
    }
    // dp[i][j]表示载人i，载货j所需的最小费用
    const LL INF = LLONG_MAX >> 1;
    vector<vector<LL>> dp(x + 1, vector<LL>(y + 1, INF));
    dp[0][0] = 0;
    // 完全背包，多维，注意超出容量也可以选择
    for (auto &[cost, people, goods] : ops) {
        for (int i = 0; i <= x; ++i) {
            for (int j = 0; j <= y; ++j) {
                int ni = min(x, i + people);
                int nj = min(y, j + goods);
                dp[ni][nj] = min(dp[ni][nj], dp[i][j] + cost);
            }
        }
    }
    cout << dp[x][y] << endl;
    return 0;
}
```
### Python
``` python
import sys

def main():
    data = sys.stdin.read().split()
    it = iter(data)
    x = int(next(it)); y = int(next(it)); n = int(next(it))
    
    ops = []  # 每种型号汽车的多种方案
    for _ in range(n):
        m = int(next(it)); a = int(next(it)); b = int(next(it)); k = int(next(it))
        # 默认方案
        ops.append((m, a, b))
        for _ in range(k):
            km = int(next(it)); ka = int(next(it)); kb = int(next(it))
            # 其他可选的方案，价格和载人，载货要相应累加
            ops.append((m + km, a + ka, b + kb))
    
    # dp[i][j]表示载人i，载货j所需的最小费用
    INF = float('inf')
    dp = [[INF] * (y + 1) for _ in range(x + 1)]
    dp[0][0] = 0
    
    # 完全背包，多维，注意超出容量也可以选择
    for cost, people, goods in ops:
        for i in range(x + 1):
            for j in range(y + 1):
                if dp[i][j] == INF:
                    continue
                ni = min(x, i + people)
                nj = min(y, j + goods)
                if dp[ni][nj] > dp[i][j] + cost:
                    dp[ni][nj] = dp[i][j] + cost
    
    print(dp[x][y])

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        Reader sc = new Reader();
        
        int x = sc.nextInt();
        int y = sc.nextInt();
        int n = sc.nextInt();
        
        // 每种型号汽车的多种方案
        List<int[]> ops = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            int m = sc.nextInt();
            int a = sc.nextInt();
            int b = sc.nextInt();
            int k = sc.nextInt();
            // 默认方案
            ops.add(new int[]{m, a, b});
            for (int j = 0; j < k; j++) {
                int km = sc.nextInt();
                int ka = sc.nextInt();
                int kb = sc.nextInt();
                // 其他可选的方案，价格和载人，载货要相应累加
                ops.add(new int[]{m + km, a + ka, b + kb});
            }
        }
        
        // dp[i][j]表示载人i，载货j所需的最小费用
        final long INF = Long.MAX_VALUE >> 1;
        long[][] dp = new long[x + 1][y + 1];
        for (int i = 0; i <= x; i++) {
            Arrays.fill(dp[i], INF);
        }
        dp[0][0] = 0;
        
        // 完全背包，多维，注意超出容量也可以选择
        for (int[] op : ops) {
            int cost = op[0];
            int people = op[1];
            int goods = op[2];
            for (int i = 0; i <= x; i++) {
                for (int j = 0; j <= y; j++) {
                    if (dp[i][j] == INF) continue;
                    int ni = Math.min(x, i + people);
                    int nj = Math.min(y, j + goods);
                    if (dp[ni][nj] > dp[i][j] + cost) {
                        dp[ni][nj] = dp[i][j] + cost;
                    }
                }
            }
        }
        
        System.out.println(dp[x][y]);
    }
    
    // 快速输入类
    static class Reader {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader() {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public int nextInt() throws IOException {
            int ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do {
                ret = ret * 10 + c - '0';
            } while ((c = read()) >= '0' && c <= '9');
            return neg ? -ret : ret;
        }

        private void fillBuffer() throws IOException {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1) buffer[0] = -1;
        }

        private byte read() throws IOException {
            if (bufferPointer == bytesRead) fillBuffer();
            return buffer[bufferPointer++];
        }
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"math"
	"os"
	"strconv"
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Split(bufio.ScanWords)
	
	// 读取输入
	x := nextInt(scanner)
	y := nextInt(scanner)
	n := nextInt(scanner)
	
	// 每种型号汽车的多种方案
	ops := make([][3]int, 0)
	for i := 0; i < n; i++ {
		m := nextInt(scanner)
		a := nextInt(scanner)
		b := nextInt(scanner)
		k := nextInt(scanner)
		// 默认方案
		ops = append(ops, [3]int{m, a, b})
		for j := 0; j < k; j++ {
			km := nextInt(scanner)
			ka := nextInt(scanner)
			kb := nextInt(scanner)
			// 其他可选的方案，价格和载人，载货要相应累加
			ops = append(ops, [3]int{m + km, a + ka, b + kb})
		}
	}
	
	// dp[i][j]表示载人i，载货j所需的最小费用
	INF := math.MaxInt64 >> 1
	dp := make([][]int64, x+1)
	for i := range dp {
		dp[i] = make([]int64, y+1)
		for j := range dp[i] {
			dp[i][j] = int64(INF)
		}
	}
	dp[0][0] = 0
	
	// 完全背包，多维，注意超出容量也可以选择
	for _, op := range ops {
		cost, people, goods := op[0], op[1], op[2]
		for i := 0; i <= x; i++ {
			for j := 0; j <= y; j++ {
				if dp[i][j] == int64(INF) {
					continue
				}
				ni := min(x, i+people)
				nj := min(y, j+goods)
				if dp[ni][nj] > dp[i][j]+int64(cost) {
					dp[ni][nj] = dp[i][j] + int64(cost)
				}
			}
		}
	}
	
	fmt.Println(dp[x][y])
}

func nextInt(scanner *bufio.Scanner) int {
	scanner.Scan()
	val, _ := strconv.Atoi(scanner.Text())
	return val
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```