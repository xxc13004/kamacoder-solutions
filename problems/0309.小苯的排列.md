# 动态规划
[题目链接](https://kamacoder.com/problempage.php?pid=1389)
## 思路分析
**状态定义：** 定义dp[i]为以数字i为结尾的严格上升子序列的数量。

**状态转移：** 如果当前的数字是j，那么以j为结尾的严格递增子序列数就为dp[j - 1]+dp[j]。因为我们前面已经形成了以j-1为结尾的严格递增子序列，这时候直接将j添加到末尾即可，并且之前以j为结尾的子序列数量不变。

**转移方程：** 

1. dp[j] = dp[j] + dp[j - 1] if dp[j - 1] != 0.

最后的结果就是以[1, n]为结尾的和，即dp数组的和，注意取模。

## 复杂度分析
1. 时间复杂度：O(n)，单组测试用例；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n;
    cin >> t;
    while (t--) {
        LL ans = 0;
        cin >> n;
        vector<int> nums(n), dp(n + 1);
        dp[0] = 1;
        for (int i = 0; i < n; ++i) {
            cin >> nums[i];
        }
        for (int i = 0; i < n; ++i) {
            if (dp[nums[i] - 1]) dp[nums[i]] += dp[nums[i] - 1];
            if (dp[nums[i]] >= MOD) dp[nums[i]] -= MOD;
        }
        for (LL i = 1; i <= n; ++i) {
            ans = (ans + dp[i] * i) % MOD;
        }
        cout << ans << endl;
    }
    return 0;
}
```
### Python
``` python
import sys

MOD = 1000000007

def main():
    input = sys.stdin.read().split()
    t = int(input[0])
    idx = 1
    
    for _ in range(t):
        n = int(input[idx]); idx += 1
        nums = []
        for i in range(n):
            nums.append(int(input[idx])); idx += 1
        
        dp = [0] * (n + 2)
        dp[0] = 1
        
        for num in nums:
            if dp[num - 1] > 0:
                dp[num] = (dp[num] + dp[num - 1]) % MOD
        
        ans = 0
        for i in range(1, n + 1):
            ans = (ans + dp[i] * i) % MOD
        
        print(ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    static final int MOD = 1000000007;
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        
        int t = Integer.parseInt(br.readLine());
        
        while (t-- > 0) {
            int n = Integer.parseInt(br.readLine());
            int[] nums = new int[n];
            
            st = new StringTokenizer(br.readLine());
            for (int i = 0; i < n; i++) {
                nums[i] = Integer.parseInt(st.nextToken());
            }
            
            int[] dp = new int[n + 2];
            dp[0] = 1;
            
            for (int num : nums) {
                if (dp[num - 1] > 0) {
                    dp[num] = (dp[num] + dp[num - 1]) % MOD;
                }
            }
            
            long ans = 0;
            for (int i = 1; i <= n; i++) {
                ans = (ans + (long) dp[i] * i) % MOD;
            }
            
            System.out.println(ans);
        }
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
)

const MOD = 1000000007

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Split(bufio.ScanWords)
	
	scanner.Scan()
	t, _ := strconv.Atoi(scanner.Text())
	
	for i := 0; i < t; i++ {
		scanner.Scan()
		n, _ := strconv.Atoi(scanner.Text())
		
		nums := make([]int, n)
		for j := 0; j < n; j++ {
			scanner.Scan()
			nums[j], _ = strconv.Atoi(scanner.Text())
		}
		
		dp := make([]int, n+2)
		dp[0] = 1
		
		for _, num := range nums {
			if dp[num-1] > 0 {
				dp[num] = (dp[num] + dp[num-1]) % MOD
			}
		}
		
		ans := 0
		for j := 1; j <= n; j++ {
			ans = (ans + dp[j]*j) % MOD
		}
		
		fmt.Println(ans)
	}
}
```