# 记忆化搜索
[题目链接](https://kamacoder.com/problempage.php?pid=1369)
## 思路分析
直接使用回溯枚举每一个情况即可，但是这样在数据拉满的情况下，一种有15!种情况，会超时。所以需要对算法进行优化，需采用记忆化搜索将时间复杂度优化到n\*2^n。

用位运算对状态进行表示，一个整数s表示当前已经枚举的集合，每次枚举的时候，如果之前已经选择过这个房屋，就跳过，否则就判断是否与前一个房屋的数字构成倍数的关系，不构成就不能选，构成就可以选择将这个房屋放在当前的位置。即dfs(s, last)表示当前已经枚举的房屋集合，以及上一个房屋的数字。

注意：最终的答案可能会达到15!，这个数是超过int的极限的，需要用long long存储。
## 复杂度分析
1. 时间复杂度：O(n\*2^n)；
2. 空间复杂度：O(m\*2^n)，其中m表示所有房屋中最大的数字。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i];
    int u = (1 << n) - 1;  // 全集u
    vector<vector<LL>> dp(*max_element(arr.begin(), arr.end()) + 1, vector<LL>(u + 1, -1LL));
    auto dfs = [&](auto&& dfs, int s, int last) -> LL {
        if (s == u) return 1;
        if (dp[last][s] >= 0) return dp[last][s];
        LL ret = 0;
        for (int i = 0; i < n; i++) {
            if (s & (1 << i) || (last % arr[i] && arr[i] % last)) continue;
            ret += dfs(dfs, s | (1 << i), arr[i]);
        }
        return dp[last][s] = ret;
    };
    cout << dfs(dfs, 0, 1) << endl;
    return 0;
}
```
### Python
``` python
# 读取输入
n = int(input())
arr = list(map(int, input().split()))
u = (1 << n) - 1  # 全集u
dp = [[-1] * (u + 1) for _ in range(max(arr) + 1)]

def dfs(s: int, last: int) -> int:
    if s == u:
        return 1
    if dp[last][s] >= 0:
        return dp[last][s]
    ret = 0
    for i in range(n):
        if s & (1 << i) or (last % arr[i] and arr[i] % last):
            continue
        ret += dfs(s | (1 << i), arr[i])
    dp[last][s] = ret
    return ret

print(dfs(0, 1))
```
### Java
``` java
import java.io.*;
import java.util.*;
public class Main {
	static int n;
	static int[] arr;
	static int u;
	static long[][] dp;
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		n = Integer.parseInt(br.readLine());
		arr = new int[n];
		StringTokenizer st = new StringTokenizer(br.readLine());
		for (int i = 0; i < n; i++) arr[i] = Integer.parseInt(st.nextToken());
		u = (1 << n) - 1;
		dp = new long[Arrays.stream(arr).max().getAsInt() + 1][u + 1];
		for (int i = 0; i < dp.length; i++) Arrays.fill(dp[i], -1);
		System.out.println(dfs(0, 1));
	}
	static long dfs(int s, int last) {
		if (s == u) return 1;
		if (dp[last][s] >= 0) return dp[last][s];
		long ret = 0;
		for (int i = 0; i < n; i++) {
			if ((s & (1 << i)) != 0 || (last % arr[i] != 0 && arr[i] % last != 0)) continue;
			ret += dfs(s | (1 << i), arr[i]);
		}
		return dp[last][s] = ret;
	}
}
```
### Go
``` go
package main
import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	reader := bufio.NewReader(os.Stdin)
	var n int
	fmt.Fscan(reader, &n)
	arr := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Fscan(reader, &arr[i])
	}
	u := (1 << uint(n)) - 1 // 全集u
	dp := make([][]int, 101)
	for i := range dp {
		dp[i] = make([]int, u + 1)
		for j := range dp[i] {
			dp[i][j] = -1
		}
	}
	var dfs func(s, last int) int
	dfs = func(s, last int) int {
		if s == u {
			return 1
		}
		if dp[last][s] >= 0 {
			return dp[last][s]
		}
		ret := 0
		for i := 0; i < n; i++ {
			if s & (1 << uint(i)) != 0 || (last % arr[i] != 0 && arr[i] % last != 0) {
				continue
			}
			ret += dfs(s | (1 << uint(i)), arr[i])
		}
		dp[last][s] = ret
		return ret
	}
	fmt.Println(dfs(0, 1))
}
```