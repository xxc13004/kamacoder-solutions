# 排序 + 二分
[题目链接](https://kamacoder.com/problempage.php?pid=1351)
## 思路分析
如果将题目改成，只取一堆糖果，那我们都知道怎么做，那就是枚举每一堆糖果作为要拿走的糖果，然后求出两份糖果的差值，最后取出差值绝对值的最小值作为答案。但是题目要求是必须拿走两堆，所以我们必须要知道在拿走两堆的情况下，什么情况是最优的，但是由于数据范围来到了2e5，所以不能直接内层循环再枚举另外一堆糖果，这样会超时。因此需要一个更高效的方法。怎么做？

由于答案与糖果的顺序无关，我们只关心糖果的数量，而不关心每堆糖果的顺序，所以可以考虑是否能对糖果进行排序，并且利用到有序这个特点。事实上，我们完全可以对糖果的数量进行排序。因为我们可以外层循环枚举每一堆糖果作为一定要拿走的糖果，假设枚举到了第i堆糖果作为一定要拿走的糖果，我们只需要知道剩下的糖果中，拿走哪堆糖果可以使得两份糖果的差值最小即可。为了方便起见，假设第i堆糖果的数量为t，那么第一份糖果的数量就是t\*k，设糖果的总数为sum，那么第二份糖果减已经拿走的糖果剩下的数量就是remain=sum-t\*k-t，我们只需要在剩下的糖果中求得一个数，使得x*k是第一个大于等于remain-x的数（可以化简为x\*(k+1) >= remain），或者第一个小于remain-x的数，就是在第一堆糖果已经确定的条件下，剩下糖果中的最优选择，然后我们对整个过程求最小值即可。这满足二分的条件，所以进行二分即可。二分可以帮我们求第一个大于等于或者第一个小于等于某个数的数。

注意二分的过程中的一些细节，不要让下标越界，添加一些特判即可。另外，如果我们在枚举第一个数的时候，如果发现t\*k已经大于等于remain了，那么剩下的能选的数一定是剩下的糖果中最小的那一堆糖果，因为第一堆糖果就已经出现了相等或者第一份糖果已经大于第二份糖果了，那么剩下来要想差值绝对值最小，第二份糖果一定要挑最少得选。

注：尤其注意int与long long的问题。

## 复杂度分析
1. 时间复杂度：O(nlog(n))；
2. 空间复杂度：O(1)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n, k;
    LL ans = LLONG_MAX;
    cin >> n >> k;
    vector<int> nums(n);
    for (int i = 0; i < n; ++i) cin >> nums[i];
    // 计算整个数组的和
    LL sum = accumulate(nums.begin(), nums.end(), 0LL);
    auto lower_bound = [=, &nums](LL target, int s) {
        // 找到第一个大于等于target的和第一个小于等于target的元素,这个才是当前情况的最优的选择
        int l = s, r = n - 1, mid;
        while (l <= r) {
            mid = (l + r) >> 1;
            LL nt = target - nums[mid];
            if (1LL * nums[mid] * k >= nt) r = mid - 1;
            else l = mid + 1;
        }
        return l;
    };
    sort(nums.begin(), nums.end());
    for (int i = 0; i < n; ++i) {
        int t = nums[i];
        // 如果只选了一个数就已经比剩下的所有部分还大的话，那另外的那个数一定只能选择最小的部分
        if (1LL * t * k >= sum - t && i != 0) ans = min(ans, abs(1LL * (nums[0] + t) * (k + 1) - sum));
        // 否则就要二分在后面找到最优的解，直接去后面找，避免找到的数与当前的数重复
        // 第一个大于等于的数
        int p = lower_bound(sum - 1LL * (k + 1) * t, i + 1);
        LL right = LLONG_MAX, left = LLONG_MAX;
        // 注意选择的数不能与当前的数重复，即每个数只能选一次
        if (p != n && p != i) right = abs(1LL * (t + nums[p]) * (k + 1) - sum);
        // 第一个小于的数就是大于等于的下标减1
        int q = p - 1;
        if (q >= 0 && q != i) left = abs(1LL * (t + nums[q]) * (k + 1) - sum);
        // 求出左边和右边的最小值
        ans = min({ans, left, right});
    }
    cout << ans << endl;
    return 0;
}
```
### Python
``` python
import sys
 
def main():
    input = sys.stdin.read
    data = input().split()
    idx = 0
    n = int(data[idx])
    k = int(data[idx+1])
    idx += 2
    nums = list(map(int, data[idx:idx+n]))
     
    sum_total = sum(nums)
    ans = float('inf')
     
    # 自定义lower_bound函数
    def lower_bound(target, s):
        l, r = s, n - 1
        while l <= r:
            mid = (l + r) // 2
            nt = target - nums[mid]
            if nums[mid] * k >= nt:
                r = mid - 1
            else:
                l = mid + 1
        return l
     
    nums.sort()
    for i in range(n):
        t = nums[i]
        # 如果只选一个数就比剩下的所有部分大，则另一个数选最小的
        if t * k >= sum_total - t and i != 0:
            ans = min(ans, abs((nums[0] + t) * (k + 1) - sum_total))
         
        # 否则在后面二分查找最优解
        p = lower_bound(sum_total - (k + 1) * t, i + 1)
        right = float('inf')
        left = float('inf')
         
        # 确保不重复选择同一个数
        if p != n and p != i:
            right = abs((t + nums[p]) * (k + 1) - sum_total)
        q = p - 1
        if q >= 0 and q != i:
            left = abs((t + nums[q]) * (k + 1) - sum_total)
         
        ans = min(ans, left, right)
     
    print(ans)
 
if __name__ == "__main__":
    main()  
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        
        int[] nums = new int[n];
        long sum = 0;
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            nums[i] = Integer.parseInt(st.nextToken());
            sum += nums[i];
        }
        
        long ans = Long.MAX_VALUE;
        
        // 自定义lower_bound函数
        class LowerBound {
            int find(long target, int s) {
                int l = s, r = n - 1;
                while (l <= r) {
                    int mid = (l + r) >>> 1;
                    long nt = target - nums[mid];
                    if ((long) nums[mid] * k >= nt) {
                        r = mid - 1;
                    } else {
                        l = mid + 1;
                    }
                }
                return l;
            }
        }
        LowerBound lowerBound = new LowerBound();
        
        Arrays.sort(nums);
        
        for (int i = 0; i < n; i++) {
            int t = nums[i];
            // 如果只选一个数就比剩下的所有部分大
            if ((long) t * k >= sum - t && i != 0) {
                long val = Math.abs((long) (nums[0] + t) * (k + 1) - sum);
                ans = Math.min(ans, val);
            }
            
            // 二分查找最优解
            int p = lowerBound.find(sum - (long)(k + 1) * t, i + 1);
            long right = Long.MAX_VALUE;
            long left = Long.MAX_VALUE;
            
            if (p != n && p != i) {
                right = Math.abs((long) (t + nums[p]) * (k + 1) - sum);
            }
            int q = p - 1;
            if (q >= 0 && q != i) {
                left = Math.abs((long) (t + nums[q]) * (k + 1) - sum);
            }
            
            ans = Math.min(ans, Math.min(left, right));
        }
        
        System.out.println(ans);
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"math"
	"os"
	"sort"
	"strconv"
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Split(bufio.ScanWords)

	// Read input
	scanner.Scan()
	n, _ := strconv.Atoi(scanner.Text())
	scanner.Scan()
	k, _ := strconv.Atoi(scanner.Text())

	nums := make([]int, n)
	var sum int64 = 0
	for i := 0; i < n; i++ {
		scanner.Scan()
		nums[i], _ = strconv.Atoi(scanner.Text())
		sum += int64(nums[i])
	}

	var ans int64 = math.MaxInt64

	// Custom lower_bound function
	lowerBound := func(target int64, s int) int {
		l, r := s, n-1
		for l <= r {
			mid := (l + r) / 2
			nt := target - int64(nums[mid])
			if int64(nums[mid])*int64(k) >= nt {
				r = mid - 1
			} else {
				l = mid + 1
			}
		}
		return l
	}

	sort.Ints(nums)

	for i := 0; i < n; i++ {
		t := nums[i]
		// 如果只选了一个数就已经比剩下的所有部分还大的话，那另外的那个数一定只能选择最小的部分
		if int64(t)*int64(k) >= sum-int64(t) && i != 0 {
			val := abs(int64(nums[0]+t)*int64(k+1) - sum)
			if val < ans {
				ans = val
			}
		}

		// 否则就要二分在后面找到最优的解，直接去后面找，避免找到的数与当前的数重复
		p := lowerBound(sum - int64(k + 1) * int64(t), i+1)
		var right, left int64 = math.MaxInt64, math.MaxInt64

		// 第一个大于等于的数
		if p != n && p != i {
			right = abs(int64(t+nums[p])*int64(k+1) - sum)
		}

		// 第一个小于的数就是大于等于的下标减1
		q := p - 1
		if q >= 0 && q != i {
			left = abs(int64(t+nums[q])*int64(k+1) - sum)
		}

		// 求出左边和右边的最小值
		ans = min(ans, min(left, right))
	}

	fmt.Println(ans)
}

func abs(x int64) int64 {
	if x < 0 {
		return -x
	}
	return x
}

func min(a, b int64) int64 {
	if a < b {
		return a
	}
	return b
}
```