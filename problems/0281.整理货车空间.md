# 动态规划
[题目链接](https://kamacoder.com/problempage.php?pid=1361)
## 思路分析
背包的模板题，定义dp[i][j]表示前i个货物在货车容量是j的情况下所能装的最大货物总体积，我们只需要求出在所有货物以及货车容量是v的情况下能装的总体积最多的货物就可以了，剩余的容量自然就是最小的。

于是就有转移方程：

1. dp[i][j] = max(dp[i][j], dp[i - 1][j - x] + x), x是当前货物的体积；

注意最后的答案是v-dp[v]，由于当前状态只与前一个状态有关，故可以将第一个维度优化掉。

## 复杂度分析
1. 时间复杂度：O(vn)；
2. 空间复杂度：O(v)。
## 代码实现
### Cpp
``` cpp
#include<bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int v, n;
    cin >> v >> n;
    vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        cin >> nums[i];
    }
    vector<int> dp(v + 1, 0);
    for (int i = 0; i < n; ++i) {
        for (int j = v; j >= nums[i]; --j) {
            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
        }
    }
    cout << v - dp[v] << endl;
    return 0;
}
```
### Python
``` python
import sys

v, n = map(int, sys.stdin.readline().strip().split())
nums = list(map(int, sys.stdin.readline().strip().split()))
# 背包
dp = [0] * (v + 1)
for i in range(n):
    for j in range(v, nums[i] - 1, -1):
        dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])
# 输出结果
print(v - dp[v])
```
### Java
``` java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int v = scanner.nextInt();
        int n = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        int[] dp = new int[v + 1];
        for (int i = 0; i < n; i++) {
            for (int j = v; j >= nums[i]; j--) {
                if (dp[j] < dp[j - nums[i]] + nums[i]) {
                    dp[j] = dp[j - nums[i]] + nums[i];
                }
            }
        }
        System.out.println(v - dp[v]);
    }
}
```
### Go
``` go
package main
import (
	"fmt"
)
func main() {
	var v, n int
	fmt.Scan(&v, &n)
	nums := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Scan(&nums[i])
	}
	dp := make([]int, v+1)
	for i := 0; i < n; i++ {
		for j := v; j >= nums[i]; j-- {
			if dp[j] < dp[j-nums[i]]+nums[i] {
				dp[j] = dp[j-nums[i]] + nums[i]
			}
		}
	}
	fmt.Println(v - dp[v])
}
```