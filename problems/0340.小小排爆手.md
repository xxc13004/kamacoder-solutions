# 哈希表 + 贪心
[题目链接](https://kamacoder.com/problempage.php?pid=1420)
## 思路分析

根据题意可知，最终不能出现两个数字之和为k的情况。所以用哈希表记录所有数出现的次数，如果x1出现y1次，而x2出现y2次，且x1 + x2 = k，那么最终的答案就需要加上min(y1, y2)。即我们把出现次数更少的那个删掉。

特殊情况：如果x1==x2，那么就需要把x1删到只剩下一个。所以针对k是偶数的情况需要特判。如k=6，数组为[3,3,3]，我们需要删掉两个3。

## 复杂度分析
1. 时间复杂度：O(n)；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include <bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n, k;
    cin >> n >> k;
    vector<int> nums(n);
    for (int i = 0; i < n; ++i) cin >> nums[i];
    unordered_map<int, int> ump;
    for (int t : nums) if (t < k) ++ump[t];  // 统计每个数的数量(<k)
    int ans = 0;
    for (int t : nums) {
        if (t >= k) continue;
        if (ump.count(t)) {
            int r = k - t;
            if (r == t) {  // 如果k刚好是t的两倍，则只需要保留一个就行，其他的全删掉
                ans += ump[t] - 1;
                ump.erase(t);  // 注意把这个数去除，避免重复计算
                continue;
            }
            if (ump.count(r)) {
                ans += min(ump[r], ump[t]);  // 只需要把数量更少的那一个删掉即可
                ump.erase(r);
                ump.erase(t);
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```
### Python
``` python
import sys
from collections import Counter

def main():
    # 优化输入
    input = sys.stdin.readline
    
    n, k = map(int, input().split())
    nums = list(map(int, input().split()))
    
    # 统计每个小于k的数的出现次数
    ump = {}
    for num in nums:
        if num < k:
            ump[num] = ump.get(num, 0) + 1
    
    ans = 0
    # 创建一个要处理的键列表，避免在遍历中修改字典
    keys_to_process = list(ump.keys())
    
    for num in keys_to_process:
        if num not in ump:  # 如果已经被处理过了
            continue
        
        r = k - num  # 配对的数
        
        if r == num:  # 如果k刚好是当前数的两倍
            # 只需要保留一个该数，其他都要删除
            ans += ump[num] - 1
            ump.pop(num, None)  # 从字典中移除，避免重复计算
            continue
        
        if r in ump:
            # 删除数量较少的那一组，保留数量较多的那一组
            ans += min(ump[num], ump[r])
            # 两个数都从字典中移除，避免重复计算
            ump.pop(r, None)
            ump.pop(num, None)
    
    print(ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        String[] firstLine = br.readLine().split(" ");
        int n = Integer.parseInt(firstLine[0]);
        int k = Integer.parseInt(firstLine[1]);
        
        String[] numsStr = br.readLine().split(" ");
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = Integer.parseInt(numsStr[i]);
        }
        
        // 统计每个小于k的数的出现次数
        Map<Integer, Integer> ump = new HashMap<>();
        for (int num : nums) {
            if (num < k) {
                ump.put(num, ump.getOrDefault(num, 0) + 1);
            }
        }
        
        int ans = 0;
        // 使用ArrayList来存储需要处理的键
        List<Integer> keys = new ArrayList<>(ump.keySet());
        
        for (int num : keys) {
            if (!ump.containsKey(num)) {
                continue; // 如果已经被处理过了
            }
            
            int r = k - num; // 配对的数
            
            if (r == num) {
                // 如果k刚好是当前数的两倍
                // 只需要保留一个该数，其他都要删除
                ans += ump.get(num) - 1;
                ump.remove(num); // 从字典中移除，避免重复计算
                continue;
            }
            
            if (ump.containsKey(r)) {
                // 删除数量较少的那一组，保留数量较多的那一组
                ans += Math.min(ump.get(num), ump.get(r));
                // 两个数都从字典中移除，避免重复计算
                ump.remove(r);
                ump.remove(num);
            }
        }
        
        System.out.println(ans);
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	// 优化输入输出
	reader := bufio.NewReader(os.Stdin)
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()
	
	var n, k int
	fmt.Fscan(reader, &n, &k)
	
	nums := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Fscan(reader, &nums[i])
	}
	
	// 统计每个小于k的数的出现次数
	ump := make(map[int]int)
	for _, num := range nums {
		if num < k {
			ump[num]++
		}
	}
	
	ans := 0
	// 收集所有需要处理的键
	keys := make([]int, 0, len(ump))
	for key := range ump {
		keys = append(keys, key)
	}
	
	for _, num := range keys {
		if _, exists := ump[num]; !exists {
			continue // 如果已经被处理过了
		}
		
		r := k - num // 配对的数
		
		if r == num {
			// 如果k刚好是当前数的两倍
			// 只需要保留一个该数，其他都要删除
			ans += ump[num] - 1
			delete(ump, num) // 从字典中移除，避免重复计算
			continue
		}
		
		if cnt, exists := ump[r]; exists {
			// 删除数量较少的那一组，保留数量较多的那一组
			if ump[num] < cnt {
				ans += ump[num]
			} else {
				ans += cnt
			}
			// 两个数都从字典中移除，避免重复计算
			delete(ump, r)
			delete(ump, num)
		}
	}
	
	fmt.Fprintln(writer, ans)
}
```