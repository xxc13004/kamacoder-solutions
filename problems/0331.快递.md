# Dijkstra
[题目链接](https://kamacoder.com/problempage.php?pid=1411)
## 思路分析
一共有k个快递点，要求每个点快递上门取件的最小时间，那么就是求快递点到当前点的最短路径。因为有多个点，所以是一个多源的最短路径问题。

利用Dijkstra算法从每一个快递点出发，求出到所有节点的最短路径。然后处理每一个查询，查询的结果就是最短路径。
## 复杂度分析
1. 时间复杂度：O((n + m) log n + q)；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include <bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    int n, m, k, q;
    cin >> n >> m >> k >> q;
    vector<int> p(k); // 快递点
    for (int i = 0; i < k; ++i) cin >> p[i];
    vector<vector<PIL>> graph(n + 1);  // 存储图
    for (int i = 0; i < m; ++i) {
        int a, b; LL c;
        cin >> a >> b >> c;
        graph[a].emplace_back(b, c);
        graph[b].emplace_back(a, c);
    }
    vector<int> qs(q);
    for (int i = 0; i < q; ++i) cin >> qs[i];
    vector<LL> dist(n + 1, LLONG_MAX >> 1);
    // 堆优化的Dijkstra
    priority_queue<pair<LL, int>, vector<pair<LL, int>>, greater<pair<LL, int>>> pq;
    // 多源的Dijkstra算法，将所有快递点作为起点
    for (int i = 0; i < k; ++i) {
        int start = p[i];
        dist[start] = 0;   // 快递点的最短路径是0
        pq.emplace(0, start);
    }
    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (d != dist[u]) continue;
        for (auto [v, w] : graph[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.emplace(dist[v], v);
            }
        }
    }

    // 处理询问
    for (int t : qs) {
        cout << dist[t] << endl;
    }
    return 0;
}
```
### Python
``` python
import heapq, sys

input = sys.stdin.readline
# 读取n, m, k, q
n, m, k, q = map(int, input().split())

# 读取快递点
p = list(map(int, input().split()))

# 构建图
graph = [[] for _ in range(n + 1)]
for _ in range(m):
    a, b, c = map(int, input().split())
    graph[a].append((b, c))
    graph[b].append((a, c))

# 读取查询点
queries = []
for _ in range(q):
    queries.append(int(input()))
# 初始化距离数组
INF = 10**18
dist = [INF] * (n + 1)

# 使用最小堆，多源Dijkstra
heap = []
for start in p:
    dist[start] = 0
    heapq.heappush(heap, (0, start))

# Dijkstra算法
while heap:
    d, u = heapq.heappop(heap)
    if d != dist[u]:
        continue
        
    for v, w in graph[u]:
        new_dist = d + w
        if new_dist < dist[v]:
            dist[v] = new_dist
            heapq.heappush(heap, (new_dist, v))

# 输出查询结果
out_lines = []
for t in queries:
    out_lines.append(str(dist[t]))

print("\n".join(out_lines))
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    static class Edge {
        int to;
        long weight;
        Edge(int to, long weight) {
            this.to = to;
            this.weight = weight;
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        int q = Integer.parseInt(st.nextToken());
        
        // 读取快递点
        int[] p = new int[k];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < k; i++) {
            p[i] = Integer.parseInt(st.nextToken());
        }
        
        // 构建邻接表
        List<List<Edge>> graph = new ArrayList<>(n + 1);
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<>());
        }
        
        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            long c = Long.parseLong(st.nextToken());
            graph.get(a).add(new Edge(b, c));
            graph.get(b).add(new Edge(a, c));
        }
        
        // 多源Dijkstra
        long[] dist = new long[n + 1];
        Arrays.fill(dist, Long.MAX_VALUE / 2);
        
        PriorityQueue<long[]> pq = new PriorityQueue<>(Comparator.comparingLong(a -> a[0]));
        for (int start : p) {
            dist[start] = 0;
            pq.offer(new long[]{0, start});
        }
        
        while (!pq.isEmpty()) {
            long[] curr = pq.poll();
            long d = curr[0];
            int u = (int) curr[1];
            
            if (d != dist[u]) continue;
            
            for (Edge edge : graph.get(u)) {
                int v = edge.to;
                long w = edge.weight;
                long newDist = d + w;
                if (newDist < dist[v]) {
                    dist[v] = newDist;
                    pq.offer(new long[]{newDist, v});
                }
            }
        }
        
        // 处理查询，每个查询一行
        for (int i = 0; i < q; i++) {
            int t = Integer.parseInt(br.readLine().trim());
            pw.println(dist[t]);
        }
        
        pw.flush();
        pw.close();
        br.close();
    }
}
```
### Go
``` go
package main

import (
    "bufio"
    "container/heap"
    "fmt"
    "os"
    "strconv"
    "strings"
)

const INF = 1 << 62

type Edge struct {
    to     int
    weight int64
}

type Item struct {
    node int
    dist int64
    index int
}

type PriorityQueue []*Item

func (pq PriorityQueue) Len() int { return len(pq) }
func (pq PriorityQueue) Less(i, j int) bool { return pq[i].dist < pq[j].dist }
func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
    pq[i].index = i
    pq[j].index = j
}

func (pq *PriorityQueue) Push(x interface{}) {
    n := len(*pq)
    item := x.(*Item)
    item.index = n
    *pq = append(*pq, item)
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    item.index = -1
    *pq = old[0 : n-1]
    return item
}

func main() {
    reader := bufio.NewReader(os.Stdin)
    writer := bufio.NewWriter(os.Stdout)
    defer writer.Flush()
    
    // 读取第一行
    line, _ := reader.ReadString('\n')
    fields := strings.Fields(line)
    n, _ := strconv.Atoi(fields[0])
    m, _ := strconv.Atoi(fields[1])
    k, _ := strconv.Atoi(fields[2])
    q, _ := strconv.Atoi(fields[3])
    
    // 读取快递点
    line, _ = reader.ReadString('\n')
    fields = strings.Fields(line)
    p := make([]int, k)
    for i := 0; i < k; i++ {
        p[i], _ = strconv.Atoi(fields[i])
    }
    
    // 构建图
    graph := make([][]Edge, n+1)
    for i := 0; i < m; i++ {
        line, _ = reader.ReadString('\n')
        fields = strings.Fields(line)
        a, _ := strconv.Atoi(fields[0])
        b, _ := strconv.Atoi(fields[1])
        c, _ := strconv.ParseInt(fields[2], 10, 64)
        
        graph[a] = append(graph[a], Edge{b, c})
        graph[b] = append(graph[b], Edge{a, c})
    }
    
    // 多源Dijkstra
    dist := make([]int64, n+1)
    for i := 0; i <= n; i++ {
        dist[i] = INF
    }
    
    pq := make(PriorityQueue, 0)
    heap.Init(&pq)
    
    for _, start := range p {
        dist[start] = 0
        heap.Push(&pq, &Item{node: start, dist: 0})
    }
    
    for pq.Len() > 0 {
        item := heap.Pop(&pq).(*Item)
        u := item.node
        d := item.dist
        
        if d != dist[u] {
            continue
        }
        
        for _, edge := range graph[u] {
            v := edge.to
            w := edge.weight
            newDist := d + w
            if newDist < dist[v] {
                dist[v] = newDist
                heap.Push(&pq, &Item{node: v, dist: newDist})
            }
        }
    }
    
    // 处理查询，每个查询一行
    for i := 0; i < q; i++ {
        line, _ = reader.ReadString('\n')
        t, _ := strconv.Atoi(strings.TrimSpace(line))
        fmt.Fprintln(writer, dist[t])
    }
}
```