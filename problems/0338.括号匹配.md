# 模拟
[题目链接](https://kamacoder.com/problempage.php?pid=1418)
## 思路分析

用栈模拟，如果遇到右括号与栈顶的左括号不匹配，就需要修改一次，答案加一。直到遍历完整个字符串。

## 复杂度分析
1. 时间复杂度：O(tn)；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include <bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    cin >> t;
    char h[128]{};
    h[']'] = '[';
    h['}'] = '{';
    while (t--) {
        string s;
        stack<char> st;
        int ans = 0;
        cin >> s;
        for (char c : s) {
            if (c == '{' || c == '[') st.push(c);
            else {
                if (st.top() != h[c]) ++ans;  // 题目数据保证一定是有效的括号，所以不会出现栈为空的情况
                st.pop();
            }
        }
        cout << ans << endl;
    }
    return 0;
}
```
### Python
``` python
import sys

def main():
    # 优化输入
    input = sys.stdin.readline
    
    # 括号映射表：右括号 -> 对应的左括号
    bracket_map = {')': '(', ']': '[', '}': '{'}
    
    t = int(input().strip())
    
    for _ in range(t):
        s = input().strip()
        stack = []
        ans = 0
        
        # 遍历字符串中的每个字符
        for c in s:
            if c in '([{':
                # 左括号入栈
                stack.append(c)
            else:
                # 右括号：检查栈顶是否匹配
                if not stack or stack[-1] != bracket_map[c]:
                    ans += 1
                stack.pop()
        
        print(ans)

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        // 优化输入输出
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        // 括号映射表：右括号 -> 对应的左括号
        Map<Character, Character> bracketMap = new HashMap<>();
        bracketMap.put(')', '(');
        bracketMap.put(']', '[');
        bracketMap.put('}', '{');
        
        int t = Integer.parseInt(br.readLine().trim());
        
        while (t-- > 0) {
            String s = br.readLine().trim();
            Stack<Character> stack = new Stack<>();
            int ans = 0;
            
            // 遍历字符串中的每个字符
            for (int i = 0; i < s.length(); i++) {
                char c = s.charAt(i);
                
                if (c == '(' || c == '[' || c == '{') {
                    // 左括号入栈
                    stack.push(c);
                } else {
                    // 右括号：检查栈顶是否匹配
                    // 根据题意，保证是有效括号，所以栈不会为空
                    if (stack.peek() != bracketMap.get(c)) {
                        ans++;
                    }
                    stack.pop();
                }
            }
            
            bw.write(ans + "\n");
        }
        
        bw.flush();
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	// 优化输入输出
	reader := bufio.NewReader(os.Stdin)
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()
	
	// 括号映射表：右括号 -> 对应的左括号
	bracketMap := map[byte]byte{
		')': '(',
		']': '[',
		'}': '{',
	}
	
	var t int
	fmt.Fscan(reader, &t)
	
	for ; t > 0; t-- {
		var s string
		fmt.Fscan(reader, &s)
		
		stack := make([]byte, 0, len(s))
		ans := 0
		
		// 遍历字符串中的每个字符
		for i := 0; i < len(s); i++ {
			c := s[i]
			
			if c == '(' || c == '[' || c == '{' {
				// 左括号入栈
				stack = append(stack, c)
			} else {
				// 右括号：检查栈顶是否匹配
				// 根据题意，保证是有效括号，所以栈不会为空
				if stack[len(stack)-1] != bracketMap[c] {
					ans++
				}
				stack = stack[:len(stack)-1] // 弹出栈顶
			}
		}
		
		fmt.Fprintln(writer, ans)
	}
}
```