# 数学
[题目链接](https://kamacoder.com/problempage.php?pid=1366)
## 思路分析
做这道题需要知道一个结论：数组中所有元素乘积尾部的0的数量取决于**数组中每个元素的因子2与因子5的总和的最小值**。举个例子：如果数组中所有元素的因子2的总和为8个，而因子5的数量为3个，那么这些元素的乘积的尾部0的个数就是min(3, 8)=3个。

有了这个结论，那么就只需要求出数组中因子2和因子5对应的总和，然后枚举每一个元素，将他们分别+1，然后与原始的尾部0进行比较，求一个最大值即可。
## 复杂度分析
1. 时间复杂度：O(nlog(C))，求因子的复杂度是log级别，需要对每一个数都求一次；
2. 空间复杂度：O(n)。
## 代码实现
### Cpp
``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

pair<int, int> get2_5(int x) {
    int count2 = 0, count5 = 0;
    while (x % 2 == 0) {
        count2++;
        x /= 2;
    }
    while (x % 5 == 0) {
        count5++;
        x /= 5;
    }
    return {count2, count5};
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        cin >> nums[i];
    }

    vector<pair<int, int>> factors(n);
    // 计算因子2和5的总数，即不进行任何操作的结尾0的数量
    int cnt2 = 0, cnt5 = 0;
    for (int i = 0; i < n; ++i) {
        factors[i] = get2_5(nums[i]);
        cnt2 += factors[i].first;
        cnt5 += factors[i].second;
    }

    // 枚举对每一个数操作的结果
    int ans = min(cnt2, cnt5);
    for (int i = 0; i < n; ++i) {
        auto [new2, new5] = get2_5(nums[i] + 1);
        int new_cnt2 = cnt2 - factors[i].first + new2;
        int new_cnt5 = cnt5 - factors[i].second + new5;
        ans = max(ans, min(new_cnt2, new_cnt5));
    }

    cout << ans << endl;
    return 0;
}
```
### Python
``` python
n = int(input().strip())
nums = list(map(int, input().strip().split()))

def get2_5(x):
    # 获取数字x的2和5的个数
    count2, count5 = 0, 0
    while x % 2 == 0:
        count2 += 1
        x //= 2
    while x % 5 == 0:
        count5 += 1
        x //= 5
    return count2, count5

# 计算所有数字的2和5的个数
factors = [get2_5(x) for x in nums]
cnt2 = sum(count2 for count2, _ in factors)
cnt5 = sum(count5 for _, count5 in factors)
ans = min(cnt2, cnt5)
for idx, x in enumerate(nums):
    count2, count5 = get2_5(x + 1)
    ans = max(ans, min(cnt2 - factors[idx][0] + count2, cnt5 - factors[idx][1] + count5))
print(ans)
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static int[] get2_5(int x) {
        int count2 = 0, count5 = 0;
        while (x % 2 == 0) {
            count2++;
            x /= 2;
        }
        while (x % 5 == 0) {
            count5++;
            x /= 5;
        }
        return new int[]{count2, count5};
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int[] nums = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();

        int[][] factors = new int[n][2];
        // 计算因子2和5的总数，即不进行任何操作的结尾0的数量
        int cnt2 = 0, cnt5 = 0;
        for (int i = 0; i < n; i++) {
            factors[i] = get2_5(nums[i]);
            cnt2 += factors[i][0];
            cnt5 += factors[i][1];
        }
        // 枚举每一种情况，可能产生的结果
        int ans = Math.min(cnt2, cnt5);
        for (int i = 0; i < n; i++) {
            int[] newFactors = get2_5(nums[i] + 1);
            int newCnt2 = cnt2 - factors[i][0] + newFactors[0];
            int newCnt5 = cnt5 - factors[i][1] + newFactors[1];
            ans = Math.max(ans, Math.min(newCnt2, newCnt5));
        }

        System.out.println(ans);
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
)

func get2_5(x int) (int, int) {
	count2, count5 := 0, 0
	for x%2 == 0 {
		count2++
		x /= 2
	}
	for x%5 == 0 {
		count5++
		x /= 5
	}
	return count2, count5
}

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Split(bufio.ScanWords)

	scanner.Scan()
	n, _ := strconv.Atoi(scanner.Text())

	nums := make([]int, n)
	for i := 0; i < n; i++ {
		scanner.Scan()
		nums[i], _ = strconv.Atoi(scanner.Text())
	}

	factors := make([][2]int, n)
	// 计算因子2和5的总数，即不进行任何操作的结尾0的数量
	cnt2, cnt5 := 0, 0
	for i := 0; i < n; i++ {
		factors[i][0], factors[i][1] = get2_5(nums[i])
		cnt2 += factors[i][0]
		cnt5 += factors[i][1]
	}

	ans := min(cnt2, cnt5)
	for i := 0; i < n; i++ {
		new2, new5 := get2_5(nums[i] + 1)
		newCnt2 := cnt2 - factors[i][0] + new2
		newCnt5 := cnt5 - factors[i][1] + new5
		if min(newCnt2, newCnt5) > ans {
			ans = min(newCnt2, newCnt5)
		}
	}

	fmt.Println(ans)
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```