# 位运算 + 贪心
[题目链接](https://kamacoder.com/problempage.php?pid=1404)
## 思路分析
异或运算有一个性质是：异或同一个数两次之后其值不变。例如 => ``` a ^ x = b, b ^ x = a，即 a ^ x ^ x = a ```。

所以对于数组中的每个数a[i]只有异或x奇数次和偶数次的两种状态，奇数次只会改变为a[i] ^ x，偶数次值会回到a[i]。

对于这道题来说，由于每次操作都需要对数组中两个相邻的数进行操作，而这种操作是可以传递的。换句话说，我们最终的状态一定是选择数组中的偶数个数进行异或操作，且不管这偶数个数的下标是什么，也就是无关位置的。

题目就变成了将数组中的每一个数a[i]都与x进行异或操作，然后将他们与a[i]做差d = (a[i] ^ x) - a[i]，将结果都保存到数组里面。我们的目标是从d数组中选取任意偶数个出来，使得增量最大。由于可以不进行任何操作，所以，选取的d一定要大于0。只需要对d数组进行排序即可，选前面偶数个最大的正数，这就是对原始数组的增量dmax。

最终结果就是sum(a) + dmax。
## 复杂度分析
1. 时间复杂度：O(nlogn)；
2. 空间复杂度：O(n)。
## 代码实现

### Cpp
``` cpp
#include <bits/stdc++.h>
#define endl '\n'
const int N = 100005, MOD = 1000000007;
using namespace std;
using LL = long long;
using PIL = pair<int, LL>;
using PII = pair<int, int>;
using T3I = tuple<int, int, int>;
int t = 0, dir[]{1, 0, -1, 0, 1};
int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    cin >> t;
    while (t--) {
        int n, x;
        cin >> n >> x;
        vector<int> a(n);
        for (int i = 0; i < n; i++) cin >> a[i];
        vector<int> d(n);
        // 计算每个位置异或后的增量
        for (int i = 0; i < n; i++) d[i] = (a[i] ^ x) - a[i];
        sort(d.rbegin(), d.rend());  // 降序排序
        LL dmax = 0;
        // 选择前偶数个正增量
        for (int i = 0; i + 1 < n; i += 2) {
            int sum_pair = d[i] + d[i + 1];
            if (sum_pair > 0) {
                dmax += sum_pair;
            } else {
                break;
            }
        }
        LL total = accumulate(a.begin(), a.end(), 0LL);
        cout << total + dmax << endl;
    }
    return 0;
}
```
### Python
``` python
import sys

def main():
    input = sys.stdin.read().split()
    t = int(input[0])
    idx = 1
    results = []
    
    for _ in range(t):
        n = int(input[idx]); idx += 1
        x = int(input[idx]); idx += 1
        a = []
        for i in range(n):
            a.append(int(input[idx])); idx += 1
        
        # 计算每个位置异或后的增量
        d = []
        for i in range(n):
            d.append((a[i] ^ x) - a[i])
        
        d.sort(reverse=True)  # 降序排序
        dmax = 0
        # 选择前偶数个正增量
        for i in range(0, n - 1, 2):
            sum_pair = d[i] + d[i + 1]
            if sum_pair > 0:
                dmax += sum_pair
            else:
                break
        
        total = sum(a)
        results.append(str(total + dmax))
    
    print("\n".join(results))

if __name__ == "__main__":
    main()
```
### Java
``` java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        Reader sc = new Reader();
        
        int t = sc.nextInt();
        StringBuilder results = new StringBuilder();
        
        while (t-- > 0) {
            int n = sc.nextInt();
            int x = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
            }
            
            // 计算每个位置异或后的增量
            int[] d = new int[n];
            for (int i = 0; i < n; i++) {
                d[i] = (a[i] ^ x) - a[i];
            }
            
            // 降序排序
            Integer[] dInteger = new Integer[n];
            for (int i = 0; i < n; i++) {
                dInteger[i] = d[i];
            }
            Arrays.sort(dInteger, Collections.reverseOrder());
            
            long dmax = 0;
            // 选择前偶数个正增量
            for (int i = 0; i + 1 < n; i += 2) {
                int sum_pair = dInteger[i] + dInteger[i + 1];
                if (sum_pair > 0) {
                    dmax += sum_pair;
                } else {
                    break;
                }
            }
            
            long total = 0;
            for (int num : a) {
                total += num;
            }
            results.append(total + dmax).append("\n");
        }
        
        System.out.print(results);
    }
    
    // 快速输入类
    static class Reader {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader() {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public int nextInt() throws IOException {
            int ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do {
                ret = ret * 10 + c - '0';
            } while ((c = read()) >= '0' && c <= '9');
            return neg ? -ret : ret;
        }

        private void fillBuffer() throws IOException {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1) buffer[0] = -1;
        }

        private byte read() throws IOException {
            if (bufferPointer == bytesRead) fillBuffer();
            return buffer[bufferPointer++];
        }
    }
}
```
### Go
``` go
package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
	"strconv"
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Split(bufio.ScanWords)
	
	t := nextInt(scanner)
	results := make([]string, 0, t)
	
	for ; t > 0; t-- {
		n := nextInt(scanner)
		x := nextInt(scanner)
		a := make([]int, n)
		for i := 0; i < n; i++ {
			a[i] = nextInt(scanner)
		}
		
		// 计算每个位置异或后的增量
		d := make([]int, n)
		for i := 0; i < n; i++ {
			d[i] = (a[i] ^ x) - a[i]
		}
		
		sort.Sort(sort.Reverse(sort.IntSlice(d))) // 降序排序
		dmax := 0
		// 选择前偶数个正增量
		for i := 0; i+1 < n; i += 2 {
			sum_pair := d[i] + d[i+1]
			if sum_pair > 0 {
				dmax += sum_pair
			} else {
				break
			}
		}
		
		total := 0
		for _, num := range a {
			total += num
		}
		results = append(results, strconv.Itoa(total+dmax))
	}
	
	for _, res := range results {
		fmt.Println(res)
	}
}

func nextInt(scanner *bufio.Scanner) int {
	scanner.Scan()
	val, _ := strconv.Atoi(scanner.Text())
	return val
}
```